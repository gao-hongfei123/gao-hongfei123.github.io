<!DOCTYPE html>
<html lang="en">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="技术爱好者" />



<meta name="description" content="title: csharp语法 vs设置vs中F6键：生成语法错误，可以定位到错误位置。 设置当前启动项目，点击解决资源管理器，右击，属性，启动项目设置为当前选定内容。 多行注释：ctrl + k+c,取消多行注释：ctrl +k +u 输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键 构造器快捷键：ctor+两次tab键 快速创建属性的快捷键：porp+两次">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: csharp语法 vs设置vs中F6键：生成语法错误，可以定位到错误位置。 设置当前启动项目，点击解决资源管理器，右击，属性，启动项目设置为当前选定内容。 多行注释：ctrl + k+c,取消多行注释：ctrl +k +u 输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键 构造器快捷键：ctor+两次tab键 快速创建属性的快捷键：porp+两次">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png">
<meta property="og:image" content="file:///C:/Users/Administrator/AppData/Local/Temp/ksohtml7308/wps1.jpg">
<meta property="og:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214254615.png">
<meta property="og:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214539229.png">
<meta property="og:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214620011.png">
<meta property="og:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20220129112920767.png">
<meta property="article:published_time" content="2022-07-17T01:44:21.865Z">
<meta property="article:modified_time" content="2022-10-30T02:34:18.710Z">
<meta property="article:author" content="技术爱好者">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">



<link rel="stylesheet" href="/css/style.css">




<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






<meta name="generator" content="Hexo 6.2.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/aaa.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/"></a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>Menu</li>
                        <li>Tags</li>
                        
                        <li>Friends</li>
                        
                        
                        <li>About Me</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/%E9%9A%8F%E7%AC%94">随笔</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="/303515096@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" target="_blank" rel="noopener" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">技术爱好者</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页"></a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/aaa.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页"></a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/%E9%9A%8F%E7%AC%94">随笔</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="/303515096@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="#" title="GitHub"></a>
                            
                                <a class="fa RSS" target="_blank" href="/atom.xml" title="RSS"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="Tags" friends="Friends" about="About Me"/>
</nav>
      <div class="body-wrap"><article id="post-csharp学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/" class="article-date">
      <time datetime="2022-07-17T01:44:21.865Z" itemprop="datePublished">2022-07-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>title: csharp语法</p>
<h2 id="vs设置"><a href="#vs设置" class="headerlink" title="vs设置"></a>vs设置</h2><p>vs中F6键：生成语法错误，可以定位到错误位置。</p>
<p>设置当前启动项目，点击解决资源管理器，右击，属性，启动项目设置为当前选定内容。</p>
<p>多行注释：ctrl + k+c,取消多行注释：ctrl +k +u</p>
<p>输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键</p>
<p>构造器快捷键：ctor+两次tab键</p>
<p>快速创建属性的快捷键：porp+两次tab键</p>
<p>激活key：BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<p>对于一些控件的属性设置在，视图选项卡的属性可以调出</p>
<p>鼠标放在某个类上直接按住F1键，会自动定位到对该类的解释文档。</p>
<p>直接删除某行ctrl+L</p>
<p>assembly ：类库</p>
<p>Ctrl+.快捷键或者ctrl+j，是智能识别快捷键，相当于eclipse中的alt+&#x2F;,java中完全使用接口interface代替了委托</p>
<p>自动实现接口中的所有方法：alt+insert</p>
<p>替换快捷键：ctrl+r</p>
<p>获取某一方法的所有重载：光标在括号内，然后ctrl+shift+空格</p>
<p>向下复制ctrl+d</p>
<p>插入空行：ctrl+enter</p>
<p>多个光标同时操作：alt+鼠标左键</p>
<p>if+tab</p>
<p>for+tab</p>
<p>删除行ctrl+l</p>
<p>整理代码：ctrl+k+f</p>
<h2 id="git推送"><a href="#git推送" class="headerlink" title="git推送"></a>git推送</h2><p>1.git init，使用之前的git文件就行</p>
<p>2.git add “文件夹名称”</p>
<p>3.git commit -m “注释”</p>
<p>4.git remote add origin <a target="_blank" rel="noopener" href="https://github.com/gao-hongfei123/Project.git">https://github.com/gao-hongfei123/Project.git</a></p>
<p>5.git pull origin master 若是不成功，在upload文件夹下执行git clean -d -fx,清除所有文件</p>
<p>6.git push -u origin master&#x2F;&#x2F;使用密码登录已经不行了，必须使用taken登录</p>
<p>taken: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</p>
<span id="more"></span>

<h2 id="窗口设置"><a href="#窗口设置" class="headerlink" title="窗口设置"></a>窗口设置</h2><p>窗口标题更改：属性：外观，text修改即可</p>
<p>修改窗口左上角小图标：窗口样式，Icon，选择图片进行设置即可，最大不超过72x72</p>
<p>窗体出现的位置设置：布局，startposition。</p>
<p>固定窗口的大小，不允许改变：布局，AntoSize&#x3D; false</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><p>方法重载区别点：1.返回类型，2.传参类型，3.传参数目</p>
<p>判断类，数据类型等，type a &#x3D; typeof(int);</p>
<p>类的继承：使用‘：’进行继承，而java中是使用extends关键词进行继承，代码如下</p>
<p>class Person : Student{</p>
<p>}</p>
<p><strong>StringBuilder</strong>: 与string的区别是，前者是针对原对象进行操作的，而后者是复制一个新对象，在新对象上面进行操作。如果对字符串操作频繁，推荐使用前者，若是只操作几次，则推荐使用string，避免产生过多的对象。</p>
<p><strong>Sizeof</strong>方法只能计算基本数据类型的大小。例如sizeof(int)。</p>
<p>对一个变量求相反数：- -x这是错误的，-(-x)这是正确的。</p>
<p>While语句与for语句的使用情况，当知道执行循环次数的时候使用for循环，其他情况的时候都是使用while语句。Foreach语句是迭代器，只能用于迭代集合中的元素或者数组。</p>
<p><strong>readonly关键字：</strong>表示该变量只能被赋予一次值 public readonly int ID;使用该关键字修饰的字段类似于const关键字，其中const修饰的字段只能在声明中赋值，而readonly可以在声明中或者在构造函数中赋值。第二是const只能修饰基元，枚举，字符串类型，而readonly可以修饰任意类型。所以最好是用readonly替换const</p>
<p>**Guid;**global unique  identifier全球唯一标识符</p>
<p>main方法中string[] args 说明声明的是长度为0的字符串数组。</p>
<p>栈：存储局部变量			</p>
<p>堆：new出来的对象</p>
<p> 默认赋值：整形：0，浮点型0.0，布尔型：false，字符型：\u0000;</p>
<p>静态：非静态成员方法既可以访问静态，也可以访问非静态，静态成员方法只可以访问静态</p>
<p>Public 不同项目中可以使用  internal(或者不写)限制在统一个项目中，被sealed修饰的类不能被继承，子类访问级别不能超过父类</p>
<p>**Typeof()运算符:**返回的是个Type类型等价于使用getType()方法,可以用它来作为反射,在winform中使用的场景是判断某个控件属于什么类型，例如一个button对象btn  If(btn.getType()&#x3D;&#x3D;typeof(TextBox))&#x2F;&#x2F;判断btn这个对象是否属于button类型</p>
<p>**Nameof(var)运算符:**返回的是变量名而不是变量值。例如console.writeLine(nameof(var1));返回的是var1,例2:console.writeLine(nameof(Myclass.method1))&#x2F;&#x2F;返回的是method1,使用它的作用就是防止在重命名变量名的时候，使用该变量名的字符串没有更改。如下</p>
<p>public static void method()</p>
<p>​    {</p>
<p>​      Console.WriteLine( “method”+”:输入”);</p>
<p>​      Console.WriteLine(“method” + “:输出”);</p>
<p>​    }</p>
<p>当使用vs的重命名功能修改method方法名为method1，则发现所有的method名称都会修改为method1，只有字符串里面的method不会修改，因为这是已经写死的，所以为了解决该问题可以使用nameof</p>
<p>改为如下console.writeLine($”{nameof(method)}”+”输入”);&#x2F;&#x2F;这样在重命名的时候就会一并修改为method1;</p>
<p><strong>Using语句</strong>：用来释放非托管资源（托管资源就是内存中的资源，比如创建的对象，变量，非托管资源就是文件流，数据库的连接，系统的窗口句柄，打印机资源等外面资源），如果不及时进行释放，其他代线程在使用该资源的时候就会报错。所以说using就是代替以及try，catch（），finally{&#x2F;&#x2F;dispose}的一种简单写法。一般用于处理各种流，使用using释放资源的对象必须实现IDisposable接口,例如TextWriter,TextReader等</p>
<p>例如using(Test t &#x3D; new Test()){}&#x2F;&#x2F;Test类必须实现Idisposable接口，否则报错，因为实现该接口后，在结尾处会自动调用dispose方法释放资源。</p>
<p>Using(filestream fs &#x3D; new filestream(“地址”)){}</p>
<p>等价于下面的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> static void WriteFileWithoutUsing()</span><br><span class="line">        &#123;</span><br><span class="line">            // 创建要写入临时文件的字节</span><br><span class="line">            Byte[] bytesToWrite = new byte[] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">            // 创建临时文件</span><br><span class="line">            FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                // 将字节写入临时文件</span><br><span class="line">                fs.Write(bytesToWrite, 0, bytesToWrite.Length);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                // 写入字节后显示关闭文件，这是必须要执行的</span><br><span class="line">                if (fs != null) fs.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">替换后</span><br><span class="line"> static void WriteFileWithoutUsing()</span><br><span class="line">        &#123;</span><br><span class="line">            // 创建要写入临时文件的字节</span><br><span class="line">            Byte[] bytesToWrite = new byte[] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">            // 创建临时文件</span><br><span class="line">            using (FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create))</span><br><span class="line">            &#123;</span><br><span class="line">                // 将字节写入临时文件</span><br><span class="line">                fs.Write(bytesToWrite, 0, bytesToWrite.Length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在c#8之后，可以简化using的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">int function()&#123;</span><br><span class="line">using(var conn = new sqlSconnection(connStr))&#123;</span><br><span class="line">conn.Open();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">简化后为</span><br><span class="line">using var conn = new sqlSconnection(connStr);这样就不是在指定的作用域内进行释放了，而是在当前using所在的整个方法即function方法快要结束的时候执行dispose方法</span><br><span class="line">conn.Open();</span><br><span class="line">这样可能会出现问题，当前面已经使用using访问某个非托管资源了，在该方法内有另一个对象也要想要访问该资源，但此时该资源被占用还没有释放，解决方法：1.使用传统的using&#123;&#125;的方式，2.使用局部代码块，将using括起来例如</span><br><span class="line">方法1</span><br><span class="line">using&#123;</span><br><span class="line">	var outStream = File.OpenWrite(&quot;e:/1.text&quot;);</span><br><span class="line">&#125;</span><br><span class="line">string s = File.ReadAllText(&quot;e:/1.txt&quot;);</span><br><span class="line">方法2</span><br><span class="line">&#123;</span><br><span class="line">	using var outStream =File.OpenWrite(&quot;e:/1.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">	string s = File.ReadAllText(&quot;e:/1.txt&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>record关键字：</strong>解决问题，对象之间使用&#x3D;&#x3D;判断是否是同一对象，如果属性都相同但是两个不同对象，结果也是false，传统方式是重写equals方法，record就是解决重写equals的问题，使用record代替class关键字，再次使用&#x3D;&#x3D;的时候就会根据对象里面的属性值进行比较代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public record Person </span><br><span class="line">&#123;</span><br><span class="line">    string firstName;</span><br><span class="line">    string lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(&quot;znk&quot;, &quot;zmk&quot;);</span><br><span class="line">Person p2 = new Person(&quot;znk&quot;, &quot;zmk&quot;);</span><br><span class="line">Person p3 = new Person(&quot;ndk&quot;, &quot;nmk&quot;);</span><br><span class="line">Console.WriteLine(p1==p2);//true</span><br><span class="line">Console.WriteLine(p2==p3);//false</span><br><span class="line">Console.WriteLine(p1==p3);//false</span><br><span class="line">注意使用record在创建对象的时候必须给所有属性赋值，在进行对象比较的时候，会将两个对象的属性值一一进行对比,并且他们的属性是只读的，不能更改，解决方法实现部分可读部分可写</span><br><span class="line">public record Person(string LastName)//注意这是一个类，看上去像一个方法，LastName是只读的属性</span><br><span class="line">&#123;</span><br><span class="line">	public string FirstName&#123;get;set;&#125;//FistName是可读可写属性</span><br><span class="line">	public void SayHello()</span><br><span class="line">	&#123;</span><br><span class="line">	cw</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组中的常用属性和方法：</strong></p>
<p>数组和集合和字典（键值对）：</p>
<p>数组元素数量不可变，集合可变（这是确定使用哪个进行存储的原因）</p>
<p>若让数组中的元素变成集合，则有两种方法1.使用数组中的toList();方法（例如arr.toList()）  2.使用Array的静态copy（）方法</p>
<p>属性，rank：表示维度				length：数组长度      </p>
<p>方法：getlength（）：返回长度</p>
<p>​	 Clear（）；将数组元素赋值为0或者null</p>
<p>​	 Array.Sort（）；对一位数组从大到小排序</p>
<p>​	 BinarySearch（）；进行二分法查找</p>
<p>​	 Clone（）；赋值</p>
<p>​	 Indexof（）；返回一维数组第一个值</p>
<p>​	 Reverse（）；翻转数组中的元素</p>
<p><strong>is关键字：</strong>if(bill is Person)&#x2F;&#x2F;来判断bill类型能否转换成Person类型。但是一般使用as代替is更加方便。</p>
<p>新用法：不仅可以判断而且如果为true的话可以进行赋值</p>
<p>例如if(Employ is Person person)&#x2F;&#x2F;判断Employ类是否属于Person，如果是，则将其转换为Person类并赋给person变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void testIs()</span><br><span class="line">           &#123;</span><br><span class="line">               string str=&quot;c#1200例&quot;;</span><br><span class="line">               Object obj = str;</span><br><span class="line">               if (obj is string)</span><br><span class="line">               &#123;</span><br><span class="line">                   string s = (string)obj;</span><br><span class="line">                   Console.WriteLine(&quot;可以转换&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   Console.WriteLine(&quot;不可以转换&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p><strong>as关键字：</strong>as也是强制转换，只不过as转换不了的话返回null，而不是报异常。</p>
<p>P &#x3D;Bill as Person</p>
<p>If(p&#x3D;&#x3D;null){&#x2F;&#x2F;逻辑代码}</p>
<p><strong>Where关键字：</strong>约束，用来约束自定义泛型中T的类型可以属于类或者其子类。一般只要出现泛型我们都需要对它进行约束</p>
<p>例如class MyClass&lt;T1,T2,T3&gt; where T2:Customer where T3:IComparable</p>
<p>约束总共有可以约束7种情况：</p>
<ol>
<li><p>约束是值类型：public void method<T>(T t) where T:struct</T></p>
</li>
<li><p>约束为引用类型public void method<T>(T t) where T:class</T></p>
</li>
<li><p>指定泛型具有无参的构造方法public void method<T>(T t) where T:new()</T></p>
</li>
<li><p>指定泛型类为某个类或者其子类 public void method<T>(T t) where T:Person</T></p>
</li>
<li><p>接口同4</p>
</li>
<li><p>指定T提供的参数必须为U提供的参数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class sample&lt;U&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	Public void method&lt;T&gt;(T t) where T:U</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>可以有多个约束</p>
<p><strong>可空类型：</strong>例如string? name（string类型是引用类型，如果不加？的话，编译器会出现警告信息，如果其他地方使用该变量的时候发现没有赋值会报错空指针异常，加上?之后就会允许使用null类型，即允许别人调用该变量的时候是null，至于拿到null之后怎样操作是调用者的事，被调用变量只负责不报错） </p>
<p>int? myInt&#x3D;22;  应用场景：数据库中值类型可以为null，但是c#中值类型是不能为null，默认为0等，所以需要对应数据库，所以使用null来代替默认值0；又比如，前端没有选择某个条件会传递后端一个null，会造成前后端数据不一致，此时使用可空类型</p>
<p>因为模型绑定系统中，对于参数为int类型，如果url中没有传入数值，则会将int类型默认赋值为0，但是需要需要区分未赋值但系统默认为0和手动传入参数为0的两种情况，此时需要使用可空类型代替默认值0</p>
<p>public IActionResult Index(int? id){</p>
<p>​	string name;&#x2F;&#x2F;等价于string name &#x3D; null;</p>
<p>​	int age;&#x2F;&#x2F;等价于int age &#x3D; 0；</p>
<p>}</p>
<p>可空类型和非可空类型之间转换</p>
<p>Int? temp &#x3D; 22;&#x2F;&#x2F;实际上这就是非可空类型转换为可空类型</p>
<p>Int temp1 &#x3D; (int)temp;&#x2F;&#x2F;这就是可空类型转换为非可空类型</p>
<p><strong>空接合运算符：</strong>?? 例如name&#x3D;temp ?? -1;表示如果temp变量是null就返回-1，如果不是null就返回temp的值。</p>
<p><strong>null条件运算符：</strong>?.   在使用.的方式调用之前检查为null，则报异常，若不为null，则调用属性，例如string name&#x3D;P?.Name;若P为null则name为null，若P不为null，则name&#x3D;Name。同理decimal? price&#x3D; P?.price; 因为deciamal本身不带null。string name &#x3D; P?.Related?.Name表示若P为null或者P.Relate为null则name为空否则name&#x3D;P.Related.Name</p>
<p>null条件运算符保证不会抛出nullreferenceexception异常，而空接合运算符保证浏览器结果中不显示空值</p>
</li>
</ol>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>namespace ：use system实际上就是使用了名称空间。就是将类放在名称空间里面，例如Console.WriteLine这个方法，使用的console这个类就是system这个名称空间里面的类，如果没有use system这个调用，需要使用system.console.writeline这个方法使用，这是比较麻烦的，所以程序开头就直接引用system这个名称空间。如何寻找命名空间：把一个类名写出来后，点击这个类，左下角会自动出现所属命名空间，引用即可。</p>
<p>属性 property 方法：method ，事件event</p>
<p>命名：类或者接口:大驼峰</p>
<p>​			变量和方法：小驼峰</p>
<p>​			常量：全部大写</p>
<h3 id="属性，字段"><a href="#属性，字段" class="headerlink" title="属性，字段"></a>属性，字段</h3><p>Get,set：在c#中，使用set和get方法对字段进行设置和获取，但是不像java那么麻烦，在这两个方法中，都是通过value这个变量来作为形参，value就是外界传入的数值，它的类型与对象的字段类型是相同的。设置set和get的目的是是对字段进行private，防止暴露在外面，同时为了筛选字段条件。<font color="red">字段一般使用private修饰，作为类内部的变量使用，而属性一般使用public修饰，外界访问类对象的属性时使用，推荐使用属性，不使用字段</font>&gt;</p>
<p>在java中的使用方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    private string name;</span><br><span class="line"></span><br><span class="line">​    public void setName(string name)//通过创建对象是传入name</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      this.name = name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public string  getName() &#123;</span><br><span class="line"></span><br><span class="line">​      return name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main方法中使用对象.setName()；去设置字段，使用对象.getName()；去获取字段，可以看到java中每个字段都要get和set，而c#是使用属性将get和set封装起来了</p>
<p>而在c#中如下class Person</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	private string name</span><br><span class="line"></span><br><span class="line">​    public string Name//这个属性就是相当于一个方法    </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​      set &#123;</span><br><span class="line"></span><br><span class="line">​        name = value;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      get &#123;</span><br><span class="line"></span><br><span class="line">​        return name;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main方法中使用对象.Name&#x3D;”张三”的方式去设置字段（自动调用set方法,通过操作属性进而为字段赋值），使用arr&#x3D;对象.Name的方式去获取字段的值（自动调用get方法，通过操作属性获取字段的值）</p>
<p>注意：在c#中字段和属性相似但是不一样的，字段是不用get和set的，而属性需要get和set的，属性其使用set方法对字段赋值，使用get方法获取。对上面的name字段提供访问方法，在java中的访问是直接通过两个函数来访问，而c#中使用属性对set和get方法进行了封装，属性名（函数名）叫做Name，一般字段用小写，而属性名是对应字段名字的大写。所以我们为属性赋值的时候，会自动调用set方法进而对字段进行赋值，获取属性的时候，会自动调用get方法，获取字段中的值。get相当于一个无参的构造方法。set相当于一个具有单个属性值参数的方法。之后为了简便就不必写字段了，而是直接将属性看为字段，即上面的代码变为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">​	Public string Name</span><br><span class="line">&#123;</span><br><span class="line">​	Set;</span><br><span class="line">​	Get;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再简化之后就是public string Name{set;get;}</p>
<p>因为属性可以直接当做字段了，所以可以为属性初始化public string Name{set;get;}&#x3D;”张三”;</p>
<p>它的底层代码就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Private string name;</span><br><span class="line"></span><br><span class="line">Public string Name</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	Set&#123;name = value&#125;//其中value=”张三”</span><br><span class="line"></span><br><span class="line">​	Get&#123;return name &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是将某个字段设置为只读属性，那么只需要删掉set即可例public string Name{get;}</p>
<h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><p>如果类中定义了构造器，那么系统就不会提供默认无参构造器，否则系统提供默认无参构造器。构造器的作用：该类在被创建对象时，就会自动执行构造器的内容，不需要再后续代码中再重新指定，相当于所有来自于该类的对象的共有属性。</p>
<p>构造方法：为对象的属性进行赋值，这样在创建对象时，直接在创建对象的形参中传入参数即可，不必每次都使用set方法，例如new Student(‘张三’,23);，为了使构造方法多样性，可以重载构造方法。若自己写出有参构造方法，那么系统不会提供无参构造，无参构造需要自己写才能调用。构造方法用来初始化属性和set，get方法作用差不多，可以后续对属性进行修改，推荐使用get，set方法，因为更加灵活。</p>
<p>子类继承父类情况下，在子类执行自己的构造方法之前会先自动调用一下父类的构造方法。如果子类想要自动调用父类的某个指定的有参构造，那么就使用</p>
<p>Public Student(int x,string s):base(x,s){};即可，如果没有手动调用，那么子类会自动调用父类的无参构造，即</p>
<p>Class Student:Person{</p>
<p>public Student():base(){};&#x2F;&#x2F;这种方式等价于public Student(){};</p>
<p>}</p>
<p>还有一种情况，本类构造函数想要使用本类的其他构造函数就使用public student(int x):this(x,”hello”){}；使用这种情况的好处是一个类有好几个构造函数，且他们都需要在开始阶段执行重复的代码，那么我们就将公共代码提出来放到新的构造函数中执行，这样其他的构造函数提前使用它即可</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//判断Form类属于什么类型</span><br><span class="line">           Type myForm = typeof(Form);</span><br><span class="line">           Console.WriteLine(myForm);</span><br><span class="line">           //Console.WriteLine(Form);这是错误的，java可以直接这样输出一个类的信息，但是c#不可以</span><br></pre></td></tr></table></figure>



<pre><code>var的变量类型， static void Main(string[] args)
    &#123;
        Console.WriteLine();
        var a = 3;
        var b = 3L;
        var c = &quot;hello world&quot;;

        Console.Write(a.GetType().Name);
        Console.Write(a.GetType().Name);
        Console.WriteLine(c.GetType().Name);

    &#125;结果为  Int32
    		Int32
    		String，说明var类型是个自动识别变量类型的变量。
</code></pre>
<p>数据类型和表示范围：int ：占4个字节，long :占8个字节，byte，一个字节，short：两个字节，float :4个字节，double:8个字节，char：2个字节，bool，1&#x2F;8个字节，<font color="red">整数默认是int，小数默认是double</font>&gt;，所以long x&#x3D;8888888888L错误，float x &#x3D; 12.3错误，应为float x &#x3D; 12.3f。</p>
<p><img src="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png" alt="image-20210202203407102"></p>
<p>c#五大数据类型： 1.类类型class</p>
<p>​							    2.接口interface</p>
<p>​								3.结构体类型struct</p>
<p>​								4.枚举类型（enum）：即给类的某个属性设置为某几个固定值，可以任意选择。（一对多）</p>
<p>​								5.委托类型deledates</p>
<h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>在字符串中使用变量,在vs2015(c#6.0)之后使用大括号将变量括起来，同时字符串前面加上$符号，这比传统使用单引号和双引号的方式好用的多。</p>
<p>int var1 &#x3D; 30;</p>
<p>int var2 &#x3D; 60;</p>
<p>Console.WriteLine($”我的年龄是{var1},老师的年龄是{var2}”);</p>
<p>字符串的常用属性或者方法：</p>
<p>\1. length：属性</p>
<p>\2. concat：静态方法，连接字符串</p>
<p>\3. contaions();方法，判断参数字符串是否是对象字符串的子字符串</p>
<p>\4. format（）；静态方法，格式化字符串</p>
<p>\5. insert(parameter 1,parameter2):插入新字符串，第一个参数为插入的位置，第二个参数为插入的字符串。</p>
<p>\6. remove();移除子字符串，从指定位置以后全部移除</p>
<p>\7. replace();将字符串中旧的子字符串替换为新的子字符串</p>
<p>\8. split();将字符串拆分为多个子字符串数组。参数为指定的拆分字符</p>
<p>\9. substring()；截取字符串</p>
<p>\10. toLower();全部转为小写</p>
<p>\11. toUpper();全部转为大写</p>
<p>\12. 将字符串解析为数字值例如double.tryParse(“12.85”,out FirstString);会生成double类型的12.85不要使用parse，因为一旦出错会报异常，而tryparse成功会将数值传递给firststring并返回true，失败会返回false。tryparse只用于将字符串类型转换为数字类型。</p>
<p>案例如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">	   string str = &quot;你深邃的眼眸abCliKlLLOO想要透漏什么密码&quot;;</span><br><span class="line">	   string str0 = &quot;lkjkjsd&quot;;</span><br><span class="line">​      Console.WriteLine(str.Length);</span><br><span class="line"></span><br><span class="line">​      var str1 = str.ToUpper();</span><br><span class="line"></span><br><span class="line">​      var str2 = str.ToLower();</span><br><span class="line"></span><br><span class="line">​      var str3 = str.Substring(2,5);</span><br><span class="line"></span><br><span class="line">​      var str4 = String.Concat(str0,str1);</span><br><span class="line"></span><br><span class="line">​      var str5 = str.Insert(3,&quot;王老吉&quot;);</span><br><span class="line"></span><br><span class="line">​      var str6 = str.Remove(8);</span><br><span class="line"></span><br><span class="line">​      var str7 = str.Replace(&quot;想要透漏&quot;,&quot;不想要&quot;);</span><br><span class="line"></span><br><span class="line">​      //var str8 = str.Reverse();</span><br><span class="line"></span><br><span class="line">​      char[] ch = &#123; &#x27;邃&#x27;,&#x27;眸&#x27;,&#x27;i&#x27;,&#x27;L&#x27;,&#x27;什&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">​      string[] str9 = str.Split(ch);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str1+str2);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str3);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str4);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str.Contains(str0));</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str5);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str6);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str7);</span><br><span class="line"></span><br><span class="line">​      foreach (var s in str9)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>float，double，decimal，其中decimal一般用于货币的计算，更加精确可以表示分数,精度比double高，浮点型转decimal可能会出现溢出错误，所以通常会使用checked{}代码块检查。</p>
<h3 id="Dynamic关键字："><a href="#Dynamic关键字：" class="headerlink" title="Dynamic关键字："></a>Dynamic关键字：</h3><p>与var差不多，只不过var是在编译时确定类型的，而dynamic是在运行时确定数据类型的。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：  静态方法不能被继承，</p>
<p>子类只能继承父类的非私有化成员，</p>
<p>子类不能继承父类的构造方法，若调用，需使用base关键字</p>
<p>若父类和子类中有相同的成员变量，根据就近原则优先使用子类的，子类没有的话会去调用父类。方法同样优先调用子类方法   </p>
<p>继承：子类 is 父类，is关键字就是判断符</p>
<p>父类的构造器不可以被子类继承，因为每个类的构造器名必须与它自己的类名相同，所以当父类使用有参构造的时候，子类中的空参构造默认调用（是调用不是继承）父类的空参构造(即类似java中子类构造器中默认会有super())，而父类不提供空参构造，所以导致报错，解决方法:在子类中创建有参构造调用父类的有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Son s = new Son(5000);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(s.money);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  class Father</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int money;</span><br><span class="line"></span><br><span class="line">​    public Father(int money)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      this.money = money;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Son :Father&#123;</span><br><span class="line"></span><br><span class="line">​    public Son(int money):base(money)//手动让子类的有参构造调用父类的有参构造</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>java中默认自带vurtual关键字，c#默认不自带，使用virtual修饰方法后表示这些成员将会在继承后重写里面的内容，如果不用virtual修饰，表示它是不能被重写的，virtual修饰属性表示可重写里面的get，set方法</p>
<p>重写：子类继承了父类中的方法，同时将父类中的方法进行了改造，优先使用子类的方法，重写的返回值是相同的或者是子父类之间的关系，参数列表必须一样</p>
<p>注意c#中的重写与java中的重写不一样，c#中父类被重写的方法需加上virtual关键字，子类中被重写的方法需加上override关键字，如果不加上这两个关键字，那么意味着父类和子类各有自己的introduce方法，如果此时使用多态进行父类引用子类对象时，就不会出现编译看父类运行看子类，多态也就没有意义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public virtual void introduce() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是父亲类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public override void introduce() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是儿子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Public override void introduce()&#123;</span><br><span class="line"></span><br><span class="line">​		Console.writeLine(“我是孙子类”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：（好处提高代码的复用性）为什么会有多态及为什么会有父类引用指向子类对象。</p>
<p>答：就是为了少写代码。例如main方法中需要一个Dog对象，一个Cat对象，可以直接创建即可，但是如果有10个类似的类，那么需要10个形参来接收，那么就太麻烦了，所以出现了接口，只要将一个接口作为形参，来接收对应的对象就可以，创建的时候就会自动指定对象的类型，可以简化代码。</p>
<p>当使用父类引用指向子类对象的情况时，在java中自动的，但是在c#中是需要手动设置的，当父类和子类有相同的方法，且创建对象使用的父类引用指向子类对象的方式，</p>
<p>前提1，具有继承关系2，有方法重写3.有父类引用指向子类对象</p>
<p>​				对于成员变量，编译看父类，运行看父类</p>
<p>​				对于成员方法，编译看父类，运行看子类</p>
<p>​				对于静态方法，编译看父类，运行看父类</p>
<p>以上是父类和子类共有相同的方法，若子类中的方法父类没有，那么就需要进行向下转型或者向上转型：</p>
<p>向上转型，父类引用指向子类对象，</p>
<p>向下转型，使用括号进行父类转化为子类，注意，必须先完成向上转型才能接着完成向下转型。即Father father &#x3D; new Son();   Son son &#x3D; (Son)father。</p>
<p>举例如下</p>
<ol>
<li><p>如果想要调用的是父类中的方法，那么就在子类的对应的方法的前面用new修饰，表示隐藏</p>
</li>
<li><p>如果想要使用的子类中的方法，那么就需要在父类的方法上用virtual修饰，子类方法用override修饰。同样，在属性，事件，索引器上也可以使用virtual的修饰方法，子类重写(抽象类的重写不必再父类上加virtual，但子类必须加override)</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Person p = new Student &#123; &#125;;</span><br><span class="line"></span><br><span class="line">​      p.method();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    public void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;父类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Student : Person</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">​    new public  void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第二种情况：</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Person p = new Student &#123; &#125;;</span><br><span class="line"></span><br><span class="line">​      p.method();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    Virtual public void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;父类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Student : Person</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">​    override public  void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="强转"><a href="#强转" class="headerlink" title="强转"></a>强转</h3><p>类型强转：如果都是数字型：int，float，double之间进行强转，可以直接使用(int)double进行强转，如果是不同类型之间进行强转，比如string和int之间需要使用int.parse(string)进行强转.</p>
<h3 id="判断字符串不能为空的方法："><a href="#判断字符串不能为空的方法：" class="headerlink" title="判断字符串不能为空的方法："></a>判断字符串不能为空的方法：</h3><p>​	方法一：使用string.isnullorempty()方法</p>
<p>​	方法二：使用textbox.text !&#x3D; “”;</p>
<p>​	注意：不能够使用textbox.text&#x3D; null;去判断</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类abstract</p>
<p>中的抽象方法强制子类必须去重写该抽象方法。抽象类的作用：1.给其他类作父类2.作为多态实现父类引用子类对象。</p>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>interface，接口仍然使用:去实现，java中是implements是实现。若子类不想要完全去实现所有的接口中的功能，例如Run方法，就使用abstract public void Run();不去重写该方法，继续作为抽象方法即可</p>
<p>所有方法都为抽象方法的类作为接口</p>
<p>接口优点：可以实现多继承</p>
<p>接口中成员变量默认修饰符pubic static final     </p>
<p>接口中所有方法不需要都去实现的话，可以自己手写一个子接口，实现总接口中的部分方法，然后让子类去实现这个子接口。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>是定义在类里面，方法的外面，然后在方法里面使用	例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum level&#123;</span><br><span class="line"></span><br><span class="line">​        low,</span><br><span class="line"></span><br><span class="line">​        mid,</span><br><span class="line"></span><br><span class="line">​        high,</span><br><span class="line"></span><br><span class="line">​        super</span><br><span class="line"></span><br><span class="line">​      &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="权限："><a href="#权限：" class="headerlink" title="权限："></a>权限：</h3><p>C#是五种访问权限</p>
<p>1.public（所有的类以及对程序集外部的也可见）  2.private（不带修饰符默认就是private）   3.protected（允许子类访问）  4.internal(内部的,只能被同一程序集内部访问，程序集就是一个源文件，可能包含多个类)  5.protected internal（受保护的内部的）</p>
<p>公开性比较大小public &gt; protect internal&gt;protect &#x3D; internal&gt;private</p>
<p><img src="file:///C:\Users\Administrator\AppData\Local\Temp\ksohtml7308\wps1.jpg" alt="img"> </p>
<h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><p>的使用方法：is用来判断该对象是否是某个类的对象，或者是某个类的子类的对象，返回的是一个bool型，而as原理与is相似，返回的是个对象或者null。as与强制类型转换的区别：强制类型转换，会将原有类型按照指定类型强制转移，若无法转换则报错。而as若无法转换则返回一个null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            teacher t = new teacher();</span><br><span class="line">            bool flag = t is teacher;//判断是否是t是否是teacher的对象，true</span><br><span class="line">            Console.WriteLine(flag);</span><br><span class="line">            bool flag2 = t is Person;判断是否是person的对象，因为teacher是person的子类，所以结果为true</span><br><span class="line">        	Console.WriteLine(flag2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    public void think() &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class teacher : Person &#123;</span><br><span class="line">    public void study() &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与java相似，c#创建对象的时候也有两种方式，第二种方式创建的对象只能使用一次，第一种方式创建的对象可以无限使用，其中中括号里面的内容表示对Form这个类中的属性进行更改。代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Form fm = new Form();</span><br><span class="line"></span><br><span class="line">​      fm.Text = &quot;这是我的第一个程序&quot;;</span><br><span class="line"></span><br><span class="line">​      fm.ShowDialog();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      new Form() &#123; Text = &quot;这是我的第二个程序&quot;&#125;.ShowDialog();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名对象："><a href="#匿名对象：" class="headerlink" title="匿名对象："></a>匿名对象：</h3><p>创建对象的另一种方式（java没有），该类没有名称，所以使用var作为接受类型，然后在{}中写入属性内容。（注意{}中不能添加方法只能添加属性）</p>
<p>var person &#x3D; new { name &#x3D; “张三”, age &#x3D; 64 };</p>
<p>​      Console.WriteLine(person.name);</p>
<p>​      Console.WriteLine(person.age);</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>1)将string类型转换为int类型,使用Convert类中的toInt32()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">string str1 = “10”;</span><br><span class="line"></span><br><span class="line">​      string str2 = “20”;</span><br><span class="line"></span><br><span class="line">​      int it1 = Convert.ToInt32(str1);</span><br><span class="line"></span><br><span class="line">​      int it2 = Convert.ToInt32(str2);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(it1+it2);</span><br><span class="line"></span><br><span class="line">​	2)显视类型转换，例如将Stone这个类转换为Monkey类，（这个在java中是没有办法实现的。）代码如下</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123; </span><br><span class="line"></span><br><span class="line">​      Stone stone1 = new Stone();</span><br><span class="line"></span><br><span class="line">​      stone1.age = 5000;</span><br><span class="line"></span><br><span class="line">​      Monkey wukong = (Monkey)stone1;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(wukong.age);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Stone &#123;</span><br><span class="line"></span><br><span class="line">​    public int age;</span><br><span class="line"></span><br><span class="line">​		//注意是在被转换的代码下面写如下代码</span><br><span class="line"></span><br><span class="line">​    public static explicit operator Monkey(Stone st)&#123;</span><br><span class="line"></span><br><span class="line">​      Monkey m = new Monkey();</span><br><span class="line"></span><br><span class="line">​      m.age = stone.age/500;//石头五百年相当于猴子一年</span><br><span class="line"></span><br><span class="line">​      return m;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Monkey &#123;</span><br><span class="line"></span><br><span class="line">​    public int age;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用get-set-方法的意义："><a href="#使用get-set-方法的意义：" class="headerlink" title="使用get(),set()方法的意义："></a>使用get(),set()方法的意义：</h3><p>为了让用户在创建对象并且为属性赋值的时候进行合法赋值（例如年龄0&lt;age&lt;100），通常将属性值设置为private权限（不让用户在没有筛选的条件下使用属性）,然后提供 set，get方法进行赋值和取值，在set，get方法中进行合理值的过滤和筛选。代码如下（注意，这是java中的代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st1 = new Student();</span><br><span class="line"></span><br><span class="line">​      st1.setAge(50);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st1.getName()+st1.getAge());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Student st2 = new Student();</span><br><span class="line"></span><br><span class="line">​      st2.setAge(100);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st2.getName()+st2.getAge());</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    private int age;</span><br><span class="line"></span><br><span class="line">​    private string name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    public void setAge(int age) &#123;</span><br><span class="line"></span><br><span class="line">​      if (0 &lt; age &amp;&amp; age &lt; 100)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        this.age = age;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(&quot;请输入年龄在0-100之间&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int getAge() &#123;</span><br><span class="line"></span><br><span class="line">​      return this.age;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    public void setName(string name) &#123;</span><br><span class="line"></span><br><span class="line">​      this.name = name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public string getName() &#123;</span><br><span class="line"></span><br><span class="line">​      return this.name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到java中的代码在访问属性时比较麻烦，为了想要用st1.age这种与public访问属性方式，c#创造了另一种写法，但是逻辑思想与java是一样的，代码如下</p>
<p>（简便书写方法，快捷键，输入propfull按两下tab键，输入对应的参数即可）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st = new Student();</span><br><span class="line"></span><br><span class="line">​      st.Age = 20;					//在这里可以直接使用这种方式访问（注意使用Age而不是age，相当于为age又起了一个变量名Age），下面的set代码块中限制了了用户年龄范围。</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st.Age);	</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    private int age;					//这个必须写，而且是private</span><br><span class="line"></span><br><span class="line">​    	public int Age &#123;					//这里与java不同，c#可以在创建属性的同时直接使用与get，set方法类似的代码块进行年龄范围设置，同时这里是public，相当于为age起了另一个变量名Age</span><br><span class="line"></span><br><span class="line">​      set &#123;</span><br><span class="line"></span><br><span class="line">​        if (value &gt; 0 &amp;&amp; value &lt; 100) 		&lt;font color = &#x27;red&#x27;&gt;//注意value此时写在get，set代码块中，value此时是个关键字（只在get，set方法中value是个关键词，在其他代码块中value不是 关键字，可以随便使用），因为此代码块中get和set不是方法所以无法传参，所以微软规定value就是这个形参，在上面st.Age = 20时，实际上value的值就等于20，若value写在string类型的代码块中，value就是个string类型的。&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          this.age = value;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          Console.WriteLine(&quot;年龄区间输入错误&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      get &#123;</span><br><span class="line"></span><br><span class="line">​        return this.age;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">还有一种写法</span><br><span class="line"></span><br><span class="line">Public int Age&#123;get;set;&#125;//这种写法是定义了一种变量Age，但是get和set中没有对Age进行限制，与public int age;</span><br></pre></td></tr></table></figure>

<h3 id="ref关键字："><a href="#ref关键字：" class="headerlink" title="ref关键字："></a>ref关键字：</h3><p>类似于指针，如下method方法中形参为ref类型，实参y传入后，x与y指向同一个内存地址，所以x直接操作的是y对应的地址，所以最终输出结果为101，而不是100,使用ref的特点是传递过来的实参应该是变量而不是数值，所以形参只是拿来用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      int y = 100;</span><br><span class="line"></span><br><span class="line">​      method(ref y);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(y);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    static void method(ref int x ) &#123;</span><br><span class="line"></span><br><span class="line">​      x = x + 1;  </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Ref关键字：当传参时，若是传递的为引用参数，那么就得使用ref进行修饰。使用时必须在方法的声明和调用中都使用ref。使用该关键字的原因是在方法中对使用该关键字的引用类型对象修改时，方法执行完后修改后的对象在其他方法中仍然使用的是修改后的对象。</p>
<p>例如ref int value，ref Student stu;普通类型和引用类型都可以使用ref</p>
<p>但是如果是引用类型进行传递的话，加ref和不加ref还是有区别的，如果不加ref，传递引用类型，那么如果在方法中对引用类型的形参赋予新的对象时，就会切断形参与实参之间的联系。当加上ref后，再对形参赋予新的对象时，不会切断两者之间的联系，而且对象是实参的值。案例如下两种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">class MyClass </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value = 20;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass mc = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之前的值为：&quot;+ mc.value);</span><br><span class="line"></span><br><span class="line">​      parameter(mc);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之后的值为：&quot;+mc.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public static void parameter(MyClass m1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      m1.value = 50;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1的值为：&quot; + m1.value);</span><br><span class="line"></span><br><span class="line">​      m1 = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(m1.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">结果为20,50,20，50</span><br><span class="line"></span><br><span class="line">第二种方式：</span><br><span class="line"></span><br><span class="line">class MyClass </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value = 20;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass mc = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之前的值为：&quot;+ mc.value);</span><br><span class="line"></span><br><span class="line">​      parameter(ref mc);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之后的值为：&quot;+mc.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public static void parameter(ref MyClass m1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      m1.value = 50;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1的值为：&quot; + m1.value);</span><br><span class="line"></span><br><span class="line">​      m1 = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(m1.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">结果为20,50,20,20</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="out关键字"><a href="#out关键字" class="headerlink" title="out关键字"></a>out关键字</h3><p>Out：他与ref类似，只不过是ref是在调用函数时将实参传入形参中，而out是将方法中的形参传出来放到实参中。他的作用就是使局部变量可以在方法块外面使用。double.tryParse(“12.85”,out FirstString);字符串转换double类型成功就将其放倒firststring变量中，否则返回false；并且转换完成之后自动放到FirstString里面的，不需要手动进行赋值。</p>
<h3 id="parames关键字"><a href="#parames关键字" class="headerlink" title="parames关键字"></a>parames关键字</h3><p>参数数组，若传递的是一个数组，那么使用params修饰，例如void test(params int[] values),但是在调用的时候不需要使用parames修饰</p>
<h3 id="具名参数："><a href="#具名参数：" class="headerlink" title="具名参数："></a>具名参数：</h3><p>实际上就是传参的另一种使用方法，（c#独有，意义不大）在调用method方法时，实参使用name:”张三”，age:23这种方式的好处一是可读性比较强，二是传参时可以不必按照method的形参的类型顺序进行赋值，即method(age:23,name:”张三”)这种传参方式也可以。</p>
<pre><code>static void Main(string[] args)
&#123;

  method2(name: &quot;张三&quot;,age:23);

&#125;    

&#125;

static void method2(String name, int age) &#123;

  Console.WriteLine(name+age);

&#125;
</code></pre>
<h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>数组的增删插入比较麻烦，查询,修改方便。集合查询修改比较麻烦，增删容易。如果数据的个数是固定的推荐使用数组，反之使用集合</p>
<p>当需要存储数据的时候,如果使用集合,在一个for循环查询数组中使用list.add()即可顺便保存到全局变量中，如果使用全部数组变量需要单独再创建一个for循环，将原数组中的每个数据保存到全局数组变量中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">方法：ArrayList list = new ArrayList();</span><br><span class="line"></span><br><span class="line">//	将数据添加到链表的结尾处</span><br><span class="line"></span><br><span class="line">​	list.add(“abc”);</span><br><span class="line"></span><br><span class="line">​	list.add(123);</span><br><span class="line"></span><br><span class="line">//	删除某一个位置的数据</span><br><span class="line"></span><br><span class="line">list.removeAt(0);</span><br><span class="line"></span><br><span class="line">​	//	指定删除某一个数据</span><br><span class="line"></span><br><span class="line">​		List.remove(“123”);</span><br><span class="line"></span><br><span class="line">​	//	插入一个数据</span><br><span class="line"></span><br><span class="line">​		List.insert(0,”helloword”);</span><br><span class="line"></span><br><span class="line">​	//查询数据：</span><br><span class="line"></span><br><span class="line">​	foreach(int i in list)&#123;</span><br><span class="line"></span><br><span class="line">​	//查询即可</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary();</span><br><span class="line"></span><br><span class="line">通过键值对完成增删改查</span><br><span class="line"></span><br><span class="line">\1. 增：</span><br><span class="line"></span><br><span class="line">a) 方式一：dic.add(1,”a”);</span><br><span class="line"></span><br><span class="line">b) 方式二:dic[1] = “a”;</span><br><span class="line"></span><br><span class="line">c) 方式三：Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary()&#123;</span><br><span class="line"></span><br><span class="line">&#123;1,”a”&#125;,</span><br><span class="line"></span><br><span class="line">&#123;2,”b”&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">\2. 查：</span><br><span class="line"></span><br><span class="line">\1. 方式一：string str = dic[1];通过键获取值</span><br><span class="line"></span><br><span class="line">\2. foreach(keyValuePair&lt;int&gt;&lt;string&gt; item in dic)&#123;//首先获取一个键值对数据</span><br><span class="line"></span><br><span class="line">int key = item.key;//获取键</span><br><span class="line"></span><br><span class="line">string value = item.value;//获取值                                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.删：bool a = dic.remove();</span><br></pre></td></tr></table></figure>



<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托：  表示具有特定参数列表和返回类型的引用，好处：将方法作为参数传递出去，将方法封装成一个对象进行传递，可以完成对该方法的使用，避免重写该方法。委托是一种类。它主要用于跨线程的时候调用控件使用，对于不能直接调用的方法，需要委托给别人，即别的线程来执行。例如一个方法在一个线程中定义，而需要调用这个函数时，在另外一个线程，这是就需要使用委托</p>
<p>delegate（可以无返回值，可以指定返回值类型）， action和delegate的参数列表被定义到了16个，足够用户使用。</p>
<p>Action(无返回值的泛型)，Action&lt;int,string&gt;表示传入int，string无返回值的委托</p>
<p>Func（有返回值的泛型委托），Func&lt;string,int&gt;表示传入参数为string，返回值为int的委托，Func&lt;string,string,int&gt;,参数为string，string，返回值类型为int</p>
<p>predicate（返回值是布尔类型的泛型委托）predicate<int>表示传入参数为int，返回bool的委托。</int></p>
<p>自定义委托：但是上面的四种委托已经足够了，自己通过代码体验就好，但是注意，自定义委托是一种类，需声明在其他类的外面，如果声明在其他类的里面，则属于嵌套类，则在使用时需要使用 当前所在类的类名.del1  cal1 &#x3D; new  del1(c1.add);进行调用。委托的使用类似于以下代码，<font color="red">委托可以接收各种传递过来的方法变量，然后调用，而不使用委托就只能固定调用某个方法。可以节约代码</font></p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">namespace test5</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  public delegate int del1(int x,int y);//自定义的委托，与下面的Action，Func具有同样的作用,自定义委托写在其他类的外面。其中被传递的函数的返回值为int，参数为两个int型于委托的返回值类型和参数列表必须一样。</span><br><span class="line"></span><br><span class="line">  class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Calculator cl = new Calculator();</span><br><span class="line"></span><br><span class="line">​      Action action = new Action(cl.Report);</span><br><span class="line"></span><br><span class="line">​      cl.Report();//传统方法调用report方法</span><br><span class="line"></span><br><span class="line">​      action.Invoke();//使用委托调用report方法</span><br><span class="line"></span><br><span class="line">​      action();//使用委托调用另一种写法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Func&lt;int,int,int&gt; func1 = new Func&lt;int,int,int&gt;(cl.Add);//两个参数类型，一个返回类型</span><br><span class="line"></span><br><span class="line">​      Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(cl.sub);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(func1(2,3));</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(func2(5,5));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      //使用自定义委托</span><br><span class="line"></span><br><span class="line">​      del1 cal1 = new del1(cl.Add);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(cal1(5, 6)); </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Calculator &#123;</span><br><span class="line"></span><br><span class="line">​    public void Report() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;I have three methods&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int Add(int a,int b) &#123;</span><br><span class="line"></span><br><span class="line">​      int result = a + b;</span><br><span class="line"></span><br><span class="line">​      return result;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int sub(int a, int b) &#123;</span><br><span class="line"></span><br><span class="line">​      int result = a - b;</span><br><span class="line"></span><br><span class="line">​      return result;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名委托：只执行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;string,int&gt; f= delegate (string n,int i)&#123;console.writelin(n+i)&#125;;即定义一个匿名方法，该方法赋给委托f，小括号内为方法参数，大括号为方法体</span><br><span class="line">f();//调用该方法</span><br><span class="line"></span><br><span class="line">Func&lt;int,int,string&gt; f2= delegate(int i,int j)&#123;console.write(i+j)&#125;//参数为int，int返回值为string的委托</span><br></pre></td></tr></table></figure>



<p>多播委托：一个委托内部封装着多个方法，顺序是按照添加的顺序执行，如果想要进行多线程争抢执行顺序，需使用BeginInvoke();  方法即action1.BeginInvoke();  action2.BeginInvoke(); action3.BeginInvoke();</p>
<p>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st = new Student();</span><br><span class="line"></span><br><span class="line">​      Teacher t = new Teacher();</span><br><span class="line"></span><br><span class="line">​      Worker w = new Worker();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Action action1 = new Action(st.doHomeWork);</span><br><span class="line"></span><br><span class="line">​      Action action2 = new Action(t.Teach);</span><br><span class="line"></span><br><span class="line">​      Action action3 = new Action(w.work);</span><br><span class="line"></span><br><span class="line">​      //多播委托</span><br><span class="line"></span><br><span class="line">​      action1 += action2;//将action2添加到action1中</span><br><span class="line"></span><br><span class="line">​      action1 += action3;//将action3添加到action1中</span><br><span class="line"></span><br><span class="line">​      action1.Invoke();//执行顺序，按照添加顺序开始执行ation1，action2，action3</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    public void doHomeWork() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是学生&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Teacher &#123;</span><br><span class="line"></span><br><span class="line">​    public void Teach() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是老师&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Worker &#123;</span><br><span class="line"></span><br><span class="line">​    public void work() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是工人&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义委托</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>（参考刘铁猛wpf的事件更加直观）事件的五个成员：1.事件的拥有者（例textbox对象）		2.事件成员（例如textbox中的click方法）		3.事件的响应者(类对象)			4.事件处理器(类对象中的方法)			5.事件订阅：事件 +&#x3D; 事件处理器（本质上是以委托为基础的约定）</p>
<p>写事件之前先把以上五个关于事件的东西写出来</p>
<p>事件拥有者和事件的响应者共有四种组合方式，推荐第四种</p>
<p>如下第一种组合方式和对应代码，</p>
<p><img src="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214254615.png" alt="image-20210219214254615"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Timer time = new Timer();//事件的拥有者，即小闪电符号的就是事件，小扳手是属性，小方块是方法</span><br><span class="line">​           time.Interval = 1000;</span><br><span class="line">            Boy boy = new Boy();//事件的响应者</span><br><span class="line">            Girl girl = new Girl();</span><br><span class="line">            time.Elapsed += boy.Action;//左边是事件，右侧是事件处理器（即Action方法），中间+=就是事件的订阅</span><br><span class="line">            time.Elapsed += girl.Acton;</span><br><span class="line">            time.Start();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Boy &#123;</span><br><span class="line">    internal void Action(object sender, ElapsedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;jump&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Girl &#123;</span><br><span class="line"></span><br><span class="line">    internal void Acton(object sender, ElapsedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;sing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二种组合方式，事件的拥有者和事件的响应者是两个不同的对象。代码重新看视频</p>
<p><img src="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214539229.png" alt="image-20210219214539229"></p>
<p>第三种组合方式，事件的拥有者和事件的响应者是同一个对象</p>
<p><img src="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214620011.png" alt="image-20210219214620011"></p>
<p>第四种组合方式：事件的拥有者是事件响应者的字段成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            MyForm mf = new MyForm();</span><br><span class="line">            mf.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyForm : Form &#123;//myFrom 作为事件的响应者</span><br><span class="line">        private Button button;//事件拥有者</span><br><span class="line">        private TextBox tb;</span><br><span class="line">        public MyForm()</span><br><span class="line">        &#123;</span><br><span class="line">            button = new Button();</span><br><span class="line">            tb = new TextBox();</span><br><span class="line">            this.Controls.Add(button);</span><br><span class="line">            this.Controls.Add(tb);</span><br><span class="line">            this.button.Click += this.action;//事件+=事件处理=》事件订阅</span><br><span class="line">            this.button.Text = &quot;say hello&quot;;</span><br><span class="line">            this.button.Top = 50;</span><br><span class="line">        &#125;</span><br><span class="line">        private void action(object sender, EventArgs e)</span><br><span class="line">    &#123;	</span><br><span class="line">        this.tb.Text = &quot;helloWorld&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对事件订阅时，即左侧为事件，右侧为事件处理，整个过程为订阅，则<strong>订阅过程共有三种写法</strong>，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            //this.button3.Click += this.button_Click;//这是第一种写法</span><br><span class="line">            //第二种写法，使用了EventHandler进行了委托</span><br><span class="line">            this.button3.Click += new EventHandler(this.button_Click);</span><br><span class="line">            //第三种写法，lamdam表达式</span><br><span class="line">            this.button3.Click += (sender, e) =&gt; &#123; this.textBox1.Text = &quot;我是button3&quot;; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void button_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;//一个事件处理器可以挂接多个不同的事件</span><br><span class="line">            if (sender == button1) &#123;</span><br><span class="line">                this.textBox1.Text = &quot;我是button1&quot;;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if (sender == button2) &#123;</span><br><span class="line">                this.textBox1.Text = &quot;我是button2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型：为什么用泛型？防止类膨胀和成员膨胀。</p>
<p>使用泛型的情况，类太多和成员变量太多或者不确定变量类型属于什么类型。方法泛型：当形参接受不同的数据类型，但是方法中对形参处理的逻辑一样就考虑使用方法泛型。只要写变量类型的时候就考虑用泛型 。</p>
<p>类膨胀如下，苹果对应一个盒子类和一个产品类，书对应一个盒子类一个产品类，那么1000中对应2000个类，这就是成员膨胀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      AppleBox box = new AppleBox() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box.cargo.color);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Book bk = new Book() &#123; bookName = &quot;new book&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      BookBox bb = new BookBox() &#123; book = bk &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(bb.book.bookName);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class AppleBox &#123;</span><br><span class="line"></span><br><span class="line">​    public Apple cargo &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class BookBox &#123;</span><br><span class="line"></span><br><span class="line">​    public Book book &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>成员膨胀：如下，在创建box1对象时，只用到了Apple这个属性，创建box2这个对象时只用到了Book这个属性，如果1000中商品，在Box类中就有1000个类属性，创建一个对象时，其他属性就多余，这就属于成员膨胀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      Book book = new Book()&#123; bookName = &quot;new book&quot;&#125;;</span><br><span class="line"></span><br><span class="line">​      Box box1 = new Box() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Box box2 = new Box() &#123; bk = book &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box1.cargo.color);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box2.bk.bookName);</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Box &#123;</span><br><span class="line"></span><br><span class="line">​    public Apple cargo &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">​    public Book bk &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：使用泛型，如下，当Box后面使用<Tcargo>说明，当创建Box对象时&lt;&gt;里面是什么类型，那么该类型会自动替换Box类中的Tcargo作为一种类型，box1中的cargo类型就是Apple类型，box2中的cargo类型就是Book类型。</Tcargo></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      Book book = new Book()&#123; bookName = &quot;new book&quot;&#125;;</span><br><span class="line"></span><br><span class="line">​      Box&lt;Apple&gt; box1 = new Box&lt;Apple&gt;() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Box&lt;Book&gt; box2 = new Box&lt;Book&gt;() &#123; cargo = book &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box1.cargo.color);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box2.cargo.bookName);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Box&lt;Tcargo&gt; &#123;</span><br><span class="line"></span><br><span class="line">​    public Tcargo cargo &#123; get; set; &#125;  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Partial类"><a href="#Partial类" class="headerlink" title="Partial类"></a>Partial类</h3><p>当项目比较庞大时，使用分布类可以将一个类拆分至几个文件中，这样可以使不同的开发人员同时工作，提升了工作效率。</p>
<p>使用别处的类的时候，无需创建新文件，只需要引用别处的文件中的类。</p>
<p>一般不使用，涉及到多人开发时才会使用。按照规范，一个类中一般不超过500行，一旦超过500行，就要使用分布类。</p>
<h2 id="Lambda表达式：相当于一个匿名方法"><a href="#Lambda表达式：相当于一个匿名方法" class="headerlink" title="Lambda表达式：相当于一个匿名方法"></a>Lambda表达式：相当于一个匿名方法</h2><p>Lambda表达式：在参数列表和表达式之间必须用&#x3D;&gt;连接。当一个方法它的内容不超过三行代码时，就直接用lambda表达式。</p>
<p>委托和lambda表达式混用：例如Fun&lt;int,int,int&gt; add &#x3D; (i,j)&#x3D;&gt;{return i+j};实际上就是为委托赋予了一个方法，该方法使用lambda表达式。参数为i,j,返回值为i+j。fun的传递的两个参数为int型，返回类型也为int型。所以在见到传递参数为func的时候，我们可以直接传递lambda表达式即可。</p>
<p>使用情况：在程序中只调用一次，可以使用lambda表达式，不用再创建类和方法进行调用，例如Func&lt;int,int,int&gt; func &#x3D; new Func&lt;int,int,int&gt;({int a,int b}&#x3D;&gt;{return a+b;});进行加法运算,简化后为Func&lt;int,int,int&gt; func &#x3D; (a,b)&#x3D;&gt;{return a+b;};</p>
<p>若方法体中没有返回值且只有一行代码，则方法体的大括号可以去掉，例如Action ac &#x3D; ()&#x3D;&gt;cosole.writeline(“你好”);</p>
<p>若方法体中有返回值但只有一行代码，则可以省略return以及大括号，例如Func&lt;int,int,string&gt; f1 &#x3D; (i1,i2)&#x3D;&gt;i1+i2</p>
<p>若只有一个参数，则参数的小括号可以省略，Action&lt;string,&gt; f1 &#x3D;s&#x3D;&gt;console.writeLine(s);  Func&lt;int,bool&gt; f2 &#x3D;i&#x3D;&gt; i&gt;0;</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      DoSomeCalc((a,b)=&gt;&#123;return a*b;&#125;,100,200);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    static void DoSomeCalc&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y) &#123;</span><br><span class="line"></span><br><span class="line">​      T res = func(x, y);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(res);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>lambda作为参数传递：会发现某些方法中要求传入func委托，实际上传入lambda即可例如数组有有个Count（Func&lt;T,bool&gt;）要求传入参数为T类型，返回值类型为bool类型的函数，但是T是什么时候传入的呢？bool又是什么时候使用的呢？T实际上是再Count()函数体里面传入的，需要查看源码，而不是在调用count函数作为参数传入的。返回的类型也是在count函数体里面使用的，若返回为true则把当前数值作为总数的一个。同理中间件中有个run方法，可以通过设置options对象进行配置，该对象也是在run方法里面自动进行传入的。即lambda表达式的参数和返回值都是在调用它的函数里面传入和使用的，具体怎样使用我们是未知的  </p>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>使用情况：需要为某个类添加方法时传统方法是修改代码，C#提供扩展方法</p>
<p>比如想要在某个类中添加其他一些方法，如果有源码，那么可以直接添加源码，如果没有源码，那么应该怎么办，就是使用扩展方法，但是扩展方法必须是静态的，它写在 一个静态类里面，该静态类随便起名，因为用不到该类名，只用到该方法名，然后在对应的静态方法上使用(this 类名 对象名)的方式来指定该方法属于哪个类中的扩展方法。而静态类实际上就是起一个封装的作用，不参与任何调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public static class exMethod</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Public Static void add(this Test test)&#123;//逻辑代码&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：<font color="red">静态类里的静态方法，参数列表最前面加this+要扩展的类型</font>&gt;</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Calculate&#123;//类中原本只有add方法</span><br><span class="line">	public int add(int a,int b)&#123;</span><br><span class="line">		return a+b;s</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static class CalculateNew&#123;//使用扩展方法为Calculate添加addNew方法</span><br><span class="line"></span><br><span class="line">​			public static int addNew(this Calculate cal,int a,int b,int c )&#123;//Calculate就是要为Claculate中添加了addNew方法</span><br><span class="line"></span><br><span class="line">​					return a+b+c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IComparable接口："><a href="#IComparable接口：" class="headerlink" title="IComparable接口："></a>IComparable接口：</h2><p>该接口只有一个方法Compareto方法。我们在创建对象的时候就要想到是否有必要去实现比较器功能。</p>
<p>当int数组需要排序时，只需要使用Array.Sort();方法即可，这是因为int类型实现了Icomparable接口，如果是我们自定义的类数组进行比较大小，那么无法使用sort，解决方法就是使用Icomprable中的compareto方法根据对象中的字段比较大小，然后就可以使用sort方法了。但是还有更加简单的方法排序方法可以替代它不用写compareto就是使用linq代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass[] mc = new MyClass[3];</span><br><span class="line"></span><br><span class="line">​      mc[0] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[0].value = 22;</span><br><span class="line"></span><br><span class="line">​      mc[1] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[1].value = 25;</span><br><span class="line"></span><br><span class="line">​      mc[2] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[2].value = 10;</span><br><span class="line"></span><br><span class="line">​      Array.Sort(mc);</span><br><span class="line"></span><br><span class="line">​      foreach (MyClass ml in mc)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(ml.value);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​			//使用linq即可，不用使用compareTo</span><br><span class="line"></span><br><span class="line">Var a = from s in mc orderBy s.value select s;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class MyClass:IComparable</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value;</span><br><span class="line"></span><br><span class="line">​    public int CompareTo(object obj)//使用linq不必使用compareTO</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      var cla = (MyClass)obj;</span><br><span class="line"></span><br><span class="line">​      if (this.value &lt; cla.value) return -1;</span><br><span class="line"></span><br><span class="line">​      if (this.value &gt; cla.value) return 1;</span><br><span class="line"></span><br><span class="line">​      else return 0;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="IEnumerator枚举器"><a href="#IEnumerator枚举器" class="headerlink" title="IEnumerator枚举器:"></a>IEnumerator枚举器:</h2><p>foreach的底层就是由它实现的，所以了解即可：实现该接口的都具有current，movenext()，reset()三个属性</p>
<p>Current：当前指针指向的对象</p>
<p>Movenext()：指针后移，返回bool型，新的位置有效返回true，无效返回false</p>
<p>Reset()：回原位</p>
<h2 id="IEumerable接口-枚举类"><a href="#IEumerable接口-枚举类" class="headerlink" title="IEumerable接口:枚举类"></a>IEumerable接口:枚举类</h2><p>他与集合相同，保存的类型可以是值类型也可以是引用类型，只有一个getEnumerator方法，返回对象的枚举器只有实现了该接口的类才能使用foreach，或者返回结果为IEumerable才能对其进行遍历。如果返回的集合只是用来遍历不需要修改，则返回IEumerable。如果返回的集合需要添加和删除，则返回ICollection，如果返回的集合支持排序，则需要返回Ilist。返回的结果为Ienumerable类型的一般只在Linq的返回结果中看到。</p>
<h2 id="Iqueryable"><a href="#Iqueryable" class="headerlink" title="Iqueryable"></a>Iqueryable</h2><p>与IEumerable差不多，前者是继承于后者的。两者的区别是在linq语句进行筛选时，使用IEumerable的集合类中的where方法是在客户端（内存）进行筛选的，而Iqueryable中的where是在服务器（数据库中进行筛选的），前者会多了一个将所有数据先加载到内存的过程，效率比较低。所以在数据库查询时推荐使用Iqueryable中的where，因为Iqueryable是在数据库服务器中进行筛选，所以会生成对应的sql语句，而前者不会。在linq中，上面传递的参数是func即委托，下面传递的expresson表达式树，具体使用哪个是根据linq查询的东西有关，如果是linq to object则选择IEumerable，如果是linq to sql则选择Iqueryable。</p>
<p>同时Iqueryable是延迟执行的：只有用到了foreach，tolist，toarray，min，max，count等方法的时候才会立即执行。使用延迟查询的原因是方便用户，比如根据不同的条件进行不同的查询语句，只有真正满足条件之后在用foreach进行立即查询，执行最后的遍历</p>
<p>Foreach举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Int[] arr = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">Foreach(int a in arr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.writeLine(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">它的底层代码如下:</span><br><span class="line"></span><br><span class="line">Int[] arr = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">IEnumerator I = arr.getEnumerator();</span><br><span class="line"></span><br><span class="line">While(i.moveNext())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​	Console.write(i.current)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.writeLine();</span><br></pre></td></tr></table></figure>

<p>所以在99%情况下我们完全可以使用foreach代替for，那1%的情况就是如果对集合实现增删，就必须得使用for而不能使用foreach</p>
<p>迭代器：它是来替代枚举器的更好的一种方法。</p>
<h1 id="expression与Func的区别"><a href="#expression与Func的区别" class="headerlink" title="expression与Func的区别"></a>expression与Func的区别</h1><p>使用上没有什么区别，底层有区别。但expression在生成sql代码的时候可以通过vs查看到树的结构，而Func不行,一般与数据库相关有expression，而其他情况使用func。另一个区别与Ienumerable和iquerable的区别一样，expression在筛选的时候是深入到数据库中进行筛选的，而func是将所有数据从数据库中放到内存后进行筛选的（比较慢），所以对于操作数据库的，我们一般使用expression代替func </p>
<h1 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h1><p>让数据处理变得更简单</p>
<p>常用扩展方法：凡是实现IEnumrable接口的都可以使用linq，例如，数组，集合（colletion），字典（directory），Set等。里面的每个元素作为参数传递到func方法中。</p>
<p>Linq：from语句指定数据源，where语句指定筛选语句，select语句指定返回的类型</p>
<p>from c in list where c.age &#x3D;&#x3D;20 select c;</p>
<p>(from c in list where c.age &gt; 20 selcet c).first();</p>
<p>综上比较会误认为第一种比较快，但实际上第二种效率快。因为第一种是查询了所有的age然后返回一个年龄为20的，而第二种是找到一个大于20的立刻返回。这就体现了first（）方法的效率，Take（2）方法同样，返回两个满足条件的，所以我们应该充分使用first和take方法。</p>
<h3 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h3><p>1.where方法：每一项数据都会经过测试，如果func执行的返回结果为true，则该元素就会放到返回值中，返回类型为IEnumrable,使用where意味着后面可以使用链式调用使用其他的linq表达式，比如list.where(e&#x3D;&gt;e.salary&gt;8000).Any();凡是返回IEnumrable的意味着可以进行链式编程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int[] nums = new int[] &#123; 1, 2, 3, 5, 6, 7 &#125;;</span><br><span class="line">			//where方法不是数组的特有方法，而是他的扩展方法，where方法会遍历集合中每个元素，对于每个元素都调用a=&gt; a&gt;10这个表达式，判断是否为true，如果为true，则把这个放到返回的集合中（lambda表达式返回结果为集合），where的参数为func委托</span><br><span class="line">            IEnumerable&lt;int&gt; result = nums.Where(a=&gt;a&gt;3);//设里面的每个元素为a，传递参数a，并判断</span><br><span class="line">            foreach(int i in result) </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i);</span><br><span class="line">            &#125;        </span><br><span class="line"> 该方法背后的秘密,自己定义一个where方法</span><br><span class="line"> staic IEnumerable&lt;int&gt; where(IEnumrable&lt;int&gt; items,Func&lt;int,bool&gt; f)</span><br><span class="line"> &#123;</span><br><span class="line"> 	List&lt;int&gt; result = new List&lt;int&gt;(); //定义一个集合用来存储符合条件的数据</span><br><span class="line"> 	foreach(int i in items)//遍历</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		if(f(i) == true)//其中委托方法里面用来判定数据是否大于3，返回类型为bool</span><br><span class="line"> 		&#123;</span><br><span class="line"> 		result.add(i); //将a&gt;3的数据装入到集合中</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	return result;//返回该集合</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>2.count方法：获取数据的条数，返回类型为int</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.Count(e=&gt;e.salary&gt;3000);</span><br><span class="line">等价于list.where(e=&gt;e.salary&gt;3000).Count();</span><br></pre></td></tr></table></figure>

<p>3.any（）方法：是否至少有一条数据返回类型为bool</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义一个员工类包含，姓名年龄，性别，工资</span><br><span class="line">var items = list.where(e=&gt;e.age&gt;30);</span><br><span class="line">foreach(var emp in items)</span><br><span class="line">&#123;</span><br><span class="line">	//遍历即可</span><br><span class="line">&#125;</span><br><span class="line">int count1 =list.Count(e=&gt;e.salary &gt;2000||e.age&lt;30);//获取工资大于2000，年龄小于30的员工数量</span><br><span class="line">list.Any(e=&gt;e.salary&gt;3000);//是否有大于工资大于3000的员工</span><br><span class="line">等价于list.where(e=&gt;e.salary&gt;3000).Any();</span><br></pre></td></tr></table></figure>

<p>4.Single()：是否只有一条满足要求的数据，并返回该条数据。返回类型为数据对应的类型，若有多条则报错</p>
<p>5.SingleOrDefault:最多只有一条满足要求的数据,(有0条或者1条满足条件的数据)，返回类型为数据对应的类型，若0条，则返回null而不是报错</p>
<p>6.First（）：至少有一条，返回第一条。若0条则报错</p>
<p>7.FirlstOrDefault：返回第一条或者0条。0条是返回null</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e1 = items.Single(e=&gt;e.name==&quot;tom&quot;);//是否只有一条并返回该条数据。</span><br><span class="line">Employee e2 = items.First(e=&gt;e.age&gt;30);//返回第一条满足条件的数据</span><br><span class="line">Employee e3 = items.FirstOrDefault(e=&gt;e.age&gt;30);//</span><br></pre></td></tr></table></figure>

<h3 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h3><p>8.list.orderBy(e&#x3D;&gt;e.salary);&#x2F;&#x2F;正向排序，返回的是IEnumrable</p>
<p>9.orderByDescending();&#x2F;&#x2F;倒叙排序。返回的是IEnumrable</p>
<h3 id="多排序"><a href="#多排序" class="headerlink" title="多排序"></a>多排序</h3><p>10.ThenBy();&#x2F;&#x2F;前面排序完之后，再按照其他条件排序。例如Ordby(e&#x3D;e.age).ThenBy(e&#x3D;&gt;e.salary);即按照年龄排序完成之后有可能年龄相同，将年龄相同的再按照工资排序。即优先按照orderby，然后按照thenby</p>
<p>11.ThenByDescending();&#x2F;&#x2F;反序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEnumrable&lt;Employee&gt; itmes = list.orderBy(e=&gt;e.age);//按照年龄正向排序</span><br><span class="line">IEnumrable&lt;Employee&gt; itmes2 = list.OrderBuDescending(e=&gt;e.salary);//按照工资倒叙排序</span><br><span class="line">IEnumrable&lt;Employee&gt; itmes3 = list.orderBy(e=&gt;e.Name[e.Name.Length-1]);//根据姓名的最后一个字母排序</span><br></pre></td></tr></table></figure>

<h3 id="获取部分数据（分页）"><a href="#获取部分数据（分页）" class="headerlink" title="获取部分数据（分页）"></a>获取部分数据（分页）</h3><p>12.Skip(n);表示跳过n条数据，返回Ienumrable</p>
<p>13.Take（n）；表示获取前n条数据返回类型IEnumrable  例如List.Skip(3).Take(2);&#x2F;&#x2F;跳过三条数据获取两条数据。</p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>14.Max（）；list.Max(e&#x3D;&gt;e.age);&#x2F;&#x2F;获取年龄最大值</p>
<p>15.Min（）；</p>
<p>16.Average（）；</p>
<p>17.Sum();</p>
<p>18.Count();</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>19.GroupBy();返回类型IEnumrable&lt;IGrouping&lt;泛型一，泛型二&gt;&gt;</p>
<h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>把集合中每一项数据只获取其中的属性值，与sql中的select完全一样,之前返回结果都是一个对象，而该方法只获取对象中的属性</p>
<p>Select投影方法的使用：把查出来的结果映射到新的对象上，而不是在数据中进行条件查询。</p>
<p>投影方法是linq中的语句，对序列或者集合进行使用，返回结果为IEnumrable，意味着只能对其进行遍历，如果想转换为集合，在返回的集合后面添加toList()方法即可。</p>
<p>20.select(); &#x2F;&#x2F;返回类型为IEnumrable</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumrable&lt;string&gt; items = list.select(e=&gt;e.Name+e.age);//</span><br><span class="line"></span><br><span class="line">foreach(string i in items)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">​	console.writelin(i);</span><br><span class="line">&#125;</span><br><span class="line">var niming = list.select(e=&gt;new&#123;xingming = e.name,nianling = e.age,xingbie = e.gender?&quot;男&quot;:&quot;女&quot;&#125;)；//返回一个新建的匿名类型</span><br></pre></td></tr></table></figure>

<h3 id="集合类型之间相互转换"><a href="#集合类型之间相互转换" class="headerlink" title="集合类型之间相互转换"></a>集合类型之间相互转换</h3><p>21.ToArray();&#x2F;&#x2F;将IEnumrable类型转换为数组类型</p>
<p>22.ToList();&#x2F;&#x2F;将IEnumrable类型转换为集合类型</p>
<p>总结：返回类型为IEnumrable的方法：where，select，orderby，groupby，take，skip，take，groupby，select等可以使用链式调用</p>
<h2 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h2><p>有两种方式，一种是使用Typeof（类名）返回的类型是Type类型，里面封装了所有该类的信息，包括所有方法的集合，所有方法参数的集合等</p>
<p>第二种是使用对象名.getType();&#x2F;&#x2F;后返回一个Type类型，获取所有信息</p>
<p>MyClass ms &#x3D; new MyClass();</p>
<p>​      Console.WriteLine(typeof(MyClass).GetFields()[0]);</p>
<p>​      Console.WriteLine(ms.GetType().GetFields()[0]);</p>
<p>一般会使用到的地方：判断某个控件是否属于某个类型的控件</p>
<p>foreach(control c in Controls){&#x2F;&#x2F;遍历所有控件的集合</p>
<p>if(c.getType()&#x3D;&#x3D;TypeOf(TextBox)&#x2F;&#x2F;判断是否为TextBox控件</p>
<p>{</p>
<p>​	</p>
<p>}</p>
<p>}</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>对于在写程序时，程序员发现可能出现的异常有两种处理方法：</p>
<p>1.使用trycatchfanally</p>
<p>2.对于处理不了的异常则主动抛出。即throw new Exception。例如原本应该传递一个对象参数，结果传递进来一个null，则主动抛出异常</p>
<p>例如说，由于内存资源有限导致需要分配的内存失败了；或某个目录下本应存在的一个文件找不着了；或说不小心被零除了、内存越界了、数组越界了等等。这些错误事件存在非常大的隐患，因此程序员总需要在程序中不断加入if语句，来判断是否有异常出现，如果有，就必须要及时处理，否则可能带来意想不到的后果。但是这样一来，程序可读性差了很多，总是有许多与真正工作无关的代码，而且也给程序员增加了极大的工作负担。）</p>
<p>3.使用异常处理后：1、把错误处理和真正的工作分开来； 2、 代码更易组织，更清晰，复杂的工作任务更容易实现； 3、 毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了；</p>
<h2 id="特性：Attribute"><a href="#特性：Attribute" class="headerlink" title="特性：Attribute"></a>特性：Attribute</h2><p>特性实际上就是一个类，他们都继承于Attribute这个类,需要导包。</p>
<p>使用场景：数据验证，类上，方法上，属性上，参数上。但是对于大项目不推荐，而且自定义校验就则写起来麻烦，推荐使用fluent api的方式</p>
<p>常见特性：</p>
<p>1.类上使用：[Obsolete(“”,true)]:表明该类已经过时, [DebuggerStepThrough]:跳过调试，[Authorize]:授权特性</p>
<p>2.方法上使用：[HttpGet]:要求只能get提交  [HttpPost]:要求只能post提交</p>
<p>3.属性上使用：</p>
<p>【Key】:主键</p>
<p>【Required】:不许为空</p>
<p>【DisplayName(“修改姓名”)】;修改发送给前端的属性名</p>
<p>【StringLength(maxmumlength:50,minmumlength:20)】:字符串长度</p>
<p>【EmaiAddress】:Email地址格式</p>
<p>【Phone】:电话号码格式</p>
<p>【Range】数据范围</p>
<p>【MinLength】：字符串最小长度</p>
<p>【MaxLength】：字符串最大长度</p>
<p>【Compare】：比较是否相等</p>
<p>【RegularExpression】：正则表达式</p>
<p>在控制器中，使用if(Modelstate.isvalid){}&#x2F;&#x2F;来判断上面的特性是否验证成功。</p>
<p>【ForeignKey(nameof(Class))】:引入外键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">自己创建特性：</span><br><span class="line"></span><br><span class="line">​	Class DefindAtrribute:Attribute&#123;</span><br><span class="line"></span><br><span class="line">​			public DefindAttribute(String showInfo)&#123;</span><br><span class="line"></span><br><span class="line">​				console.writelin(showInfo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当调用该特性时为[Defind(&quot;自定义特性&quot;)]</span><br></pre></td></tr></table></figure>

<p>所有的特性再视图-》对象浏览器下面搜索</p>
<p><img src="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/assets/image-20220129112920767.png" alt="image-20220129112920767"></p>
<h3 id="异步和多线程："><a href="#异步和多线程：" class="headerlink" title="异步和多线程："></a>异步和多线程：</h3><p>多线程：用于计算密集型</p>
<p>异步：用于IO密集型</p>
<p>例如点击一个按钮，该按钮处理的逻辑太多（比如加载网页内容过多），导致主线程阻滞，这时可以开启一个新的线程去处理该按钮，而主线程还可以处理其他的东西。</p>
<p>异步</p>
<h2 id="设计架构："><a href="#设计架构：" class="headerlink" title="设计架构："></a>设计架构：</h2><p>\1. 抽象类的构造方法设置成protect的，因为不用他创建对象。</p>
<p>\2. IEnumerable</p>
<p>\3. 优先考虑将基类或者接口作为形参</p>
<p>\4. 用params减少重复的形参</p>
<p>\5. 接口和抽象类选择：接口的功能比较单一，比如只有一个方法，而抽象类功能多样。抽象类和子类之间关系密切，包含很多相似功能，而接口和子类关系不大，子类只是为了实现接口的某一功能。</p>
<p>使用sealed修饰的类不能被继承</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>Title:</span><a href="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/"></a></p>
        <p><span>Author:</span><a href="/" title="Back to Homepage"></a></p>
        <p><span>Created:</span>2022-07-17, 09:44:21</p>
        <p><span>Updated:</span>2022-10-30, 10:34:18</p>
        <p>
            <span>Full URL:</span><a class="post-url" href="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/" title="">https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/</a>
            <span class="copy-path" data-clipboard-text="From https://gao-hongfei123.github.io/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/　　By " title="Copy Article&#39;s Link &amp; Author"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>License:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"CC BY-NC-SA 4.0"</a> Keep Link &amp; Author if Distribute.
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2022/07/17/ef%E5%AD%A6%E4%B9%A0/">
                    
                </a>
            </div>
        
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vs%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">vs设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git%E6%8E%A8%E9%80%81"><span class="toc-number">2.</span> <span class="toc-text">git推送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">窗口设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AE%B9"><span class="toc-number">4.</span> <span class="toc-text">内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">基础知识：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">4.2.</span> <span class="toc-text">名称空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AD%97%E6%AE%B5"><span class="toc-number">4.3.</span> <span class="toc-text">属性，字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">构造器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">字符串处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">小数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">4.8.</span> <span class="toc-text">Dynamic关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">4.9.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">4.10.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.11.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E8%BD%AC"><span class="toc-number">4.12.</span> <span class="toc-text">强转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.13.</span> <span class="toc-text">判断字符串不能为空的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.14.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">4.15.</span> <span class="toc-text">接口：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.16.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%EF%BC%9A"><span class="toc-number">4.17.</span> <span class="toc-text">权限：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is%E5%92%8Cas"><span class="toc-number">4.18.</span> <span class="toc-text">is和as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">4.19.</span> <span class="toc-text">匿名对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.20.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8get-set-%E6%96%B9%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="toc-number">4.21.</span> <span class="toc-text">使用get(),set()方法的意义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">4.22.</span> <span class="toc-text">ref关键字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#out%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.23.</span> <span class="toc-text">out关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parames%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.24.</span> <span class="toc-text">parames关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">4.25.</span> <span class="toc-text">具名参数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%EF%BC%9A"><span class="toc-number">4.26.</span> <span class="toc-text">集合：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">4.27.</span> <span class="toc-text">委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.28.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.29.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial%E7%B1%BB"><span class="toc-number">4.30.</span> <span class="toc-text">Partial类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A%E7%9B%B8%E5%BD%93%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">Lambda表达式：相当于一个匿名方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">扩展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IComparable%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">IComparable接口：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerator%E6%9E%9A%E4%B8%BE%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">IEnumerator枚举器:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEumerable%E6%8E%A5%E5%8F%A3-%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">IEumerable接口:枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iqueryable"><span class="toc-number">10.</span> <span class="toc-text">Iqueryable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#expression%E4%B8%8EFunc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">expression与Func的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LINQ"><span class="toc-number"></span> <span class="toc-text">LINQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E5%A6%82"><span class="toc-number">0.1.</span> <span class="toc-text">比如</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">0.2.</span> <span class="toc-text">排序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%8E%92%E5%BA%8F"><span class="toc-number">0.3.</span> <span class="toc-text">多排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%EF%BC%88%E5%88%86%E9%A1%B5%EF%BC%89"><span class="toc-number">0.4.</span> <span class="toc-text">获取部分数据（分页）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">0.5.</span> <span class="toc-text">聚合函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84"><span class="toc-number">0.6.</span> <span class="toc-text">分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%BD%B1"><span class="toc-number">0.7.</span> <span class="toc-text">投影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">0.8.</span> <span class="toc-text">集合类型之间相互转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">反射：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9AAttribute"><span class="toc-number">3.</span> <span class="toc-text">特性：Attribute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">异步和多线程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">设计架构：</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="Hide"  title="Show or Hide Table of Contents">

    <script>
        yiliaConfig.toc = ["Hide", "Show", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"　| Hexo　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2022/07/17/ef%E5%AD%A6%E4%B9%A0/" title="Pre: ">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="Mini Archives"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/" title="Back to Homepage"><i class="fa fa-home"></i></a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/10/29/Maui/">Maui</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/02/blazor%E5%AD%A6%E4%B9%A0/">blazor学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/08/04/matlab/">matlab</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/%E9%A1%B9%E7%9B%AE/">项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">网络安全基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/%E5%89%8D%E7%AB%AF/">前端学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/winform%E5%AD%A6%E4%B9%A0/">winform控件</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/SqlSugar/">SqlSugar</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/net5%E9%A1%B9%E7%9B%AE/">net5项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/net5/">net core</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/MVC/">MVC</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/ef%E5%AD%A6%E4%B9%A0/">ef学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/07/17/csharp%E5%AD%A6%E4%B9%A0/">csharp学习</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2022 技术爱好者
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="A fast, simple &amp; powerful blog framework">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="Another simple and elegant theme for Hexo  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="Site Visitors"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="Page Hits"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="Back to Top"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="Comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="Go to Bottom"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
             title: "a.article-title, .article-more-link a", 
            
             tags: ".article-tag a", 
             categories: ".article-category a, a.tag-list-link", 
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
             menu: ".header-menu a", 
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>