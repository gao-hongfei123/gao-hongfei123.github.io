<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>MVC5：新建项目的时候选择web项目-》mvc</p>
<p>更换访问端口：右击项目-》属性-》web</p>
<p>MVC是一种web开发框架。</p>
<p>​    Models：实体模型，就是用来操作数据库的</p>
<p>​    View：视图，用户可以看到的前端界面</p>
<p>​    Controllor：决定用户调用哪个视图，调用哪个逻辑计算</p>
<p>vs2013在iis上发布一个网站：</p>
<p>​    1.首先点击项目于右键-》发布-》自定义-》输入一个发布名-》发布方法选择文件系统-》目标位置选择当前项目所在的路径名-》点击发布完成。发布就是将网站源码打包成一个文件夹，将源码封装起来。不让用户看见源码，例如写完的exe文件就是已经打包好的。</p>
<p>​    2.在iis上添加一个网站-》设置网站名称-》网站路径选择 发布的项目。部署完成。部署就是将文件夹发布到iis上。</p>
<p>获取前端提交数据的两种方式</p>
<p>一：使用内置对象request方式获取</p>
<p>二（推荐）：在控制器的index的方法添加参数例如public ActionResult Index(string name){其他代码}，其中的参数就是前端页面提交的数据</p>
<h1 id="访问原理："><a href="#访问原理：" class="headerlink" title="访问原理："></a>访问原理：</h1><p>客户端通过访问view中某个cs文件下的某个方法进行访问默认是index，会自动返回view中的html界面。例如192.168.0.1：2021/Home/index</p>
<p>控制器中的方法称为action。</p>
<h1 id="通过控制器传递到view的方式："><a href="#通过控制器传递到view的方式：" class="headerlink" title="通过控制器传递到view的方式："></a>通过控制器传递到view的方式：</h1><h2 id="view访问controller中的数据"><a href="#view访问controller中的数据" class="headerlink" title="view访问controller中的数据"></a>view访问controller中的数据</h2><p>在一个控制器中手写一个方法，右键该方法-》视图-》添加视图即可看见在view中添加了对应的html。当控制器中的方法执行时，该方法的返回值return view();会自动定位到view中的cshtml。</p>
<p>访问方式：客户端通过访问controller中某个cs文件下的某个方法进行访问默认是index，会自动返回view中的html界面。</p>
<p>控制器中的方法称为action。</p>
<p>返回类型actionResult子类有viewresult（返回相应的视图），contentresult（返回字符串），rederectresult（重定向），redirecttoaction（重定向某一个方法上）</p>
<p>控制器中的数据显示到cshtml的代码：</p>
<p>​    方式一：使用viewBag.变量名 = “显示内容”，然后在cshtml中写入@viewBag.变量名。就会最终将后端的内容显示到前端界面。</p>
<p>​    方式二：使用ViewData[“变量名”]=”显示内容”，在cshtml中写入@viewData[“变量名”]即可。</p>
<p>​    方式三：使用tempdata[“变量名”]=“显示内容”，cshtml中写入@tempdatea[“变量名”]即可显示    特点：只能够访问一次，之后立即消失</p>
<pre><code>        ViewBag.content = &quot;这是controller中的数据&quot;;
        ViewData[&quot;Name&quot;] = &quot;张三&quot;;
        TempData[&quot;age&quot;] = &quot;24&quot;;
        @ViewBag.content
        @ViewData[&quot;name&quot;]
        @TempData[&quot;age&quot;]
</code></pre>
<p>方式四：通过传递model（对象）的形式（这种方式用来传递主要数据，上面三种用来传递零碎数据）</p>
<p>public ActionResult Index(string name)</p>
<p>​    {</p>
<p>​      ViewBag.content = “这是controller中的数据”;</p>
<p>​      ViewData[“Name”] = “张三”;</p>
<p>​      TempData[“age”] = “24”;//特点，只能访问一次，第二次访问就会消失</p>
<p>​      Student stu = new Student();//这是model中的对象</p>
<p>​      stu.id = 12;</p>
<p>​      stu.name = “张三”;</p>
<p>​      stu.age = 24;</p>
<p>​      return view(student);</p>
<p>​    }</p>
<h2 id="view访问model中的数据"><a href="#view访问model中的数据" class="headerlink" title="view访问model中的数据"></a>view访问model中的数据</h2><p>注意：虽然在一个项目中，但是如果在controller中创建model中的对象，仍需要引用命名空间。</p>
<p>view不能够直接访问model中的数据，需要通过controller作为中介。在contoller中创建model的对象，将这个对象通过controller中返回的view()的第三个参数进行传递。然后在view中使用@Model.id<br>@Model.age@Model..name的形式获取model中的数据。</p>
<p>注意（在view中如果直接使用@Model.age那么后面的age是不会提示的，因为控制器返回的是一个object类型，所以需要在view中的首行进行拆箱，写入@model MVC.Models.Student，这样它才会提示对象的各种属性）</p>
<pre><code>model中：

public class Student
    {
        public int id;
        public string name;
        public int age; 
    }

controller中：

 Student stu = new Student();
            stu.id = 12;
            stu.name = &quot;张三&quot;;
            stu.age = 24;
​            return View(stu);

view中：
@model MVC.Models.Student//小写model，手动添加进行拆箱
@Model.id//大写Model
@Model.age
@Model..name
</code></pre>
<p>将view中的数据传递到controller的方式：</p>
<p>方式一：Request.QueryString[“提交的键”];(适用于get提交方式)</p>
<p>Request.Form[“提交的键”];//适用于post提交方式</p>
<p>方式二：直接通过action的形参获取即可：缺点如果提交的参数过多，那么index方法中的形参也就越多，所以微软推荐方式三</p>
<p>public ActionResult Index(string name,string password)</p>
<p>{</p>
<p>//在前端传递了一个name参数，那么index中的name形参就会接收到</p>
<p>Return Content(name+password)</p>
<p>}</p>
<p>方式三：在model中创建一个专门用来存取数据的类，里面的属性就是前端传递的数据参数，前端传递了name和password，在控制器的index中用类对象作为形参，方法中直接对象.变量名使用即可。但是注意：model中的属性必须添加get，set即使用prop自动生成，否则访问不了。</p>
<p>public ActionResult login(LoginUser user) {</p>
<p>​      if (ModelState.IsValid)</p>
<p>​      {</p>
<p>​        if (user.name == “张三” &amp;&amp; user.password == “123”)</p>
<p>​        {</p>
<p>​          return Content(“登录成功”);</p>
<p>​        }</p>
<p>​        else</p>
<p>​        {</p>
<p>​          return Content(“登录失败”);</p>
<p>​        }</p>
<p>​      }</p>
<p>​      else {</p>
<p>​        return Content(“您的数据有误”);</p>
<p>​      }</p>
<p>​    }</p>
<p>根据控制器自动生成前端页面。使用前端进行账号密码验证</p>
<p>1.Controller的action写完后，添加视图模板中选择create，</p>
<p>2.模型类选择需要需要使用的类，类似上面方法三中传递的LoginUser类，</p>
<p>3.勾选添加脚本</p>
<p><img src="MVC/assets/wps4C5A.tmp.jpg" alt="img"></p>
<h1 id="MVC的目录结构："><a href="#MVC的目录结构：" class="headerlink" title="MVC的目录结构："></a>MVC的目录结构：</h1><p>​    AppStart：</p>
<p>​    Bundle：打包器：作用1.压缩文件2.随着js文件的更新而更新。</p>
<p>​    Filter：过滤器</p>
<p>​    Route:路由配置</p>
<p>​    Content：css样式</p>
<p>​    Controller：控制器，默认控制器下的所有方法都是action方法。默认控制器名字HomeContrller。默认的action（默认页面）是控制器中的index方法。controller中的方法返回的是个view对象，根据源码view类有多个重写方法。1.不含参2.一个参数3.两个参数4.三个参数。其中第一个参数viewname指的的视图名，如果不写表示当前方法对应的view中的cshtml，如果更改就显示另一个cshtml页面。第二个参数mastername表示母版页，如果不写默认使用viewstart中指定的母版页，第三个参数是一个object对象，默认为null。</p>
<p>​    Font：里面放的是图标和字体</p>
<p>​    Model：实际上就是操作数据库的数据处理模型</p>
<p>​    Script：js文件</p>
<p>​    View：视图：注意controller里面的文件（例如homeController.cs）在view中有对应的文件名的文件夹（对应为Home）。同时controller的类文件里面的方法（比如说index方法）,在view下的对应文件夹下有对应的html文件(对应为index.cshtml)；</p>
<p>​        Shared：里面的layout文件是个完整的前端页面（相当于一个母版），在其里面有个@renderbody()这句代码，这句代码相当于一个占位符，当用户指定Home文件下下的index.cshtml时就会将index里面的代码替换掉renderbody。如果home文件下的某个html页面不想用layout中的模板，那么就在该页面中ViewBag.Title = “页面名”;的下一行添加layout = null;这句代码。</p>
<p>​        Vewstart文件：里面的一句代码Layout = “~/Views/Shared/_Layout.cshtml”;指定了mvc默认开始访问的页面就是layout.html页面。所以viewstart是前端页面的开始。</p>
<h2 id="Mvc中的内置对象（注意是对象）"><a href="#Mvc中的内置对象（注意是对象）" class="headerlink" title="Mvc中的内置对象（注意是对象）"></a>Mvc中的内置对象（注意是对象）</h2><p>客户端的数据在mvc中都是通过键值对进行获取的保存的。</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>a) 使用get方式进行了提交（例？name=123）那么获取方式就是Request.QueryString[“name”];</p>
<p>b) 使用post方式进行提交，获取字符串数据方式：Request.Form[“name”];</p>
<p>获取用户上传的文件：</p>
<p>Request.Files[“file”].SaveAs(Request.MapPath(“~/upload/“+Request.Files[“file”].FileName))</p>
<p>Request.Files[“file”];//file文件是用户通过前端进行上传的文件。但是注意上传成功后必须点击点击当前项目，找到解决方案资源管理器中的显示所有文件的图标，否则上传成功后在文件夹下找不到。</p>
<p>SaveAs()；将上传的文件保存在当前项目的文件夹下（必须使用绝对路径）</p>
<p>Request.MapPath(“~/upload/“+Request.Files[“file”].FileName)；将相对路径转换为绝对路径。即保存在当前项目下upload文件夹下以原文件名命名的文件。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response.write(“helloworld”);//向客户端输出内容</p>
<p>Response.redirect(url);//重定向</p>
<p>Response.StatusCode()//返回的状态吗</p>
<h3 id="Session-保存在服务器中，用来存储少量重要数据。比如账号"><a href="#Session-保存在服务器中，用来存储少量重要数据。比如账号" class="headerlink" title="Session:保存在服务器中，用来存储少量重要数据。比如账号"></a>Session:保存在服务器中，用来存储少量重要数据。比如账号</h3><p>Session[“user”]=request.form[“user”];//是通过键值对的方式进行保存的。</p>
<p>Session默认存货时间20分钟</p>
<p>Session.abanon/session.clear()//清除session</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>向客户端保存cookie：response.cookies.add(new HttpCookie(“token”){</p>
<p>​        Value = “acb456453156”；//token的值</p>
<p>​        Expires = DateTime.Now.AddDays(1);//保存时间为1天</p>
<p>});</p>
<p>从客户端获取cookie：Request.Cookies[“token”].Value</p>
<p>删除cookie：response.cookies.add(new HttpCookie(“token”){</p>
<p>​        Expires = DateTime.Now.AddDays(-1);//时间改为负值进行删除cookie</p>
<p>});</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>保存在服务器中与session的区别，session是每个人只能访问自己的session，而application是可以互相访问的</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>封装了了服务器常用属性。比如服务器名称等。</p>
<p>Server.transfer();//转发。重新打开一个页面但是该页面与之前的页面必须在同一个文件下。即转发不能转发外站的内容。而重定向可以定位到一个外站的内容。</p>
