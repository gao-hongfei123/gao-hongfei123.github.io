<h2 id="vs设置"><a href="#vs设置" class="headerlink" title="vs设置"></a>vs设置</h2><p>vs中F6键：生成语法错误，可以定位到错误位置。</p>
<p>设置当前启动项目，点击解决资源管理器，右击，属性，启动项目设置为当前选定内容。</p>
<p>多行注释：ctrl + k+c,取消多行注释：ctrl +k +u</p>
<p>输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键</p>
<p>构造器快捷键：ctor+两次tab键</p>
<p>激活key：BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<p>对于一些控件的属性设置在，视图选项卡的属性可以调出</p>
<p>鼠标放在某个类上直接按住F1键，会自动定位到对该类的解释文档。</p>
<p>直接删除某行ctrl+L</p>
<p>assembly ：类库</p>
<p>Ctrl+.快捷键或者ctrl+j，是智能识别快捷键，相当于eclipse中的alt+/,java中完全使用接口interface代替了委托</p>
<p>自动实现接口中的所有方法：alt+insert</p>
<p>替换快捷键：ctrl+r</p>
<h2 id="窗口设置"><a href="#窗口设置" class="headerlink" title="窗口设置"></a>窗口设置</h2><p>窗口标题更改：属性：外观，text修改即可</p>
<p>修改窗口左上角小图标：窗口样式，Icon，选择图片进行设置即可，最大不超过72x72</p>
<p>窗体出现的位置设置：布局，startposition。</p>
<p>固定窗口的大小，不允许改变：布局，AntoSize= false</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>方法重载区别点：1.返回类型，2.传参类型，3.传参数目</p>
<p>判断类，数据类型等，type a = typeof(int);</p>
<p>类的继承：使用‘：’进行继承，而java中是使用extends关键词进行继承，代码如下</p>
<p>class Person : Student{</p>
<p>}</p>
<p>Sizeof方法只能计算基本数据类型的大小。例如sizeof(int)。</p>
<p>对一个变量求相反数：- -x这是错误的，-(-x)这是正确的。</p>
<p>While语句与for语句的使用情况，当知道执行循环次数的时候使用for循环，其他情况的时候都是使用while语句。Foreach语句是迭代器，只能用于迭代集合中的元素或者数组。</p>
<p>readonly关键字：表示该变量只能被赋予一次值 public readonly int ID;</p>
<p>main方法中string[] args 说明声明的是长度为0的字符串数组。</p>
<p>栈：存储局部变量            </p>
<p>堆：new出来的对象</p>
<p> 默认赋值：整形：0，浮点型0.0，布尔型：false，字符型：\u0000;</p>
<p>静态：非静态成员方法既可以访问静态，也可以访问非静态，静态成员方法只可以访问静态</p>
<p>Public 不同项目中可以使用  internal(或者不写)限制在统一个项目中，被sealed修饰的类不能被继承，子类访问级别不能超过父类</p>
<h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>namespace ：use system实际上就是使用了名称空间。就是将类放在名称空间里面，例如Console.WriteLine这个方法，使用的console这个类就是system这个名称空间里面的类，如果没有use system这个调用，需要使用system.console.writeline这个方法使用，这是比较麻烦的，所以程序开头就直接引用system这个名称空间。如何寻找命名空间：把一个类名写出来后，点击这个类，左下角会自动出现所属命名空间，引用即可。</p>
<p>属性 property 方法：method ，事件event</p>
<p>命名：类或者接口:大驼峰</p>
<p>​            变量和方法：小驼峰</p>
<p>​            常量：全部大写</p>
<h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><p>如果类中定义了构造器，那么系统就不会提供默认无参构造器，否则系统提供默认无参构造器。构造器的作用：该类在被创建对象时，就会自动执行构造器的内容，不需要再后续代码中再重新指定，相当于所有来自于该类的对象的共有属性。</p>
<p>构造方法：为对象的属性进行赋值，这样在创建对象时，直接在创建对象的形参中传入参数即可，不必每次都使用set方法，例如new Student(‘张三’,23);，为了使构造方法多样性，可以重载构造方法。若自己写出有参构造方法，那么系统不会提供无参构造，无参构造需要自己写才能调用。构造方法用来初始化属性和set，get方法作用差不多，可以后续对属性进行修改，推荐使用get，set方法，因为更加灵活。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><pre><code> //判断Form类属于什么类型
            Type myForm = typeof(Form);
            Console.WriteLine(myForm);
            //Console.WriteLine(Form);这是错误的，java可以直接这样输出一个类的信息，但是c#不可以
</code></pre>
<pre><code>var的变量类型， static void Main(string[] args)
    {
        Console.WriteLine();
        var a = 3;
        var b = 3L;
        var c = &quot;hello world&quot;;

        Console.Write(a.GetType().Name);
        Console.Write(a.GetType().Name);
        Console.WriteLine(c.GetType().Name);

    }结果为  Int32
            Int32
            String，说明var类型是个自动识别变量类型的变量。
</code></pre>
<p>数据类型和表示范围：int ：占4个字节，long :占8个字节，byte，一个字节，short：两个字节，float :4个字节，double:8个字节，char：2个字节，bool，1/8个字节，<font color='red'>整数默认是int，小数默认是double</font>&gt;，所以long x=8888888888L错误，float x = 12.3错误，应为float x = 12.3f。</p>
<p><img src="csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png" alt="image-20210202203407102"></p>
<p>c#五大数据类型： 1.类类型class</p>
<p>​                                2.接口interface</p>
<p>​                                3.结构体类型struct</p>
<p>​                                4.枚举类型（enum）：即给类的某个属性设置为某几个固定值，可以任意选择。（一对多）</p>
<p>​                                5.委托类型deledates</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：  静态方法不能被继承，</p>
<p>子类只能继承父类的非私有化成员，</p>
<p>子类不能继承父类的构造方法，若调用，需使用base关键字</p>
<p>若父类和子类中有相同的成员变量，根据就近原则优先使用子类的，子类没有的话会去调用父类。方法同样优先调用子类方法   </p>
<p>继承：子类 is 父类，is关键字就是判断符</p>
<p>父类的构造器不可以被子类继承，因为每个类的构造器名必须与它自己的类名相同，所以当父类使用有参构造的时候，子类中的空参构造默认调用（是调用不是继承）父类的空参构造(即类似java中子类构造器中默认会有super())，而父类不提供空参构造，所以导致报错，解决方法:在子类中创建有参构造调用父类的有参构造</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Son s = new Son(5000);

​      Console.WriteLine(s.money);

​    }

  }

  

  class Father

  {

​    public int money;

​    public Father(int money)

​    {

​      this.money = money;

​    }

  }

  class Son :Father{

​    public Son(int money):base(money)//手动让子类的有参构造调用父类的有参构造

​    {

​    }

  }
</code></pre>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写：子类继承了父类中的方法，同时将父类中的方法进行了改造，优先使用子类的方法，重写的返回值是相同的或者是子父类之间的关系，参数列表必须一样</p>
<p>注意c#中的重写与java中的重写不一样，c#中父类被重写的方法需加上virtual关键字，子类中被重写的方法需加上override关键字，如果不加上这两个关键字，那么意味着父类和子类各有自己的introduce方法，如果此时使用多态进行父类引用子类对象时，就不会出现编译看父类运行看子类，多态也就没有意义。</p>
<pre><code>public virtual void introduce() {

​      Console.WriteLine(&quot;我是父亲类&quot;);

​    }

 

public override void introduce() {

​      Console.WriteLine(&quot;我是儿子类&quot;);

​    }

 

Public override void introduce(){

​        Console.writeLine(“我是孙子类”);

}
</code></pre>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：（好处提高代码的复用性）例如</p>
<p>前提1，具有继承关系2，有方法重写3.有父类引用指向子类对象</p>
<p>​                对于成员变量，编译看父类，运行看父类</p>
<p>​                对于成员方法，编译看父类，运行看子类</p>
<p>​                对于静态方法，编译看父类，运行看父类</p>
<p>以上是父类和子类共有相同的方法，若子类中的方法父类没有，那么就需要进行向下转型或者向上转型：</p>
<p>向上转型，父类引用指向子类对象，</p>
<p>向下转型，使用括号进行父类转化为子类，注意，必须先完成向上转型才能接着完成向下转型。即Father father = new Son();   Son son = (Son)father。</p>
<h3 id="强转"><a href="#强转" class="headerlink" title="强转"></a>强转</h3><p>类型强转：如果都是数字型：int，float，double之间进行强转，可以直接使用(int)double进行强转，如果是不同类型之间进行强转，比如string和int之间需要使用int.parse(string)进行强转.</p>
<h3 id="判断字符串不能为空的方法："><a href="#判断字符串不能为空的方法：" class="headerlink" title="判断字符串不能为空的方法："></a>判断字符串不能为空的方法：</h3><p>​    方法一：使用string.isnullorempty()方法</p>
<p>​    方法二：使用textbox.text != “”;</p>
<p>​    注意：不能够使用textbox.text= null;去判断</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类abstract</p>
<p>中的抽象方法强制子类必须去重写该抽象方法。抽象类的作用：1.给其他类作父类2.作为多态实现父类引用子类对象。</p>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>interface，接口仍然使用:去实现，java中是implements是实现。若子类不想要完全去实现所有的接口中的功能，例如Run方法，就使用abstract public void Run();不去重写该方法，继续作为抽象方法即可</p>
<p>所有方法都为抽象方法的类作为接口</p>
<p>接口优点：可以实现多继承</p>
<p>接口中成员变量默认修饰符pubic static final     </p>
<p>接口中所有方法不需要都去实现的话，可以自己手写一个子接口，实现总接口中的部分方法，然后让子类去实现这个子接口。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>是定义在类里面，方法的外面，然后在方法里面使用    例如</p>
<pre><code>enum level{

​        low,

​        mid,

​        high,

​        super

​      };
</code></pre>
<p>权限：public：公用</p>
<p>​            protected</p>
<p>​            private ：私用,只允许类的内部方法互相调用。</p>
<p>​            无定义:</p>
<p>+无穷大:double.PositiveInfinity</p>
<p>-无穷大：double.negativeInfinity</p>
<h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><p>的使用方法：is用来判断该对象是否是某个类的对象，或者是某个类的子类的对象，返回的是一个bool型，而as原理与is相似，返回的是个对象或者null。as与强制类型转换的区别：强制类型转换，会将原有类型按照指定类型强制转移，若无法转换则报错。而as若无法转换则返回一个null。</p>
<pre><code>static void Main(string[] args)
        {
            teacher t = new teacher();
            bool flag = t is teacher;//判断是否是t是否是teacher的对象，true
            Console.WriteLine(flag);
            bool flag2 = t is Person;判断是否是person的对象，因为teacher是person的子类，所以结果为true
            Console.WriteLine(flag2);
    }
}
class Person {
    public void think() { 
        
    }
}

class teacher : Person {
    public void study() { 
        
    }
}
</code></pre>
<p>与java相似，c#创建对象的时候也有两种方式，第二种方式创建的对象只能使用一次，第一种方式创建的对象可以无限使用，其中中括号里面的内容表示对Form这个类中的属性进行更改。代码如下。</p>
<pre><code>static void Main(string[] args)

​    {

​      Form fm = new Form();

​      fm.Text = &quot;这是我的第一个程序&quot;;

​      fm.ShowDialog();

 

​      new Form() { Text = &quot;这是我的第二个程序&quot;}.ShowDialog();

​    }
</code></pre>
<h3 id="匿名对象："><a href="#匿名对象：" class="headerlink" title="匿名对象："></a>匿名对象：</h3><p>创建对象的另一种方式（java没有），该类没有名称，所以使用var作为接受类型，然后在{}中写入属性内容。（注意{}中不能添加方法只能添加属性）</p>
<p>var person = new { name = “张三”, age = 64 };</p>
<p>​      Console.WriteLine(person.name);</p>
<p>​      Console.WriteLine(person.age);</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>1)将string类型转换为int类型,使用Convert类中的toInt32()方法。</p>
<pre><code>string str1 = “10”;

​      string str2 = “20”;

​      int it1 = Convert.ToInt32(str1);

​      int it2 = Convert.ToInt32(str2);

​      Console.WriteLine(it1+it2);

​    2)显视类型转换，例如将Stone这个类转换为Monkey类，（这个在java中是没有办法实现的。）代码如下

static void Main(string[] args)

​    { 

​      Stone stone1 = new Stone();

​      stone1.age = 5000;

​      Monkey wukong = (Monkey)stone1;

​      Console.WriteLine(wukong.age);

​    }

  }

  class Stone {

​    public int age;

​        //注意是在被转换的代码下面写如下代码

​    public static explicit operator Monkey(Stone st){

​      Monkey m = new Monkey();

​      m.age = stone.age/500;//石头五百年相当于猴子一年

​      return m;

​    }

  }

  class Monkey {

​    public int age;

 }
</code></pre>
<h3 id="使用get-set-方法的意义："><a href="#使用get-set-方法的意义：" class="headerlink" title="使用get(),set()方法的意义："></a>使用get(),set()方法的意义：</h3><p>为了让用户在创建对象并且为属性赋值的时候进行合法赋值（例如年龄0&lt;age&lt;100），通常将属性值设置为private权限（不让用户在没有筛选的条件下使用属性）,然后提供 set，get方法进行赋值和取值，在set，get方法中进行合理值的过滤和筛选。代码如下（注意，这是java中的代码）</p>
<pre><code> static void Main(string[] args)

​    {

​      Student st1 = new Student();

​      st1.setAge(50);

​      Console.WriteLine(st1.getName()+st1.getAge());

 

​      Student st2 = new Student();

​      st2.setAge(100);

​      Console.WriteLine(st2.getName()+st2.getAge());

​    }

  }

  class Student {

​    private int age;

​    private string name;

 

​    public void setAge(int age) {

​      if (0 &lt; age &amp;&amp; age &lt; 100)

​      {

​        this.age = age;

​      }

​      else {

​        Console.WriteLine(&quot;请输入年龄在0-100之间&quot;);

​      }

​    }

​    public int getAge() {

​      return this.age;

​    }

 

​    public void setName(string name) {

​      this.name = name;

​    }

​    public string getName() {

​      return this.name;

​    }

  }

}
</code></pre>
<p>我们可以看到java中的代码在访问属性时比较麻烦，为了想要用st1.age这种与public访问属性方式，c#创造了另一种写法，但是逻辑思想与java是一样的，代码如下</p>
<p>（简便书写方法，快捷键，输入propfull按两下tab键，输入对应的参数即可）</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Student st = new Student();

​      st.Age = 20;                    //在这里可以直接使用这种方式访问（注意使用Age而不是age，相当于为age又起了一个变量名Age），下面的set代码块中限制了了用户年龄范围。

​      Console.WriteLine(st.Age);    

​    }

  }

  class Student {

​    private int age;                    //这个必须写，而且是private

​        public int Age {                    //这里与java不同，c#可以在创建属性的同时直接使用与get，set方法类似的代码块进行年龄范围设置，同时这里是public，相当于为age起了另一个变量名Age

​      set {

​        if (value &gt; 0 &amp;&amp; value &lt; 100)         &lt;font color = &#39;red&#39;&gt;//注意value此时写在get，set代码块中，value此时是个关键字（只在get，set方法中value是个关键词，在其他代码块中value不是 关键字，可以随便使用），因为此代码块中get和set不是方法所以无法传参，所以微软规定value就是这个形参，在上面st.Age = 20时，实际上value的值就等于20，若value写在string类型的代码块中，value就是个string类型的。&lt;/font&gt;

​        {

​          this.age = value;

​        }

​        else {

​          Console.WriteLine(&quot;年龄区间输入错误&quot;);

​        }

​      }

​      get {

​        return this.age;

​      }

​    }

  }

还有一种写法

Public int Age{get;set;}//这种写法是定义了一种变量Age，但是get和set中没有对Age进行限制，与public int age;
</code></pre>
<h3 id="ref关键字："><a href="#ref关键字：" class="headerlink" title="ref关键字："></a>ref关键字：</h3><p>类似于指针，如下method方法中形参为ref类型，实参y传入后，x与y指向同一个内存地址，所以x直接操作的是y对应的地址，所以最终输出结果为101，而不是100</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      int y = 100;

​      method(ref y);

​      Console.WriteLine(y);

​    }

​    static void method(ref int x ) {

​      x = x + 1;  

​    }

  }
</code></pre>
<h3 id="具名参数："><a href="#具名参数：" class="headerlink" title="具名参数："></a>具名参数：</h3><p>实际上就是传参的另一种使用方法，（c#独有，意义不大）在调用method方法时，实参使用name:”张三”，age:23这种方式的好处一是可读性比较强，二是传参时可以不必按照method的形参的类型顺序进行赋值，即method(age:23,name:”张三”)这种传参方式也可以。</p>
<pre><code>static void Main(string[] args)
{

  method2(name: &quot;张三&quot;,age:23);

}    

}

static void method2(String name, int age) {

  Console.WriteLine(name+age);

}
</code></pre>
<h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>数组的增删插入比较麻烦，查询,修改方便。集合查询修改比较麻烦，增删容易。如果数据的个数是固定的推荐使用数组，反之使用集合</p>
<p>当需要存储数据的时候,如果使用集合,在一个for循环查询数组中使用list.add()即可顺便保存到全局变量中，如果使用全部数组变量需要单独再创建一个for循环，将原数组中的每个数据保存到全局数组变量中。</p>
<pre><code>方法：ArrayList list = new ArrayList();

//    将数据添加到链表的结尾处

​    list.add(“abc”);

​    list.add(123);

//    删除某一个位置的数据

list.removeAt(0);

​    //    指定删除某一个数据

​        List.remove(“123”);

​    //    插入一个数据

​        List.insert(0,”helloword”);

​    //查询数据：

​    foreach(int i in list){

​    //查询即可
</code></pre>
<pre><code>Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary();

通过键值对完成增删改查

\1. 增：

a) 方式一：dic.add(1,”a”);

b) 方式二:dic[1] = “a”;

c) 方式三：Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary(){

{1,”a”},

{2,”b”}

};

\2. 查：

\1. 方式一：string str = dic[1];通过键获取值

\2. foreach(keyValuePair&lt;int&gt;&lt;string&gt; item in dic){//首先获取一个键值对数据

int key = item.key;//获取键

string value = item.value;//获取值                                   
}

3.删：bool a = dic.remove();
</code></pre>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托：  表示具有特定参数列表和返回类型的引用，好处：将方法作为参数传递出去，将方法封装成一个对象进行传递，可以完成对该方法的使用，避免重写该方法。委托是一种类</p>
<p>delegate（可以无返回值，可以指定返回值类型）， action和delegate的参数列表被定义到了16个，足够用户使用。</p>
<p>Action(无返回值的泛型)，Action&lt;int,string&gt;表示传入int，string无返回值的委托</p>
<p>Func（有返回值的泛型委托），Func&lt;string,int&gt;表示传入参数为string，返回值为int的委托</p>
<p>predicate（返回值是布尔类型的泛型委托）predicate<int>表示传入参数为int，返回bool的委托。</p>
<p>自定义委托：但是上面的四种委托已经足够了，自己通过代码体验就好，但是注意，自定义委托是一种类，需声明在其他类的外面，如果声明在其他类的里面，则属于嵌套类，则在使用时需要使用 当前所在类的类名.del1  cal1 = new  del1(c1.add);进行调用。委托的使用类似于以下代码，委托可以接收各种传递过来的方法变量，然后调用，而不使用委托就只能固定调用某个方法。</p>
<p>​            int i =6;<br>​            Console.WriteLine(i);//类似于委托<br>​            Console.WriteLine(6);//没有使用委托</p>
<p>代码如下</p>
<pre><code>namespace test5

{

  public delegate int del1(int x,int y);//自定义的委托，与下面的Action，Func具有同样的作用,自定义委托写在其他类的外面。其中被传递的函数的返回值为int，参数为两个int型于委托的返回值类型和参数列表必须一样。

  class Program

  {

​    static void Main(string[] args)

​    {

​      Calculator cl = new Calculator();

​      Action action = new Action(cl.Report);

​      cl.Report();//传统方法调用report方法

​      action.Invoke();//使用委托调用report方法

​      action();//使用委托调用另一种写法

 

​      Func&lt;int,int,int&gt; func1 = new Func&lt;int,int,int&gt;(cl.Add);//两个参数类型，一个返回类型

​      Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(cl.sub);

​      Console.WriteLine(func1(2,3));

​      Console.WriteLine(func2(5,5));

 

​      //使用自定义委托

​      del1 cal1 = new del1(cl.Add);

​      Console.WriteLine(cal1(5, 6)); 

​    }

  }

 

  class Calculator {

​    public void Report() {

​      Console.WriteLine(&quot;I have three methods&quot;);

​    }

​    public int Add(int a,int b) {

​      int result = a + b;

​      return result;

​    }

​    public int sub(int a, int b) {

​      int result = a - b;

​      return result;

​    }

  }

}
</code></pre>
<p>多播委托：一个委托内部封装着多个方法，顺序是按照添加的顺序执行，如果想要进行多线程争抢执行顺序，需使用BeginInvoke();  方法即action1.BeginInvoke();  action2.BeginInvoke(); action3.BeginInvoke();</p>
<p>代码如下</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Student st = new Student();

​      Teacher t = new Teacher();

​      Worker w = new Worker();

 

​      Action action1 = new Action(st.doHomeWork);

​      Action action2 = new Action(t.Teach);

​      Action action3 = new Action(w.work);

​      //多播委托

​      action1 += action2;//将action2添加到action1中

​      action1 += action3;//将action3添加到action1中

​      action1.Invoke();//执行顺序，按照添加顺序开始执行ation1，action2，action3

​    }

  }

  class Student {

​    public void doHomeWork() {

​      Console.WriteLine(&quot;我是学生&quot;);

​    }

  }

  class Teacher {

​    public void Teach() {

​      Console.WriteLine(&quot;我是老师&quot;);

​    }

  }

  class Worker {

​    public void work() {

​      Console.WriteLine(&quot;我是工人&quot;);

​    }

}
</code></pre>
<p>自定义委托</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件的五个成员：1.事件的拥有者（event source）        2.事件成员（event）        3.事件的响应者(event subcriber)            4.事件处理器(响应者中的处理方法)            5.事件订阅：事件 += 事件处理器（本质上是以委托为基础的约定）</p>
<p>写事件之前先把以上五个关于事件的东西写出来</p>
<p>事件拥有者和事件的响应者共有四种组合方式，推荐第四种</p>
<p>如下第一种组合方式和对应代码，</p>
<p><img src="csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214254615.png" alt="image-20210219214254615"></p>
<pre><code>
class Program
    {
        static void Main(string[] args)
        {
            Timer time = new Timer();//事件的拥有者，即小闪电符号的就是事件，小扳手是属性，小方块是方法
​           time.Interval = 1000;
            Boy boy = new Boy();//事件的响应者
            Girl girl = new Girl();
            time.Elapsed += boy.Action;//左边是事件，右侧是事件处理器（即Action方法），中间+=就是事件的订阅
            time.Elapsed += girl.Acton;
            time.Start();
            Console.ReadLine();
  }
}
class Boy {
    internal void Action(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine(&quot;jump&quot;);
    }
}
class Girl {

    internal void Acton(object sender, ElapsedEventArgs e)
    {
        Console.WriteLine(&quot;sing&quot;);
    }
}
</code></pre>
<p>第二种组合方式，事件的拥有者和事件的响应者是两个不同的对象。代码重新看视频</p>
<p><img src="csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214539229.png" alt="image-20210219214539229"></p>
<p>第三种组合方式，事件的拥有者和事件的响应者是同一个对象</p>
<p><img src="csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214620011.png" alt="image-20210219214620011"></p>
<p>第四种组合方式：事件的拥有者是事件响应者的字段成员</p>
<pre><code> class Program
    {
        static void Main(string[] args)
        {
            MyForm mf = new MyForm();
            mf.ShowDialog();
        }
    }
    class MyForm : Form {//myFrom 作为事件的响应者
        private Button button;//事件拥有者
        private TextBox tb;
        public MyForm()
        {
            button = new Button();
            tb = new TextBox();
            this.Controls.Add(button);
            this.Controls.Add(tb);
            this.button.Click += this.action;//事件+=事件处理=》事件订阅
            this.button.Text = &quot;say hello&quot;;
            this.button.Top = 50;
        }
        private void action(object sender, EventArgs e)
    {    
        this.tb.Text = &quot;helloWorld&quot;;
    }
}
</code></pre>
<p>针对事件订阅时，即左侧为事件，右侧为事件处理，整个过程为订阅，则订阅过程共有三种写法，如下</p>
<pre><code>public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            //this.button3.Click += this.button_Click;//这是第一种写法
            //第二种写法，使用了EventHandler进行了委托
            this.button3.Click += new EventHandler(this.button_Click);
            //第三种写法，lamdam表达式
            this.button3.Click += (sender, e) =&gt; { this.textBox1.Text = &quot;我是button3&quot;; };
        }

        private void button_Click(object sender, EventArgs e)
        {//一个事件处理器可以挂接多个不同的事件
            if (sender == button1) {
                this.textBox1.Text = &quot;我是button1&quot;;
                
            }
            if (sender == button2) {
                this.textBox1.Text = &quot;我是button2&quot;;
            }
            

        }
    }
</code></pre>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型：为什么用泛型？防止类膨胀和成员膨胀。</p>
<p>使用泛型的情况，类太多和成员变量太多或者不确定变量类型属于什么类型。方法泛型：当形参接受不同的数据类型，但是方法中对形参处理的逻辑一样就考虑使用方法泛型。只要写变量类型的时候就考虑用泛型 。</p>
<p>类膨胀如下，苹果对应一个盒子类和一个产品类，书对应一个盒子类一个产品类，那么1000中对应2000个类，这就是成员膨胀</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      AppleBox box = new AppleBox() { cargo = apple };

​      Console.WriteLine(box.cargo.color);

 

​      Book bk = new Book() { bookName = &quot;new book&quot; };

​      BookBox bb = new BookBox() { book = bk };

​      Console.WriteLine(bb.book.bookName);

​    }

  }

  class Apple {

​    public string  color { get; set; }

 

  }

  class AppleBox {

​    public Apple cargo { get; set; }

  }

  class Book {

​    public String bookName { get; set; }

  }

  class BookBox {

​    public Book book { get; set; }

  }
</code></pre>
<p>成员膨胀：如下，在创建box1对象时，只用到了Apple这个属性，创建box2这个对象时只用到了Book这个属性，如果1000中商品，在Box类中就有1000个类属性，创建一个对象时，其他属性就多余，这就属于成员膨胀</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      Book book = new Book(){ bookName = &quot;new book&quot;};

​      Box box1 = new Box() { cargo = apple };

​      Box box2 = new Box() { bk = book };

​      Console.WriteLine(box1.cargo.color);

​      Console.WriteLine(box2.bk.bookName);

​      

​    }

  }

  class Apple {

​    public string  color { get; set; }

 

  }

  class Box {

​    public Apple cargo { get; set; }

​    public Book bk { get; set; }

  }

  class Book {

​    public String bookName { get; set; }

  }
</code></pre>
<p>解决方法：使用泛型，如下，当Box后面使用<Tcargo>说明，当创建Box对象时&lt;&gt;里面是什么类型，那么该类型会自动替换Box类中的Tcargo作为一种类型，box1中的cargo类型就是Apple类型，box2中的cargo类型就是Book类型。</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      Apple apple = new Apple() { color = &quot;red&quot; };

​      Book book = new Book(){ bookName = &quot;new book&quot;};

​      Box&lt;Apple&gt; box1 = new Box&lt;Apple&gt;() { cargo = apple };

​      Box&lt;Book&gt; box2 = new Box&lt;Book&gt;() { cargo = book };

​      Console.WriteLine(box1.cargo.color);

​      Console.WriteLine(box2.cargo.bookName);

​    }

  }

  class Apple {

​    public string  color { get; set; }

  }

  class Box&lt;Tcargo&gt; {

​    public Tcargo cargo { get; set; }  

  }

  class Book {

​    public String bookName { get; set; }

  }
</code></pre>
<h3 id="Partial类"><a href="#Partial类" class="headerlink" title="Partial类"></a>Partial类</h3><h3 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h3><p>使用情况：在程序中只调用一次，可以使用lambda表达式，不用再创建类和方法进行调用，例如Func&lt;int,int,int&gt; func = new Func&lt;int,int,int&gt;({inta,int b}=&gt;{return a+b;});进行加法运算,简化后为Func&lt;int,int,int&gt; func = (a,b)=&gt;{return a+b;};</p>
<p>例子</p>
<pre><code>class Program

  {

​    static void Main(string[] args)

​    {

​      DoSomeCalc((a,b)=&gt;{return a*b;},100,200);

​    }

​    static void DoSomeCalc&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y) {

​      T res = func(x, y);

​      Console.WriteLine(res);

​    }

  }
</code></pre>
