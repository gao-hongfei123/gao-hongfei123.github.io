<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目</title>
      <link href="/2026/01/29/%E9%A1%B9%E7%9B%AE/"/>
      <url>/2026/01/29/%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="项目1：重命名文件系统"><a href="#项目1：重命名文件系统" class="headerlink" title="项目1：重命名文件系统"></a>项目1：重命名文件系统</h1><p>地址：F:\c#_code\RenameFileApplacation</p><p>Combox的下拉框选择后触发事件，使用comboBox2_SelectedValueChanged事件</p><ol><li><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>Directory.CreateDirectory(newPath);</p></li><li><h2 id="重命名核心算法："><a href="#重命名核心算法：" class="headerlink" title="重命名核心算法："></a>重命名核心算法：</h2><p>将文件移动到一个新的文件夹下并重新改名，删除原来的文件夹，然后再移动回来，</p></li></ol><p>File.Move(oldPath + oldName[Form1.flag], newPath + newName);</p><p>File.Move(newPath + newName, oldPath + newName);<span id="more"></span></p><ol start="3"><li><h2 id="获取文件夹下所有文件"><a href="#获取文件夹下所有文件" class="headerlink" title="获取文件夹下所有文件"></a>获取文件夹下所有文件</h2><p>DirectoryInfo di &#x3D; new DirectoryInfo(oldPath);</p><p>​                                           FileInfo[] fi &#x3D; di.GetFiles();</p></li></ol><h2 id="选择文件夹"><a href="#选择文件夹" class="headerlink" title="选择文件夹"></a>选择文件夹</h2><p>folderbrowerdialog，openfiledialog,savefiledialog实际上都是winform中的默认控件，常规操作都是创建对象之后在点击ok之后之后执行相应的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void getPath() &#123;</span><br><span class="line"></span><br><span class="line">​      FolderBrowserDialog fbd = new FolderBrowserDialog();</span><br><span class="line"></span><br><span class="line">​      fbd.SelectedPath = &quot;e:\\&quot;;//默认选择的路径</span><br><span class="line"></span><br><span class="line">​      if (fbd.ShowDialog() == DialogResult.OK)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        if (fbd.SelectedPath != &quot;&quot;)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          filePath.Text = fbd.SelectedPath.Trim();//前端的路径输入框</span><br><span class="line"></span><br><span class="line">​          path = fbd.SelectedPath.Trim();//将文件夹路径保存到一个静态变量中</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;文件路径错误&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="文件加载功能"><a href="#文件加载功能" class="headerlink" title="文件加载功能"></a>文件加载功能</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void filePath_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      getPath();</span><br><span class="line"></span><br><span class="line">​      //获取文件路径</span><br><span class="line"></span><br><span class="line">​      oldPath = Form1.path + &quot;\\&quot;;</span><br><span class="line"></span><br><span class="line">​      DirectoryInfo di = new DirectoryInfo(oldPath);</span><br><span class="line"></span><br><span class="line">​      FileInfo[] fi = di.GetFiles();//获取文件夹中的所有文件</span><br><span class="line"></span><br><span class="line">​      //将文件按照创建时间进行排序</span><br><span class="line"></span><br><span class="line">​      //string[] oldName = Directory.GetFiles(oldPath);</span><br><span class="line"></span><br><span class="line">​      Array.Sort(fi, delegate(FileInfo x, FileInfo y) &#123; return x.CreationTime.CompareTo(y.CreationTime); &#125;);</span><br><span class="line"></span><br><span class="line">​      oldName = new string[fi.Length];</span><br><span class="line"></span><br><span class="line">​      for (int i = 0; i &lt; fi.Length; i++)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        oldName[i] = fi[i].Name;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="实现按下enter键完成操作"><a href="#实现按下enter键完成操作" class="headerlink" title="实现按下enter键完成操作"></a>实现按下enter键完成操作</h2><p>判断键盘上按下的键是哪个键e.KeyCode &#x3D;&#x3D; Keys.Enter || e.KeyCode &#x3D;&#x3D; Keys.Tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void textBox1_KeyDown(object sender, KeyEventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​        id = 1;</span><br><span class="line"></span><br><span class="line">​        inputEnter(((TextBox)sender).Text, e, id);//当前控件对象时textbox类型</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;文件路径不能为空&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">public void inputEnter(string str, KeyEventArgs e,int id)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      if (e.KeyCode == Keys.Enter || e.KeyCode == Keys.Tab)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        int i = int.Parse(str);</span><br><span class="line"></span><br><span class="line">​        for (int j = 0; j &lt; i; j++)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          Form2 form2 = new Form2(this,j+1);</span><br><span class="line"></span><br><span class="line">​          form2.ShowDialog();</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="重命名代码"><a href="#重命名代码" class="headerlink" title="重命名代码"></a>重命名代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void renameFile(Form1 form1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //获取文件路径</span><br><span class="line"></span><br><span class="line">​      //获取大类，和份数</span><br><span class="line"></span><br><span class="line">​      int count = int.Parse(textBox1.Text);//获取页数</span><br><span class="line"></span><br><span class="line">​      String newPath;</span><br><span class="line"></span><br><span class="line">​      newPath = oldPath + &quot;a\\&quot;;</span><br><span class="line"></span><br><span class="line">​      Directory.CreateDirectory(newPath);//创建文件夹</span><br><span class="line"></span><br><span class="line">​      //处理第四类</span><br><span class="line"></span><br><span class="line">​      if (id == 4) &#123;</span><br><span class="line"></span><br><span class="line">​        string LittleClass = form1.comboBox1.Text;</span><br><span class="line"></span><br><span class="line">//不超过10页          </span><br><span class="line"></span><br><span class="line"> if (count &lt; 10) &#123;</span><br><span class="line"></span><br><span class="line">​            for (int j = 0; j &lt; count; j++)</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​              string newName = &quot;0&quot; + id + &quot;-&quot; + LittleClass + &quot;-&quot; + i + &quot;-&quot; + (j + 1) + &quot;.jpg&quot;;</span><br><span class="line"></span><br><span class="line">​              //3月9日处理不了</span><br><span class="line"></span><br><span class="line">​              File.Move(oldPath + oldName[Form1.flag], newPath + newName);</span><br><span class="line"></span><br><span class="line">​              File.Move(newPath + newName, oldPath + newName);</span><br><span class="line"></span><br><span class="line">​              Form1.flag++;</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            Directory.Delete(newPath);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h1 id="项目2-记事本"><a href="#项目2-记事本" class="headerlink" title="项目2:记事本"></a>项目2:记事本</h1><p>地址：F:\c#_code\notepad</p><p>需要引用的命名空间</p><p>using System.Drawing.Text;</p><p>using System.Collections;</p><p>using System.IO;</p><h2 id="添加工具栏"><a href="#添加工具栏" class="headerlink" title="添加工具栏"></a>添加工具栏</h2><p>toolscrip，设置成以下显示方式：</p><p>​1.在属性中将displayStyle设置成文字和图片</p><p>​2.imagescaling设置为none</p><p>​3.texeimagerelation显示方式设置为imageabovetext即可。</p><p><img src="/2026/01/29/%E9%A1%B9%E7%9B%AE/assets/wps30D8.tmp.jpg" alt="img"> </p><h2 id="将字体加载到combobox中"><a href="#将字体加载到combobox中" class="headerlink" title="将字体加载到combobox中"></a>将字体加载到combobox中</h2><p>&#x2F;&#x2F;调用字体库，一般是写到窗口加载的代码中</p><p>​      InstalledFontCollection ifc &#x3D; new InstalledFontCollection();</p><p>​      FontFamily[] ff &#x3D;  ifc.Families;&#x2F;&#x2F;字体数组</p><p>​      &#x2F;&#x2F;往combox中添加字体名字</p><p>​      for (int i &#x3D; 0; i &lt; ff.Length; i++) {</p><p>​        toolStripComboBox1.Items.Add(ff[i].Name);</p><p>​      }</p><h2 id="字体加粗-倾斜，倾斜将blod改为Italic即可"><a href="#字体加粗-倾斜，倾斜将blod改为Italic即可" class="headerlink" title="字体加粗&#x2F;倾斜，倾斜将blod改为Italic即可"></a>字体加粗&#x2F;倾斜，倾斜将blod改为Italic即可</h2><p>C#对字体进行设置时，使用label.Font &#x3D; new Font(“字体类型”,字体大小,是否加粗&#x2F;斜体&#x2F;、下划线&#x2F;删除线);因为在c#中，字体的属性是一个枚举类型，是只读的，不能对其直接进行设置，所以需要进行重新绘制。</p><p>错误写法：textBox1.Font.Bold &#x3D; true;</p><p>正确写法：textBox1.Font &#x3D; new Font(textBox1.Font,FontStyle.Bold);</p><p>&#x2F;&#x2F;加粗按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      if (textBox1.Font.Bold == false)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        textBox1.Font = new Font(textBox1.Font, FontStyle.Bold);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        //取消加粗</span><br><span class="line"></span><br><span class="line">​        //textBox1.Font.Bold = true;错误写法</span><br><span class="line"></span><br><span class="line">​        textBox1.Font = new Font(textBox1.Font,FontStyle.Regular);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">## 选择</span><br></pre></td></tr></table></figure><h2 id="字体同时进行字体更改"><a href="#字体同时进行字体更改" class="headerlink" title="字体同时进行字体更改"></a>字体同时进行字体更改</h2><p>&#x2F;&#x2F;字体类型改变</p><p>​    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  string fontName =  toolStripComboBox1.Text;//在combox中获取字体的名字</span><br><span class="line"></span><br><span class="line">​      float  fontSize = float.Parse(toolStripComboBox2.Text);//获取字体的大小</span><br><span class="line"></span><br><span class="line">​      textBox1.Font = new Font(fontName,fontSize);//字体更改</span><br><span class="line"></span><br><span class="line">字体大小改变combobox2中手动写入了10-22字号的大小，所以fontsize实际上就是字号大小</span><br></pre></td></tr></table></figure><h2 id="Savefiledialog和openfiledialog-新建，关闭，全部关闭"><a href="#Savefiledialog和openfiledialog-新建，关闭，全部关闭" class="headerlink" title="Savefiledialog和openfiledialog,新建，关闭，全部关闭"></a>Savefiledialog和openfiledialog,新建，关闭，全部关闭</h2><p>的区别如下，savefiledialog打开的保存窗口，而openfiledialog打开的是打开窗口，两者里面的一些属性或者方法有些是不同的，前者的filename是文件名是路径名加上手动写入的文件名，而后者的filename是点击的文件的文件名。(注意filenames属性是包含前面的文件路径名，而safafilename不包含路径名，只是文件名)</p><p>前者使用streamwriter，后者使用streamreader。</p><p><img src="file:///C:\Users\hasee\AppData\Local\Temp\ksohtml\wps8B08.tmp.jpg" alt="img"> <img src="/2026/01/29/%E9%A1%B9%E7%9B%AE/assets/wps8B18.tmp.jpg" alt="img"></p><p>​保存打开</p><p>&#x2F;&#x2F;进行保存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    if (textBox1.Text.Trim() != &quot;&quot;)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        SaveFileDialog sfd = new SaveFileDialog();//查看savefiledialog与openfiledialog与folderbrowserdialog的关系   </span><br><span class="line"></span><br><span class="line">​        sfd.Filter = (&quot;文本文档(*.txt)|*.txt&quot;);//为保存的文件设置保存格式为txt类型</span><br><span class="line"></span><br><span class="line">​        if (sfd.ShowDialog() == DialogResult.OK)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          string path = sfd.FileName;//获取需要保存的文件路径，以及手动输入的文件名</span><br><span class="line"></span><br><span class="line">​          StreamWriter sw = new StreamWriter(path, false);//false表示如果有和它一样的文件名不会进行追加，如果改为true则表示将文件追加到原来文件的后面</span><br><span class="line"></span><br><span class="line">​          sw.WriteLine(textBox1.Text.Trim());</span><br><span class="line"></span><br><span class="line">​          sw.Flush();</span><br><span class="line"></span><br><span class="line">​          sw.Close();</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure><p>打开文件代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">OpenFileDialog ofd = new OpenFileDialog();</span><br><span class="line"></span><br><span class="line">​      ofd.Filter = (&quot;文本文档(*.txt)|*.txt&quot;);//设置打开文档类型</span><br><span class="line"></span><br><span class="line">​      if (ofd.ShowDialog() == DialogResult.OK) &#123;</span><br><span class="line"></span><br><span class="line">​        string path = ofd.FileName;</span><br><span class="line"></span><br><span class="line">​        StreamReader sr = new StreamReader(path,Encoding.UTF8);</span><br><span class="line"></span><br><span class="line">​        textBox1.Text = sr.ReadToEnd();</span><br><span class="line"></span><br><span class="line">​        sr.Close();</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><p>新建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FrmChild fc = new FrmChild();</span><br><span class="line"></span><br><span class="line">​      fc.MdiParent = this;//应用到了多文档窗口</span><br><span class="line"></span><br><span class="line">​      fc.Show();</span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Form frm = this.ActiveMdiChild;//关闭当前激活状态的子窗体</span><br><span class="line"></span><br><span class="line">​      frm.Close();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">全部关闭</span><br><span class="line"></span><br><span class="line">​//使用foreach循环关闭</span><br><span class="line"></span><br><span class="line">​      foreach (Form item in this.MdiChildren)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        this.ActiveMdiChild.Close();</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><h2 id="多文档界面"><a href="#多文档界面" class="headerlink" title="多文档界面"></a>多文档界面</h2><p>与单文档界面不同，当应用程序执行时，单文档界面只能操作一个文档，每个窗口都是一个单独的程序，多文档界面可同时操作多个窗口，但是就一个程序，且子窗体都是显示在父窗体里面的，而单文档界面调用一个窗体时，该窗体是任意位置的。比如学生管理系统可以同时操作添加学生和成绩管理两个窗口。在任务栏中，多文档(mdi)只显示一个任务，而单文档显示多个任务。</p><p>操作方法：在父窗体中将ismdicontainer属性改为true，在创建子窗体的对象后，使用对象.mdiParent &#x3D; 父窗体对象即可。</p><h1 id="项目3：图书管理系统"><a href="#项目3：图书管理系统" class="headerlink" title="项目3：图书管理系统"></a>项目3：图书管理系统</h1><p>地址：F:\c#_code\BookManagerSystem</p><h2 id="1-技巧："><a href="#1-技巧：" class="headerlink" title="1.技巧："></a>1.技巧：</h2><p>​如果想要将从前端获取的数据临时进行存取，例如：用户名，id，可以添加一个静态类。</p><p>这样当后台需要使用使用该数据的时候，就可以直接将其提取出来。（不需要重新建立一个数据表进行增删改的操作了）。但是如果需要永久保存数据的话并且作为中介，则还是需要数据表的，例如借出的图书，归还的图书。</p><p>从数据库查询到结果后，使用c#从后台获取到的方法，在（3用户登陆）中。通过数组获取。第一种是使用索引，第二种是直接使用字段获取。第二种更好</p><p>保证多个radiobutton只能选择一个，在（3用户登陆）中</p><p>后端数据库中的数据显示在前端页面的方法（5）中</p><p>可将修改和添加写在一个窗体中，然后如果是添加则自动显示添加按钮，如果是修改则显示修改按钮，两个按钮进行覆盖。</p><p>了解DialogResult dr &#x3D; MessageBox.Show(“是否要删除该图书”, “”,</p><p>MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);中每个参数的含义，返回结果</p><p>与dialogresult中的枚举值进行对比。</p><p>​如何获取表格中选中行的数据并且进行操作，在（7中）</p><p>​判断增删改执行成功，判断语句是影响的行数是否大于0即可，查询判断语句是bool型</p><p>​Form2如果想要使用form1中的方法，那么应该需要将Form1作为一个对象传递到Form2中，如果想要使用Form1中的一些属性，实际上Form1的属性可以将private改为public即可。</p><p>​修改图书:方法1：执行一次删除，在执行一次添加，方法2.执行update语句。（参考8）</p><p>​多行删除操作：11</p><h2 id="2-连接数据库的源码"><a href="#2-连接数据库的源码" class="headerlink" title="2.连接数据库的源码"></a>2.连接数据库的源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Dao</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    /*连接数据库的三个步骤</span><br><span class="line"></span><br><span class="line">​     \* 1.获取数据源</span><br><span class="line"></span><br><span class="line">​     \* 2.加载数据源和sql命令</span><br><span class="line"></span><br><span class="line">​     \* 3.开始执行</span><br><span class="line"></span><br><span class="line">​ *4.关闭数据库</span><br><span class="line"></span><br><span class="line">​     */</span><br><span class="line"></span><br><span class="line">​    SqlConnection sc;</span><br><span class="line"></span><br><span class="line">​    public SqlConnection connection() &#123;</span><br><span class="line"></span><br><span class="line">​    string path = &quot;Data Source=(localdb)\\Projects;Initial Catalog=BookMS;Integrated Security=True&quot;;</span><br><span class="line"></span><br><span class="line">​      sc = new SqlConnection(path);</span><br><span class="line"></span><br><span class="line">​      sc.Open();</span><br><span class="line"></span><br><span class="line">​      return sc;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public SqlCommand command(string sql) &#123;</span><br><span class="line"></span><br><span class="line">​      SqlCommand sc = new SqlCommand(sql,connection());</span><br><span class="line"></span><br><span class="line">​      return sc;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    public int execute(string sql) &#123;</span><br><span class="line"></span><br><span class="line">​      return command(sql).ExecuteNonQuery();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public SqlDataReader read(string sql) &#123;</span><br><span class="line"></span><br><span class="line">​      return command(sql).ExecuteReader();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public void dbClose() &#123;</span><br><span class="line"></span><br><span class="line">​      sc.Close();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-用户登陆"><a href="#3-用户登陆" class="headerlink" title="3. 用户登陆"></a>3. 用户登陆</h2><p>​      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">if (radioButton1.Checked == true) &#123;//radio选择的是用户</span><br><span class="line"></span><br><span class="line">​       radioButton2.Checked = false;//将管理员设置为false，以保证唯一性</span><br><span class="line"></span><br><span class="line">​        string sql = &quot;select * from t_user where id = &#x27;&quot;+textBox1.Text+&quot;&#x27; and psw = &#x27;&quot;+textBox2.Text+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​        Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​        SqlDataReader sr = dao.read(sql);//查询语句用read方法。并且返回值为bool型。</span><br><span class="line"></span><br><span class="line">​        if (sr.Read())//因为只需要查询固定的某个人，所以只需要执行一次即可，否则需要使用while循环，sr.Read()方法会自动指向下一个指针。</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          //将用户的id和姓名保存在静态类里面，以便后面使用。</span><br><span class="line"></span><br><span class="line">​          User.Uid = sr[&quot;id&quot;].ToString();</span><br><span class="line"></span><br><span class="line">​          User.Uname = sr[&quot;name&quot;].ToString();</span><br><span class="line"></span><br><span class="line">​          UserMain um = new UserMain();</span><br><span class="line"></span><br><span class="line">​          this.Hide();</span><br><span class="line"></span><br><span class="line">​          um.ShowDialog();</span><br><span class="line"></span><br><span class="line">​          this.Show();</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;用户名或者密码错误&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        sr.Close();</span><br></pre></td></tr></table></figure><h2 id="4-管理员登陆"><a href="#4-管理员登陆" class="headerlink" title="4. 管理员登陆"></a>4. 管理员登陆</h2><p>同用户登陆一样。</p><h2 id="5-将数据库中的数据显示到前端表格中"><a href="#5-将数据库中的数据显示到前端表格中" class="headerlink" title="5. 将数据库中的数据显示到前端表格中"></a>5. 将数据库中的数据显示到前端表格中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void showTable()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      dataGridView1.Rows.Clear();//清除原有数据</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;select * from t_book&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​      IDataReader ir = dao.read(sql);</span><br><span class="line"></span><br><span class="line">​      while (ir.Read())</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        //记住往表格中添加数据的方法</span><br><span class="line"></span><br><span class="line">​        dataGridView1.Rows.Add(ir[0].ToString(), ir[1].ToString(), ir[2].ToString(), ir[3].ToString(), ir[4].ToString());</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      ir.Close();</span><br><span class="line"></span><br><span class="line">​      dao.dbClose();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-添加图书"><a href="#6-添加图书" class="headerlink" title="6. 添加图书"></a>6. 添加图书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)//点击提交时间的时候执行</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      if (textBox1.Text != &quot;&quot; &amp;&amp; textBox2.Text != &quot;&quot; &amp;&amp; textBox3.Text != &quot;&quot; &amp;&amp; textBox4.Text != &quot;&quot; &amp;&amp; textBox5.Text != &quot;&quot;)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​        string sql = &quot;insert into t_book values (&#x27;&quot; + textBox1.Text + &quot;&#x27;,&#x27;&quot; + textBox2.Text + &quot;&#x27;,&#x27;&quot; + textBox3.Text + &quot;&#x27;,&#x27;&quot; + textBox4.Text + &quot;&#x27;,&#x27;&quot; + textBox5.Text + &quot;&#x27;);&quot;;</span><br><span class="line"></span><br><span class="line">​        if (dao.execute(sql) &gt; 0)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;添加成功&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;添加失败&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        textBox1.Text = null;</span><br><span class="line"></span><br><span class="line">​        textBox2.Text = null;</span><br><span class="line"></span><br><span class="line">​        textBox3.Text = null;</span><br><span class="line"></span><br><span class="line">​        textBox4.Text = null;</span><br><span class="line"></span><br><span class="line">​        textBox5.Text = null;</span><br><span class="line"></span><br><span class="line">​        book.showTable();</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;不能有空项&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="7-删除图书"><a href="#7-删除图书" class="headerlink" title="7. 删除图书"></a>7. 删除图书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private void button3_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //删除图书</span><br><span class="line"></span><br><span class="line">​      DialogResult dr = MessageBox.Show(&quot;是否要删除该图书&quot;, &quot;&quot;, MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);</span><br><span class="line"></span><br><span class="line">​      if (dr == DialogResult.Yes)//判断返回结果</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        //注意获取选中行的字段技巧。注意，selectRows中的索引值默认代表的是多选情况下（multiselect），对应的所选的行的集合中的某一行。</span><br><span class="line"></span><br><span class="line">​        //如果multiselect属性改为false（即只能选择一行），那么index只能为0。cells同理</span><br><span class="line"></span><br><span class="line">​        string id = dataGridView1.SelectedRows[0].Cells[0].Value.ToString();</span><br><span class="line"></span><br><span class="line">​        string sql = &quot;delete from t_book where id = &#x27;&quot; + id + &quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​        Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​        if (dao.execute(sql) &gt; 0)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;删除成功&quot;);</span><br><span class="line"></span><br><span class="line">​          showTable();</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;删除失败&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        dao.dbClose();</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="8-修改图书"><a href="#8-修改图书" class="headerlink" title="8.修改图书"></a>8.修改图书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void button3_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //修改图书</span><br><span class="line"></span><br><span class="line">​      string id, name, press, num, author;</span><br><span class="line"></span><br><span class="line">​      id = textBox1.Text;</span><br><span class="line"></span><br><span class="line">​      name = textBox2.Text;</span><br><span class="line"></span><br><span class="line">​      press = textBox3.Text;</span><br><span class="line"></span><br><span class="line">​      num = textBox4.Text;</span><br><span class="line"></span><br><span class="line">​      author = textBox5.Text;</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;update t_book set id = &#x27;&quot;+textBox1.Text+&quot;&#x27;,name=&#x27;&quot;+textBox2.Text+&quot;&#x27;,press=&#x27;&quot;+textBox3.Text+&quot;&#x27;,num=&#x27;&quot;+textBox4.Text+&quot;&#x27;,author=&#x27;&quot;+textBox5.Text+&quot;&#x27; where id=&#x27;&quot;+str[0]+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​      if (dao.execute(sql) &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;修改成功&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      book.showTable();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="9-归还图书"><a href="#9-归还图书" class="headerlink" title="9. 归还图书"></a>9. 归还图书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public void showTable()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      dataGridView1.Rows.Clear();</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;select [no],[bid],[datetime] from t_lend where uid = &#x27;&quot;+User.Uid+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​      IDataReader ir = dao.read(sql);</span><br><span class="line"></span><br><span class="line">​      while (ir.Read())</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        //记住往表格中添加数据的方法</span><br><span class="line"></span><br><span class="line">​        dataGridView1.Rows.Add(ir[0].ToString(), ir[1].ToString(), ir[2].ToString());</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      ir.Close();</span><br><span class="line"></span><br><span class="line">​      dao.dbClose();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    private void button1_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //归还图书</span><br><span class="line"></span><br><span class="line">​      int no = int.Parse(dataGridView1.SelectedRows[0].Cells[0].Value.ToString());</span><br><span class="line"></span><br><span class="line">​      string id = dataGridView1.SelectedRows[0].Cells[1].Value.ToString();</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;delete from t_lend where no=&#x27;&quot;+no+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​      string sql2 = &quot;update t_book set num = (num+1) where Id = &#x27;&quot;+id+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​      if (dao.execute(sql) &gt; 0 &amp;&amp; dao.execute(sql2) &gt; 0)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;归还成功&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;归还失败&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      showTable();</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="10-借出图书"><a href="#10-借出图书" class="headerlink" title="10. 借出图书"></a>10. 借出图书</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public void showTable()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      dataGridView1.Rows.Clear();</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;select * from t_book&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​      IDataReader ir = dao.read(sql);</span><br><span class="line"></span><br><span class="line">​      while (ir.Read())</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        //记住往表格中添加数据的方法</span><br><span class="line"></span><br><span class="line">​        dataGridView1.Rows.Add(ir[0].ToString(), ir[1].ToString(), ir[2].ToString(), ir[3].ToString(), ir[4].ToString());</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      ir.Close();</span><br><span class="line"></span><br><span class="line">​      dao.dbClose();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    private void button1_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //执行借出图书操作</span><br><span class="line"></span><br><span class="line">​      string  id = dataGridView1.SelectedRows[0].Cells[0].Value.ToString();</span><br><span class="line"></span><br><span class="line">​      int num = int.Parse(dataGridView1.SelectedRows[0].Cells[3].Value.ToString());//获取书的库存</span><br><span class="line"></span><br><span class="line">​      if(num &lt; 1)&#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;库存不足，请联系管理员购入&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;else &#123;</span><br><span class="line"></span><br><span class="line">​        string sql = &quot;update  t_book set num=&#x27;&quot; + (num - 1) + &quot;&#x27;where id = &#x27;&quot;+id+&quot;&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">​        string sql2 = &quot;insert into t_lend ([uid],[bid],[datetime]) values(&#x27;&quot;+User.Uid+&quot;&#x27;,&#x27;&quot; + id + &quot;&#x27;,GETDATE());&quot;;</span><br><span class="line"></span><br><span class="line">​        Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line">​        if (dao.execute(sql) &gt; 0 &amp;&amp; dao.execute(sql2)&gt;0)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;借出成功&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          MessageBox.Show(&quot;借出失败&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        showTable();</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><h2 id="11-选中多行进行删除"><a href="#11-选中多行进行删除" class="headerlink" title="11. 选中多行进行删除"></a>11. 选中多行进行删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private void button7_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //多行删除功能的实现</span><br><span class="line"></span><br><span class="line">​      int n = dataGridView1.SelectedRows.Count;//选中行的数目</span><br><span class="line"></span><br><span class="line">​      //delete from t_book where id in(201906,20190108);</span><br><span class="line"></span><br><span class="line">​      string sql = &quot;delete from t_book where id in(&quot;;</span><br><span class="line"></span><br><span class="line">​      for(int i=0;i &lt; n ;i++)&#123;</span><br><span class="line"></span><br><span class="line">​        sql += &quot;&#x27;&quot; + dataGridView1.Rows[i].Cells[0].Value.ToString()+&quot;&#x27;,&quot;;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      sql =sql.Remove(sql.Length-2);//删除最后一个逗号</span><br><span class="line"></span><br><span class="line">​      sql += &quot;&#x27;)&quot;;</span><br><span class="line"></span><br><span class="line">​      Dao dao = new Dao();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      if (dao.execute(sql) &gt; (n - 1))</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;删除成功&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        MessageBox.Show(&quot;删除失败&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      showTable();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h1 id="项目四：音乐播放器"><a href="#项目四：音乐播放器" class="headerlink" title="项目四：音乐播放器"></a>项目四：音乐播放器</h1><p>地址：F:\c#_code\MusicPlayer</p><p>每次设计winform窗体的时候，拉伸窗体的时候导致窗体与初始的窗体设置不一样。</p><p>解决方法：1.划分区域，使用工具箱中的容器里面的划分区域的工具。Split，table，tab等</p><pre><code>2．将winform的AutoSizeMode改为GrowAndShrink</code></pre><p>去掉文件的后缀名，引用IO，使用Path.getFileNameWithoutExtention(文件名)</p><p>去掉路径名，使用safefileNames，不是filenames</p><p> 拖动游标使用的trackbar控件中mouseup和mousedown事件</p><h2 id="音乐播放核心"><a href="#音乐播放核心" class="headerlink" title="音乐播放核心"></a>音乐播放核心</h2><ol><li><p>引用window media player的库</p></li><li><p>Using  wmplib</p></li><li><p>需要手动添加一个三方的控件，在工具箱中右键添加一个选项卡命名为WMP，右键该选项卡选择项，在com中找到windows media player添加到工具箱中，然后将该控件拖到页面上，visable设为false（我们不是通过点击该控件进行播放，而是点击歌曲名字进行播放），在listBox1_SelectedIndexChanged事件中对axWindowsMediaPlayer1.url进行赋值即可进行播放。</p></li><li><p>4.listbox中的激活元素赋值方式必须得使用第三方变量进行赋值。（坑）</p></li></ol><p>axWindowsMediaPlayer控件的属性</p><p>​从头开始播放：axWindowsMediaPlayer1.URL</p><p>​播放停止：axWindowsMediaPlayer1.Ctlcontrols.stop()；</p><p>​播放暂停：axWindowsMediaPlayer1.Ctlcontrols.pause();</p><p>​暂停的位置开始播放：axWindowsMediaPlayer1.Ctlcontrols.play();</p><p>当前播放媒体的时间长度：double max &#x3D; axWindowsMediaPlayer1.currentMedia.duration;</p><p>当前播放媒体的位置：      double cuPostion &#x3D; axWindowsMediaPlayer1.Ctlcontrols.currentPosition;</p><h2 id="下一曲"><a href="#下一曲" class="headerlink" title="下一曲"></a>下一曲</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void button6_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //下一曲</span><br><span class="line">            int i = listBox1.SelectedIndex + 1;</span><br><span class="line">            if (i &lt; listBox1.Items.Count)</span><br><span class="line">            &#123;</span><br><span class="line">                listBox1.SelectedIndex = i;//将高亮显示向下移动一行</span><br><span class="line">                axWindowsMediaPlayer1.URL = list[i];//播放下一曲</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                axWindowsMediaPlayer1.URL = list[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="上一曲"><a href="#上一曲" class="headerlink" title="上一曲"></a>上一曲</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> private void button5_Click(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //上一曲</span><br><span class="line"></span><br><span class="line">​        int i = listBox1.SelectedIndex - 1;</span><br><span class="line">​        if (i &gt;= 0)</span><br><span class="line">​        &#123;</span><br><span class="line">​            listBox1.SelectedIndex = i;//将高亮显示向上移动一行</span><br><span class="line">​            axWindowsMediaPlayer1.URL = list[i];//播放上一曲</span><br><span class="line">​        &#125;</span><br><span class="line">​        else</span><br><span class="line">​        &#123;</span><br><span class="line">​            axWindowsMediaPlayer1.URL = list[0];</span><br><span class="line">​        &#125;</span><br><span class="line">​        label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line"></span><br><span class="line">​        //if (listBox1.SelectedIndex &gt;= 0)</span><br><span class="line">​        //&#123;</span><br><span class="line">​        //    /*注意下面这行代码本身就是个错误代码，索引值要求大于等于0,</span><br><span class="line">​        //     * -1表示当前没有元素被选中，那么后面就没有办法播放索引值为-1的歌曲</span><br><span class="line">​        //     * 如果将其写在if语句外面也是错误的，因为本身索引值就不能为-1</span><br><span class="line">​        //     */</span><br><span class="line">​        //    listBox1.SelectedIndex = listBox1.SelectedIndex - 1;//这句代码本身就是个错误</span><br><span class="line">​        //    axWindowsMediaPlayer1.URL = list[listBox1.SelectedIndex];</span><br><span class="line">​        //&#125;</span><br><span class="line">​        //else</span><br><span class="line">​        //&#123;</span><br><span class="line">​        //    MessageBox.Show(&quot;索引错误&quot;);</span><br><span class="line">​        //&#125;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    private void button4_Click(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //停止</span><br><span class="line">​        axWindowsMediaPlayer1.Ctlcontrols.stop();</span><br><span class="line">​        timer1.Enabled = false;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void button3_Click(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //暂停</span><br><span class="line">​        axWindowsMediaPlayer1.Ctlcontrols.pause();</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> private void button2_Click(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //播放</span><br><span class="line">​        //注意：如果没有元素被选中的情况下，listbox.selctIndex是等于-1的</span><br><span class="line">​        if (listBox1.SelectedIndex &gt;=0)</span><br><span class="line">​        &#123;//有选中的情况下，从暂停的部分开始播放</span><br><span class="line">​            axWindowsMediaPlayer1.Ctlcontrols.play();</span><br><span class="line">​            label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line">​        &#125;</span><br><span class="line">​        else &#123; </span><br><span class="line">​        //没有元素激活的情况下，从第一个开始播放</span><br><span class="line">​            axWindowsMediaPlayer1.URL = list[0];</span><br><span class="line">​            label1.Text = list[0].ToString();</span><br><span class="line">​        &#125;</span><br><span class="line">​        //代码优化</span><br><span class="line">​        /*可以代替上面的代码</span><br><span class="line">​           int index = listBox1.SelectedIndex;</span><br><span class="line">​           index = index &lt; 0 ? 0 : index;</span><br><span class="line">​           axWindowsMediaPlayer1.URL = list[index];</span><br><span class="line">​           label1.Text = list[index];</span><br><span class="line">​         */</span><br><span class="line">​        timer1.Enabled = true;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="添加歌曲"><a href="#添加歌曲" class="headerlink" title="添加歌曲"></a>添加歌曲</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //添加歌曲</span><br><span class="line">​        OpenFileDialog ofd = new OpenFileDialog();</span><br><span class="line">​        ofd.Filter = (&quot;文件格式(*.mp3)|*.mp3&quot;);//前面表示文件格式提示，后面是文件格式的限制条件</span><br><span class="line">​        ofd.Multiselect = true;//设置成可以多选</span><br><span class="line">​        if (ofd.ShowDialog() == DialogResult.OK) &#123; </span><br><span class="line">​            //读取文件名</span><br><span class="line">​            string[] fileName = ofd.FileNames;//safefilenames与filenames的区别是前者不包含前面的路径名</span><br><span class="line">​            foreach (string item in fileName)</span><br><span class="line">​            &#123;</span><br><span class="line">​                string name = Path.GetFileNameWithoutExtension(item);//去掉文件的后缀名</span><br><span class="line">​                listBox1.Items.Add(name);//往listbox中添加歌曲名称</span><br><span class="line">​                list.Add(item);//保存到集合里面方便后面的方法使用</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="点击歌名播放"><a href="#点击歌名播放" class="headerlink" title="点击歌名播放"></a>点击歌名播放</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   private void listBox1_SelectedIndexChanged(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //播放当前选中的歌曲</span><br><span class="line">​        axWindowsMediaPlayer1.URL = list[listBox1.SelectedIndex];</span><br><span class="line">​        label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line">​        timer1.Enabled = true;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="时间控制器（控制trackbar的游标，歌曲播放完毕自动切换）"><a href="#时间控制器（控制trackbar的游标，歌曲播放完毕自动切换）" class="headerlink" title="时间控制器（控制trackbar的游标，歌曲播放完毕自动切换）"></a>时间控制器（控制trackbar的游标，歌曲播放完毕自动切换）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> private void timer1_Tick(object sender, EventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //获取歌曲的长度</span><br><span class="line">​        double max = axWindowsMediaPlayer1.currentMedia.duration;</span><br><span class="line">​        //获取当前歌曲的播放位置</span><br><span class="line">​        double cuPostion = axWindowsMediaPlayer1.Ctlcontrols.currentPosition;</span><br><span class="line">​        trackBar1.Maximum = (int)max;</span><br><span class="line">​        trackBar1.Value = (int)cuPostion;</span><br><span class="line"></span><br><span class="line">​        //当前歌曲播放完成后，自动切换到下一首</span><br><span class="line">​        if (axWindowsMediaPlayer1.playState == WMPPlayState.wmppsStopped) &#123;//当前歌曲的播放位置结束的判断方式</span><br><span class="line">​            </span><br><span class="line">​            int i = listBox1.SelectedIndex;</span><br><span class="line">​            if (i == listBox1.Items.Count - 1)//列表中的最后一首歌播放完成后，从头开始播放</span><br><span class="line">​            &#123;</span><br><span class="line">​                listBox1.SelectedIndex = 0;//将高亮显示向下移动一行</span><br><span class="line">​                axWindowsMediaPlayer1.URL = list[0];//播放第一首</span><br><span class="line">​                listBox1.SelectedIndex = 0;</span><br><span class="line">​                label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line">​                trackBar1.Value = 0;</span><br><span class="line">​                timer1.Enabled = true;</span><br><span class="line">​            &#125;</span><br><span class="line">​            else &#123;</span><br><span class="line">​                axWindowsMediaPlayer1.URL = list[i + 1];</span><br><span class="line">​                listBox1.SelectedIndex = (i + 1);</span><br><span class="line">​                label1.Text = listBox1.SelectedItem.ToString();</span><br><span class="line">​                trackBar1.Value = 0;</span><br><span class="line">​                timer1.Enabled = true;</span><br><span class="line">​            &#125;</span><br><span class="line">​            </span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="游标拖动实现歌曲快进退"><a href="#游标拖动实现歌曲快进退" class="headerlink" title="游标拖动实现歌曲快进退"></a>游标拖动实现歌曲快进退</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  //使用valuechanged事件还是mouseup和mousedown事件，注意值改变不仅包含手动拖动游标，还包含播放时自己移动，所以不使用valuechanged事件</span><br><span class="line"></span><br><span class="line">​    private void trackBar1_MouseDown(object sender, MouseEventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //鼠标按下的时候开始进行拖动</span><br><span class="line">​        axWindowsMediaPlayer1.Ctlcontrols.pause();</span><br><span class="line">​        timer1.Enabled = false;</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    private void trackBar1_MouseUp(object sender, MouseEventArgs e)</span><br><span class="line">​    &#123;</span><br><span class="line">​        //鼠标松开的时候开始播放</span><br><span class="line">​        axWindowsMediaPlayer1.Ctlcontrols.currentPosition = trackBar1.Value;</span><br><span class="line">​        axWindowsMediaPlayer1.Ctlcontrols.play();</span><br><span class="line">​        timer1.Enabled = true;</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目5：幸运抽奖系统"><a href="#项目5：幸运抽奖系统" class="headerlink" title="项目5：幸运抽奖系统"></a>项目5：幸运抽奖系统</h1><p>代码：F:\c#_code\LuckDraw</p><h2 id="读取文件的操作流程"><a href="#读取文件的操作流程" class="headerlink" title="读取文件的操作流程"></a>读取文件的操作流程</h2><ol><li><p>封装文件路径filestream</p></li><li><p>创建读取文件流对象。Streamreader&#x2F;streamwriter</p></li><li><p>操作文件。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void fileRead(string path,ListBox listbox) &#123;</span><br><span class="line"></span><br><span class="line">​      //封装文件路径</span><br><span class="line"></span><br><span class="line">​      FileStream fs = new FileStream(path, FileMode.OpenOrCreate);//第一个参数表示路径，第二个参数表示对文件的操作形式是打开类型</span><br><span class="line"></span><br><span class="line">​      //进行读取操作</span><br><span class="line"></span><br><span class="line">​      StreamReader sr = new StreamReader(fs, Encoding.UTF8);</span><br><span class="line"></span><br><span class="line">​      while (true)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        string name = sr.ReadLine();</span><br><span class="line"></span><br><span class="line">​        if (name != null)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          listbox.Items.Add(name);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      fs.Close();</span><br><span class="line"></span><br><span class="line">​      sr.Close();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void fileWrite(string path, ListBox listbox)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //封装文件路径</span><br><span class="line"></span><br><span class="line">​      FileStream fs = new FileStream(path, FileMode.Create);//注意，这里面与读取的方法不同，是重新创建一个eat文件，如果是openorcreate就是在原有文件上追加</span><br><span class="line"></span><br><span class="line">​      //进行读取操作</span><br><span class="line"></span><br><span class="line">​      StreamWriter sr = new StreamWriter(fs, Encoding.UTF8);</span><br><span class="line"></span><br><span class="line">​      foreach (var item in listBox2.Items)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        sr.WriteLine(item.ToString());</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      sr.Close();</span><br><span class="line"></span><br><span class="line">​      fs.Close();</span><br></pre></td></tr></table></figure><p>​      </p><p>​    }</p><h2 id="语音播报指定的内容。"><a href="#语音播报指定的内容。" class="headerlink" title="语音播报指定的内容。"></a>语音播报指定的内容。</h2><p>在项目中添加引用-&gt;框架-》system.speech</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Speech.Synthesis;</span><br><span class="line"></span><br><span class="line">写一个方法专门用来播报</span><br><span class="line"></span><br><span class="line">public void broad(string content) &#123;</span><br><span class="line"></span><br><span class="line">​      SpeechSynthesizer ss = new SpeechSynthesizer();</span><br><span class="line"></span><br><span class="line">​      PromptBuilder pb = new PromptBuilder();//下面的speak方法中需要使用</span><br><span class="line"></span><br><span class="line">​      pb.AppendText(content);//播报指定文本</span><br><span class="line"></span><br><span class="line">​      ss.Speak(pb);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h1 id="项目6：影院管理系统（未完成）"><a href="#项目6：影院管理系统（未完成）" class="headerlink" title="项目6：影院管理系统（未完成）"></a>项目6：影院管理系统（未完成）</h1><p>有数据库访问的话就可以用三层架构。</p><p>注意：sqlserver乱码，使用三个代码修改后重新创建表，新建的表才不会出现乱码，而之前创建的表仍然乱码</p><p>三层架构：</p><p>​显示层（view）：实际上winform窗口就是一个view层显示作用和逻辑处理。而在同一个解决方案中创建其他的类项目（不是winform项目），就是实现三层架构</p><p>​业务逻辑层（BLL）：使用dal层的对象调用dal中的方法。没什么作用就是为了好看，在调用方法的时候不想dal层一样需要传参，方法的返回结果仍然是一个集合。 </p><p>​数据访问层（DAL）。就是将model层返回的所有结果集合通过dal层中的方法返回一个list集合，返回给BLL层。</p><p>辅助层：</p><p>​模型层（model）：必需的，与数据库中的数据进行匹配。即将数据库中的各个字段作为模型类中的属性</p><p>​公共层（common）：必需的，用来存放不同项目之间可以通用的公共代码</p><p>​控件层：将控件组合形成自定义控件，以方便直接拿来用。</p><p>各层关系：View-&gt;BLL-&gt;DAL</p><p>实现各层之间可以相互调用操作：View添加引用BLL，Model，Common层</p><p>BLL添加引用DAL，Model，Common层</p><p>​DAL添加引用Model，Common层</p><p>整个流程是从底层开始写，即model&#x2F;common-》dal-》bll-》view，但是调用过程是反过来的。</p><p>1.将view层绘制完成之后</p><p>2.使用c#代码生成器将model层的代码自动生成，并且按照各层关系相互引用。</p><p>3.引用DBHelper，将其放进common（公共）层。需要修改地方：手动写入命名空间：即当前的文件夹名。修改constr变量改为自己的数据库</p><p>4.当使用查询的使用，在数据访问层（dal层）创建一个查询的方法，返回类型是一个list类型，泛型类型是需要查询的表对应的model类型。每一个表对应dal层中的一个类。每一个表对应一个model层中的一个类。每一个dal层类对应一个BLL层类。</p><h1 id="项目7：C-sharp-实现excel操作-b站糖君哒（npoi）"><a href="#项目7：C-sharp-实现excel操作-b站糖君哒（npoi）" class="headerlink" title="项目7：C sharp 实现excel操作(b站糖君哒（npoi）)"></a>项目7：C sharp 实现excel操作(b站糖君哒（npoi）)</h1><p>理论知识：工作簿（workbook）</p><p>​       工作表（sheet）即一个excel文件里面有多个工作表sheet1，sheet2……</p><p>​   行（row）</p><p>​   列&#x2F;单元格（cell） </p><h3 id="1-读取excel中的数据"><a href="#1-读取excel中的数据" class="headerlink" title="1.读取excel中的数据"></a>1.读取excel中的数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public NPOI.SS.UserModel.ISheet st;//将表格作为公共对象</span><br><span class="line">        private void Form1_Load(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //导入路径</span><br><span class="line">            var fs = new FileStream(@&quot;F:\c#_code\mytest.xlsx&quot;, FileMode.Open, FileAccess.Read);</span><br><span class="line">            //获取工作簿(即文件)</span><br><span class="line">            var wk = new np.XSSFWorkbook(fs);</span><br><span class="line">            //获取工作表(sheet1是从0索引开始，sheet2是索引1)</span><br><span class="line">            st = wk.GetSheetAt(0);</span><br><span class="line">            //MessageBox.Show(st.SheetName);</span><br><span class="line">            //获取行和列</span><br><span class="line">            MessageBox.Show(st.FirstRowNum.ToString());//有数据的第一行</span><br><span class="line">            MessageBox.Show(st.LastRowNum.ToString());//有数据的最后一行</span><br><span class="line">            MessageBox.Show(st.GetRow(3).FirstCellNum.ToString());//有数据的第一列</span><br><span class="line">            MessageBox.Show(st.GetRow(3).LastCellNum.ToString());//有数据的最后一列</span><br><span class="line">            for (int i = st.FirstRowNum+1; i &lt; st.LastRowNum; i++)</span><br><span class="line">            &#123; //获取4-16行中第2列的数据，以数字的方式显示</span><br><span class="line">                listBox1.Items.Add(st.GetRow(i).GetCell(1).NumericCellValue);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><pre><code>         private void button2_Click(object sender, EventArgs e)    {        //显示计算的公式即B4*2        textBox1.Text = st.GetRow(3).GetCell(2).CellFormula;        //读取字符串        textBox1.Text = st.GetRow(3).GetCell(3).StringCellValue;        //读取日期        textBox1.Text = st.GetRow(6).GetCell(5).DateCellValue.ToString(&quot;yyyy/MM/dd&quot;);    }</code></pre><h3 id="2-将数据写到excel中（导包）"><a href="#2-将数据写到excel中（导包）" class="headerlink" title="2.将数据写到excel中（导包）"></a>2.将数据写到excel中（导包）</h3><pre><code>        //创建工作簿       XSSFWorkbook workBook =  new XSSFWorkbook();        //创建工作表       NPOI.SS.UserModel.ISheet sheet = workBook.CreateSheet();        //创建行       NPOI.SS.UserModel.IRow row=  sheet.CreateRow(0);        //创建列       NPOI.SS.UserModel.ICell cell =  row.CreateCell(0);        //为单元格赋值       cell.SetCellValue(&quot;c#操作excel&quot;);        //合并单元格       //NPOI.SS.Util.CellRangeAddress cra = new NPOI.SS.Util.CellRangeAddress(0,4,0,3);//合并A1:D5,即第一行到第五行，第一列到第四列合并       //sheet.AddMergedRegion(cra);        //设置字体颜色//将excel文件输出       FileStream fs = new FileStream(@&quot;C:\Users\hasee\Desktop\ABCDE.xlsx&quot;,FileMode.Create,FileAccess.Write);       workBook.Write(fs);       fs.Close();       MessageBox.Show(&quot;操作已完成&quot;);</code></pre><h1 id="项目8：获取文件目录"><a href="#项目8：获取文件目录" class="headerlink" title="项目8：获取文件目录"></a>项目8：获取文件目录</h1><p>使用记事本创建一个bat文件，里面写入代码 “dir &#x2F;b&gt;文件目录.csv”执行后会自动生成excel文件</p><h1 id="项目9：学生管理系统"><a href="#项目9：学生管理系统" class="headerlink" title="项目9：学生管理系统"></a>项目9：学生管理系统</h1><p>1.vs中自带数据库。创建一个sqlServer项目。在视图-》sqlserver对象资源管理器打开选项卡即可使用</p><p>2.如果做好的数据库表需要更改，如果vs不让更改，在工具-》选项-》数据库工具-》表设计器-》将防止保存需要重新创建表的更改取消即可。</p><p>3.解决中文乱码的问题：将创建表的时候将varchar改为nvarchar即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/image-20220119124805589.png" alt="image-20220119124805589"></p><p>连接到服务器：指的是存放数据库的那个电脑，数据库服务器名称就是右键我的电脑 名称，一般数据库服务器只有一个计算机名称，所以通常不做更改（同一网段中可以连接其他服务器）</p><p>连接到数据库：指的是与某个指定的数据库进行连接的过程，建立成功后在服务器资源管理器中可以看到连接，默认连接的是master数据库<span id="more"></span></p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/image-20220119125758933.png" alt="image-20220119125758933"></p><p>添加sqlserver：指的是创建一个sqlserver管理界面，将与指定的服务器进行连接将所有的数据库导入到sqlserver中在vs中放在sqlserver对象管理器中</p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/image-20220119124705159.png" alt="image-20220119124705159"></p><p>连接字符串：以上都是通过可视化界面进行连接数据库的，但是编程必须使用代码进行数据库的连接，所以通过连接字符串连接数据库，连接字符串寻找方法：数据连接中右键属性，在属性对话中的可以找到连接字符串，如下</p><p>“Data Source&#x3D;(localdb)\MSSQLLocalDB;Initial Catalog&#x3D;master;Integrated Security&#x3D;True”</p><p>连接的服务器为(localdb)\MSSQLLocalDB，连接的数据库为master</p><p>1.打开链接：等价于在命令行中输入mysqli -u username -p password进行连接数据库。注意，不是一个数据库对应一个密码，而是一个用户一个密码对应一个连接名，这个连接名可以随便起，只是方便客户进行用户名分类，要不然使用用户名密码的形式查看不方便，一个连接名里面可以创建多个数据库，使用某个数据库不需要密码因为之前已经进行了连接。在同一个连接名下的数据库都是用同一个用户名和密码。一个用户对应一个连接名。</p><p> 2.在vs中无法为表添加数据的原因是：选错了项目，应该选择sqlServer，而不是项目</p><p>3.右键表：查看数据，为表添加数据</p><p>4.数据库乱码修改：</p><p>​ALTER DATABASE 【数据库名】 SET SINGLE_USER WITH ROLLBACK IMMEDIATE</p><p>​ALTER DATABASE [数据库名] COLLATE Chinese_PRC_CI_AS</p><p>​ALTER DATABASE [数据库名 ]SET MULTI_USER</p><p>创建表的时候，字段名要有字节的命名方式，否则从表中获取数据的之后容易写错。</p><p>执行表语句的时候，增删改返回的int类型，返回的行数，而查询返回的是一个集合。</p><p>5.数据库命名习惯t_数据库名，例如t_student其中t代表table，数据表中性别设置为男或者女的sql语句</p><p>Sql查询语句的两种写法</p><p>string sql &#x3D; “select * from t_user where id &#x3D; ‘“+textBox1.Text+”‘ and psw &#x3D; ‘“+textBox2.Text+”‘“;</p><p>string sql2&#x3D;string.Format(“select * from t_user where id &#x3D;{0} and psw&#x3D;{1}”,textBox1.Text,textBox2.Text);</p><p>6.Vs连接自带数据库：在项目中添加-》基于服务的数据库，后缀名为.mdf,然后 –》工具选项卡-》连接到数据库-》数据源选择为sql server-》服务器名选择是在sqlserver对象资源管理器中单击所创建的数据库，左上角有个添加sqlserver 然后serverName就是服务器名，-》选择数据库名称中添加自己创建的数据库即可，连接成功后会在服务器资源管理中的数据连接看到所创建的连接。</p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/wps82AE.tmp.jpg" alt="img"> </p><p>​设置数据库表中Id为自增：vs中打开表后，在右侧属性中-》标识列改为Id即可设置为自增</p><p>​数据库表修改完成之后点击-》更新，而不是保存-》更新数据库，完成更新</p><p>实现远程连接vs内置数据库。参考连接：<a href="https://www.cnblogs.com/caijiaming/p/9991216.html">https://www.cnblogs.com/caijiaming/p/9991216.html</a></p><p>​1.创建用户远程连接：create login [admin] with password ‘admin’，&#x2F;&#x2F;添加一个服务器登录名</p><p>​2.首先使用window登录方法进入sa权限，在需要连接的数据库的下面有个安全性-》添加用户</p><p>create user admin for login admin with default_schema&#x3D;dbo</p><p>​3.为用户赋予db_owner权限，exec sp_addrolemember ‘db_owner’, ‘admin’</p><p>​4.然后使用用户名密码进行登录服务器进行连接发现用户admin可以使用</p><p>oracle账户：</p><p>​sys:超级管理员，sys的权限比system获得的权限要多（数据库工程师使用（sysPER））</p><p>​system：管理员 （普通管理员使用）类似于淘宝数据库管理员（sysdba）</p><p>​普通用户：类似于淘宝用户(normal)</p><p>​Oracle11g和Oracle10g安装好后，自带一个普通用户，并自带四个二维表  并给该用户默认名为scott：（普通用户） 默认密码：tiger</p><p>在sqlserver中，char(10)：表示固定长度不变为10个字节，最大字节数为8000字节。varchar(10)表示最大长度为10个字节该类型最大字节数为8000。nvarchar(10)表示一个字符代表一个双字节（常用于含有除英语字符之外的字符例如中文）最大字节数为8000，最大字符数为4000，不带n表示一个字符代表一个单字节。text最大字节数为2Gb</p><p>date：年月日</p><p>time：时分秒</p><p>datetime：年月日时分秒</p><p>image 图片文件类型，但是不推荐使用，而是将文件存在在服务器上，使用nvarchar（500）来保存文件路径。</p><h2 id="设计数据库表的技巧"><a href="#设计数据库表的技巧" class="headerlink" title="设计数据库表的技巧"></a>设计数据库表的技巧</h2><p>如果有前端页面就根据前端页面进行设计，根据前端页面进行后台实体类的设计。<a href="https://blog.csdn.net/weixin_44491423/article/details/121250623">https://blog.csdn.net/weixin_44491423/article/details/121250623</a></p><p>如上链接：可知肯定有实体类Product这一项，肯定有Cart这一项，但是CartItem是如何引出的？因为在Cart这个页面中，肯定有多个Product，也就是列表项里面的产品，但是可以观察到每一项并不仅仅是product而且还根据用户的选择对Product进行了数量计算，总价计算，这些变量在Product或者Cart是无法体现的，所以将其拆分出来作为一个单独的类为CartItem。注意这个数量是与用户交互的数量，而不是product的剩余数量。综上：只要页面的不同区域并且与用户进行交互的部分就需要单独拆分出一个类。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="oracle修改密码："><a href="#oracle修改密码：" class="headerlink" title="oracle修改密码："></a>oracle修改密码：</h3><p>​在cmd命令行中使用命令：sqlplus &#x2F; as sysdba</p><p>​然后使用命令：</p><p>​alter user 用户名 identified by 新密码;</p><p>第二种方式</p><p>​然后使用命令：conn as sysdba</p><p>​然后输入一个已知的用户名和密码</p><p>​然后使用命令：</p><p>​alter user 用户名 identified by 新密码;</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>select * from 表名  查询表中所有的数据</p><p>select 字段名1，字段名2，..from 表名 查询指定字段的所有值，不同字段之间使用逗号隔开</p><h3 id="使用别名，"><a href="#使用别名，" class="headerlink" title="使用别名，"></a>使用别名，</h3><p>将字段改为其他的名字后只是在控制台上进行更改，但是在数据库中不会进行更改，只是为了方便用户查看</p><p>as可以省略不写，如果有特殊字符（例如空格）使用双引号添加别名</p><p>例第一种方式：select ename 姓名,job 工作,sal<em>12 年资,sal</em>12+3000 年薪 from emp  （直接在字段后面添加别名，字段名就会被改变成修改后的值）</p><p>第二种方式：select ename “姓名”,job 工作,sal<em>12 ’年资’,sal</em>12+3000 年薪 from emp  （使用双引号添加别名,不能使用单引号（上面的年资错误））</p><p>第三种方式：select ename as 姓名,job “工作”,sal<em>12 年资,sal</em>12+3000 年薪 from emp  （使用as关键字添加别名）</p><p>select ename “姓  名”,job 工作,sal<em>12 年资,sal</em>12+3000 年薪 from emp  如果别名中有空格或者其他特殊字符，使用双引号</p><h3 id="使用链接符：-作用：用来进行字符串连接"><a href="#使用链接符：-作用：用来进行字符串连接" class="headerlink" title="使用链接符：||作用：用来进行字符串连接"></a>使用链接符：||作用：用来进行字符串连接</h3><p>​select ename||job,sal from emp;  使用||符号进行字符链接</p><p>​select ename||’  的工作是  ‘||job||’  并且月工资是  ‘||sal from emp;  （这样可以将字段值进行连接） 注意：普通字符串使用的是单引号，而在别名时使用的是双引号</p><h3 id="去除重复-distinct"><a href="#去除重复-distinct" class="headerlink" title="去除重复 distinct"></a>去除重复 distinct</h3><p>​select distinct job from emp–发现工作是重复的，而工作种类是需要去除重复的,去除重复的规则是按照行纪念性去除的，多行数据完全相同取其一</p><p>问题1：查看员工工作种类</p><p>​select distinct job from emp 使用distinct关键字去除重复值，并且打印的是job</p><p>​问题2；怎么多字段去除重复</p><p>​select distinct job,sal from emp;  多字段去除重复，去除的是重复的一整条信息，即只有job和sal都同时一样时才会去掉重复</p><h3 id="排序-（如果不写则默认按照第一个字段的升序排序）"><a href="#排序-（如果不写则默认按照第一个字段的升序排序）" class="headerlink" title="排序 （如果不写则默认按照第一个字段的升序排序）"></a>排序 （如果不写则默认按照第一个字段的升序排序）</h3><p>​知识点：关键字desc降序  asc 升序，</p><p>​select 字段名1，字段名2…from 表名 order by 字段名3  desc（asc） 按照字段名三将前面的两个字段名值打印出来</p><p>​select * from emp order by sal,ename； 多字段作为排序条件的时候，优先按照第一个字段排序，然后依次按照其他字段排序。</p><p>​select ename,job,sal from emp order by sal*12  使用算术表达式，在sql语句种+只能做字段的逻辑运算</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>使用where条件进行结果筛选</p><p>​语法：select * from 表名 where 条件；</p><p>​在where中使用算术表达式 &#x3D; ,&lt; , &gt; ,&gt;&#x3D; ,&lt;&#x3D; ,&lt;&gt;（不等于）</p><p>​使用order by 对筛选结果进行排序，order by 出现在where后面</p><p>例如：查看工资等于1250的员工信息</p><p>​select ename,job ,sal from emp  where sal&gt;’1250’ order by sal–使用order by 对筛选结果进行排序，order by 出现在where后面</p><p>​查看工资不等于1500的员工信息</p><p>​select * from emp where sal&lt;&gt;1500 order by sal</p><p>查看入职日期在81年后的员工信息</p><p>​select * from emp where hiredate&gt;’1981年12月31号’这种方式错误，默认时日-月-年</p><p>​select * from emp where hiredate&gt;’1981&#x2F;12&#x2F;31’这种方式错误</p><p>​正确格式：select * from emp where hiredate&gt;’31-12月-1981年’ –使用日期的默认格式：日-月-年</p><p>知识点：where查询条件中使用关键字</p><p>​1、and 用于多条件的与筛选：select * from 表名 where 条件 and 条件 and 条件….</p><p>​2、or 用于多条件的或筛选： select * from 表名 where 条件 or 条件 or 条件….</p><p>​3、in 用于多条件的或筛选： select * from 表名 where 字段名 in(值，值，值….)</p><p>​4、like用于模糊查询：    select * from 表名 where 字段名 </p><p>like ‘%值%’ 包含，%表示任意多个任意字符</p><p>​5、is null 和is not null 用来判断字段是否为空  select * from 表名　where 字段名 is null </p><p>例：–查询工资在2000-3000之间的员工信息</p><p>​select * from emp where sal&gt;&#x3D;2000 and sal&lt;&#x3D;3000–使用and关键字进行”与”的多条件筛选；</p><p>​–查询工作为SALESMAN,ANALYST,MANAGER的员工信息</p><p>​select  * from emp where job&#x3D;’SALESMAN’ or job&#x3D;’ANALYST’ or job&#x3D;’MANAGER’–使用or关键字进行”或”的多条件筛选（注意字段值区分大小写）</p><p>​select * from emp where job in(‘SALESMAN’,’ANALYST’,’MANAGER’);–使用in关键字进行”或”的多条件筛选（in中的内容只能是单个值，而or是可以包括范围的）</p><p>​select  * from emp where job&#x3D;’ANALYST’</p><p>​–查询姓名中包含s的，以s开头的，以s结尾的，第二个字符为A的。</p><p>​select * from emp where ename like ‘%S%’;–使用like关键字，姓名中包含S的,%代表任意多个字符（也有大小写）%任意多个的任意字符</p><p>​select * from emp where ename like ‘S%’;–使用like关键字，以S开头的</p><p>​select * from emp where ename like ‘%S’;–以S结尾的</p><p>​select * from emp where ename like ‘<em>A%’–使用”</em>“指定位置包含指定字符的信息，”_”代表任意一个字符，A所在的位置取决于下划线个数的多少</p><p>查询名字中包含下划线的用户信息</p><p>​select * from emp where ename like ‘%A_%’escape ‘A’;–使用escape关键字将普通字符设置成为转译字符。</p><p>Escape 将指定的字符变为转义字符，而转义字符可以将特殊字符转为普通字符</p><p>​–查询有津贴的员工信息</p><p>​select * from emp where comm is not null;</p><p>​select * from emp where comm is null;–查询没有津贴的员工信息</p><h3 id="总结：单行函数-多行函数-转换函数-其他函数"><a href="#总结：单行函数-多行函数-转换函数-其他函数" class="headerlink" title="总结：单行函数 多行函数 转换函数 其他函数"></a>总结：单行函数 多行函数 转换函数 其他函数</h3><p>​–单行函数学习：不改变原始数据，只是起到修饰的作用，可以和字段混用即，使用单行函数是，当同时使用字段时，是不会产生冲突的，例首字母大写函数与ename混用，返回后，每条数据的字段值都会首字母大写。</p><table><thead><tr><th>函 数</th><th>功 能</th><th>示 例</th><th>结 果</th></tr></thead><tbody><tr><td>INITCAP (char)</td><td>首字母大写</td><td>initcap (‘hello’)</td><td>Hello</td></tr><tr><td>LOWER (char)</td><td>转换为小写</td><td>lower (‘FUN’)</td><td>fun</td></tr><tr><td>UPPER (char)</td><td>转换为大写</td><td>upper (‘sun’)</td><td>SUN</td></tr><tr><td>LTRIM (char, set)</td><td>左剪裁</td><td>ltrim (‘xyzadams’, ‘xyz’)</td><td>adams</td></tr><tr><td>RTRIM (char, set)</td><td>右剪裁</td><td>rtrim (‘xyzadams’, ‘ams’)</td><td>xyzad</td></tr><tr><td>TRANSLATE (char, from, to)</td><td>按字符翻译</td><td>translate (‘jack’, ‘abcd’, ‘1234’)</td><td>j13k</td></tr><tr><td>REPLACE (char, search_str, replace_str)</td><td>字符串替换</td><td>replace (‘jack and jue’, ‘j’, ‘bl’)</td><td>black and blue</td></tr><tr><td>INSTR (char, substr[, pos])</td><td>查找子串位置</td><td>instr (‘worldwide’, ‘d’)</td><td>5</td></tr><tr><td>SUBSTR (char, pos, len)</td><td>取子字符串</td><td>substr (‘abcdefg’,3,2)</td><td>cd</td></tr><tr><td>CONCAT (char1, char2)</td><td>连接字符串</td><td>concat (‘Hello’, ‘world’)</td><td>Helloworld</td></tr></tbody></table><p>​—1、字符函数</p><p>​select * from emp;</p><p>​select INITCAP(ename) from emp;–initcap函数只将将首字母大写，并打印ename字段的值（函数可以用in）</p><p>​select lower(ename)from emp;–lower 字母小写</p><p>​select replace(ename,’S’,’M’)  from emp;–replace 替换</p><p>​–2、数值函数–Math</p><table><thead><tr><th>函 数</th><th>功 能</th><th>示 例</th><th>结 果</th></tr></thead><tbody><tr><td>ABS(n)</td><td>取绝对值</td><td>abs(-15)</td><td>15</td></tr><tr><td>CEIL(n )</td><td>向上取整</td><td>ceil(44.778)</td><td>45</td></tr><tr><td>SIN(n)</td><td>正弦</td><td>sin(1.571)</td><td>.999999979</td></tr><tr><td>COS(n)</td><td>余弦</td><td>cos(0)</td><td>1</td></tr><tr><td>SIGN(n)</td><td>取符号</td><td>sign(-32)</td><td>-1</td></tr><tr><td>FLOOR(n)</td><td>向下取整</td><td>floor(100.2)</td><td>100</td></tr><tr><td>POWER(m,n )</td><td>m的n次幂</td><td>power(4,2)</td><td>16</td></tr><tr><td>MOD(m,n)</td><td>取余数</td><td>mod(10,3)</td><td>1</td></tr><tr><td>ROUND(m,n)</td><td>四舍五入</td><td>round(100.256,2)</td><td>100.26</td></tr><tr><td>TRUNC(m,n)</td><td>截断</td><td>trunk(100.256,2)</td><td>100.25</td></tr><tr><td>SQRT(n)</td><td>平方根</td><td>sqrt(4)</td><td>2</td></tr></tbody></table><p>—-伪表 dual，不是真是存在的表，是为了方便进行数据的验证，我们为了进行数据计算不可能创建一个表，只是为了方便我们进行计算，看一些效果，系统提供一个伪表dual 例如 select sys_date from dual;查看系统日期</p><p>​select * from dual</p><p>​select abs(-3) 绝对值，ceil(3.1415926)向上取整,floor(3.1415926)向下取整,power(2,3)幂,round(3.4)四舍五入 from dual（如果是真实的表则括号中需要填入字段值）</p><p>–3、日期函数</p><table><thead><tr><th>函 数</th><th>功 能</th><th>示 例</th><th>结 果</th></tr></thead><tbody><tr><td>MONTHS_BETWEEN</td><td>返回两个日期间的月份</td><td>months_between (‘04-11月-05’,’11-1月-01’)</td><td>57.7741935</td></tr><tr><td>ADD_MONTHS</td><td>返回把月份数加到日期上的新日期</td><td>add_months(‘06-2月-03’,1)add_months(‘06-2月-03’,-1)</td><td>06-3月-0306-1月-03</td></tr><tr><td>NEXT_DAY</td><td>返回指定日期后的星期对应的新日期</td><td>next_day(‘06-2月-03’,’星期一’)</td><td>10-2月-03</td></tr><tr><td>LAST_DAY</td><td>返回指定日期所在的月的最后一天</td><td>last_day(‘06-2月-03’)</td><td>28-2月-03</td></tr><tr><td>ROUND</td><td>按指定格式对日期进行四舍五入</td><td>round(to_date(‘13-2月-03’),’YEAR’) round(to_date(‘13-2月-03’),’MONTH’)round(to_date(‘13-2月-03’),’DAY’)</td><td>01-1月-0301-2月-0316-2月-03</td></tr><tr><td>TRUNC</td><td>对日期按指定方式进行截断</td><td>trunc(to_date(‘06-2月-03’),’YEAR’)trunc(to_date(‘06-2月-03’),’MONTH’)trunc(to_date(‘06-2月-03’),’DAY’)</td><td>01-1月-0301-2月-0302-2月-03</td></tr></tbody></table><p>select months_between(‘13-12月-2016’,’13-10月-2016’) from dual；–months_between 返回两个日期之间的月份数</p><p>Select add_month(’’) 将月份进行加减</p><p>–select months_between(‘16-11月-2016’,’16-8月-2016’) from dual;</p><p> –返回指定月数后的的日期</p><p>–select add_months(‘01-4月-2018’，4) from dual;</p><p>–返回下一个星期三对应的日期</p><p>–select next_day(‘16-4月-2018’,’星期三’) from dual;</p><p>–返回当月最后一天的日期</p><p>–select last_day(‘16-4月-2019’) from dual;</p><p>–按照星期进行四舍五入，即如果19号在星期日到星期三则向下取整，返回星期日对应的日期,否则返回星期六对应的日期。如果是按照MONTH进行四舍五入，则当日期在该月的中旬以上,就向上取整为下一个月，反之向下取整。如果按照YEAR进行四舍五入，则在六月以前该年份是向下取整，否则向上取整为下一个月</p><p>select round(to_date(‘19-4月-2019’),’DAY’) from dual;</p><p>多行函数学习</p><p>​多行函数 ：(记住)，多行函数不能与普通字段和单行函数进行混用（除非分组），因为多行函数返回的是字段值中的一条数据对多行的数据进行处理返回一个值，当使用字段返回的是字段中的所有值，这样的话就会发生冲突</p><p>例如  select ename ,max(sal) from emp;   –max返回的是sal中的最大值，而ename返回的所有的ename值所以产生错误</p><p>select max(sal)，lower(ename) from emp–多行函数和单行函数不能直接出现在查询语句中，除非group by 同理，lower是将ename进行小写并返回，但是max是找出其中的最大值并返回</p><p>​ max: max(字段名) 返回此字段的最大值</p><p>​ min：min(字段名) 返回此字段的最小值</p><p>​ avg：avg(字段名) 返回平均值</p><p>​ sum：sum（字段名） 返回字段的和</p><p>​ count:count</p><p>​ –count(*)，用来查询表中有多少条记录</p><p>​ –count（字段名），用来查询某个字段有值的个数，null会自动被过滤</p><p>​ –count(distinct 字段名),可以先去除重复再计数。</p><p> 注意： –多行函数不能和普通字段直接出现在查询语句中，除非group by </p><p>​ –多行函数和单行函数不能直接出现在查询语句中，除非group by     </p><p>​查看员工的最高工资</p><p>​select max(sal),ename from emp–多行函数不能和普通字段直接出现在查询语句中，除非group by</p><p>​  select max(sal)，lower(ename) from emp–多行函数和单行函数不能直接出现在查询语句中，除非group by</p><p>​select ename from emp</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>第三天：</p><p>​第一节课：转换函数学习</p><p>转换函数:在转换的时候改变的是数据的类型，数据内容不会改变，可以指定格式。</p><p>​1、to_number：将数值字符串转换为数字类型的数值，to_number(数字字符)</p><p>​2、to_char：将数字转换为字符类型，将日期转换为字符类型 to_char(数字&#x2F;日期)</p><p>​3、to_date：将字符类型的日期转换为日期类型： to_date(char)</p><p>1：number–&gt;char 转换的时候使用的是默认格式，</p><p>​select  to_char(123) from dual–将数字转换为字符类型，使用to_char(number)</p><p>​select sal, to_char(sal) from emp</p><p>​number–&gt;char 使用指定的格式 char类型可以指定字符的格式</p><p>​to_char(number,’格式’)，格式：</p><p>​$代表美元符，9代码位置占位。例如，L999,999,999表示三位一组的显示方式L代表人民币符号，0代表保留数字个数，不足使用0补充。</p><p>​select to_char(sal),to_char(sal,’L999,999,999’) from emp</p><p>​select to_char(sal),to_char(sal,’L0000.00’) from emp</p><p>2：char—&gt;number  to_number(数字字符)</p><p>​select to_number(‘123’) from dual</p><p>数值和字符之间的转换是隐士转换，即to_number可以省略不写</p><p>3：har—&gt;date，转换的字符必须是日期格式的字符串，默认格式 dd-mm-yyyy</p><p>注意：因为字符串有很多，所以在字符转换为日期的时候，需要指定格式，因为日期是具备一定格式的字符组合。</p><p>字符转换为日期的时候，指定的格式为字符的日期顺序，无需指定间隔符。</p><p>​yyyy：表示年  mm:表示月  dd表示日</p><p>​select to_date(‘05-12月-2016’) from dual;（这是正确的，因为Oracle默认格式就是日月年）将字符串转为日期</p><p>​select to_date(‘2016-05-12’,’yyyy-mm-dd’) from dual–使用指定的格式将指定的日期字符串转换为日期将字符串转为日期</p><p>​select to_date(‘12-05-2016’,’mm&#x2F;dd&#x2F;yyyy’) from dual</p><p>4：date转为char</p><p>​注意：因为日期本身就具备一定的格式在不是指定格式的情况下会默认使用dd-mm-yyyy格式显示数据</p><p>​指定的格式会作为日期转换为字符串类型的显示格式存在。例如：</p><p>​常用：yyyy-mm-dd’  ‘2016-12-05’</p><p>​  yyyy&#x2F;mm&#x2F;dd’   ‘2016&#x2F;12&#x2F;05’</p><p>​yyyy”年”mm”月”dd”日”‘   2016年12月05日</p><p>​select hiredate,to_char(hiredate) from emp–日期转换为字符的时候，不指定格式使用默认格式：dd-mm-yyyy，将日期转为字符串</p><p>​select hiredate,to_char(hiredate,’yyyy-mm-dd’) from emp;–使用指定格式将日期转换为字符串类型将日期转为字符串</p><p>select hiredate,to_char(hiredate,’yyyy&#x2F;mm&#x2F;dd’) from emp;–使用指定格式将日期转换为字符串类型</p><p>​select hiredate,to_char(hiredate,’yyyy”年”mm”月”dd”日”‘) from emp;–使用指定格式将日期转换为字符串类型</p><p>第二节课：其他函数：</p><p>其他函数：</p><p>​1、nvl():nvl(字段名，执行)–相当于java中的if条件判断如果字段值不为null则返回字段值，如果为null的话就返回“执行” 部分的值</p><p>​2、nvl2():nvl2(字段名，值1，值2)–相当于java中的If(){}else{}判断如果字段值为null的执行值1，如果值1也为null，则执行值2</p><p>​3、decode():decode(字段名，条件1，执行内容1，条件2，执行内容2，条件3，执行内容3，公共执行内容)相当于java中if(){}else if(){}else if(){}…else{}</p><p>例如：</p><p>select ename,sal 基本工资,comm 绩效,sal+comm 月薪 from emp（会出现错误，因为comm部分会出现null的情况）</p><p>​select ename,sal 基本工资,comm 绩效,sal+nvl(comm,0)月薪 from emp（正确写法）</p><p>​查询所有员工的月薪及姓名和工作</p><p>​select ename,sal 基本工资,comm 绩效,nvl2(comm,sal+comm,sal)月薪 from emp</p><p>​显示员工的职称</p><p>​select ename,job,decode(job,’MANAGER’,’经理’,’SALESMAN’,’销售人员’,’普通员工’) from emp</p><p>解释：decode中job与manager比较为真的话就执行经理，与salesman比较为真的话就执行销毁人员，如果全为假，就执行普通员工类似于if（job &#x3D; manager）{输出经理}else if（job &#x3D; salesman ）{输出销售人员} else {输出普通员<img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/wps629D.tmp.jpg" alt="img"></p><p>​</p><h3 id="使用group-by分组字段"><a href="#使用group-by分组字段" class="headerlink" title="使用group by分组字段"></a>使用group by分组字段</h3><p>在多行函数中不能直接使用普通字段，除非group by</p><p>在多行函数中不能直接使用单行函数，除非group by</p><p>group by学习：</p><p>​ —1、使用group by进行数据分组 select 多行函数，分组字段 from 表名 group by </p><p>注意1：分组字段在使用了分组字段后，在select语句中只允许出现分组字段和多行函数，因为按照分组字段分组后，只打印出分完组之后的内容，而普通字段是显示所有的该字段值</p><p>注意2：如果是多字段分组，则按照第一字段分组，然后每个小组再进行筛选</p><p>注意3；再where语句中不允许出现多行函数，因为where的优先级要大于多行函数</p><p>​ —2、多字段进行分组的时候，按照字段顺序进行分组，第一条件分组完成后，继续使用其他条件依次分组。</p><p>​ —3、group by依然可以和order by 联合使用，order by永远是在最后</p><p>​ —4、可以和单行函数联合进行分组，注意“使用了单行函数那么在查询语句中必须也要使用</p><p>​查询不同部门的最高工资</p><p>​select * from emp order by deptno</p><p>​select  deptno,max(sal) from emp group by deptno–使用group进行分组查询，分组的字段可以出现在查询中，其他字段依然不可以</p><p>​查询不同工作岗位的员工数</p><p>​select * from emp for update</p><p>​select lower(job),count(*) from emp group by lower(job)–使用单行函数进行分组</p><p>​查询不同部门的不同工作岗位的人数</p><p>​select deptno,job ,count(*) from emp group by deptno,job–使用多字段组合进行分组</p><p>​select deptno,job ,count(*) from emp group by deptno,job order by deptno</p><p>​查询不同部门的不同工作岗位的并且人数大于1的信息</p><p>​select count(<em>) from emp where count(</em>)&gt;3 group by deptno（这是错误的，where语句中不能出现多行函数）</p><p>​select deptno,job ,count(<em>) from emp where count(</em>)&gt;1 group by deptno,job order by deptno（这也是错误的）</p><p>​查询部门号大于10的不同部门的不同工作岗位的人数</p><p>​select deptno,job ,count(*) from  emp where deptno&gt;10 group by deptno,job order by deptno</p><p>​使用having进行分组后筛选</p><h3 id="having学习："><a href="#having学习：" class="headerlink" title="having学习："></a>having学习：</h3><p>​  –1、使用group by分组后在进行数据筛选的时候，where中不能出现多行函数，因为where语句比多行函数的级别要高，只有进行筛选完后才能用多行函数进行处理 ，而不是先进行多行函数处理再进行where筛选，所以出现了错误，所以使用新的关键字having进行条件筛选，针对分组进行分组后的数据筛选，允许使用多行函数，但是having关键词必须和分组结合使用，不允许单独使用</p><p>​  –2、where条件筛选的执行顺序：from–&gt;where—&gt;group by–&gt;select</p><p>​  –3、having条件筛选的执行顺序：from–&gt;group by –&gt;having–&gt;select</p><p>​  –4、where的执行效率比having要高，能使用where的情况下尽量不要使用having</p><p>​查询不同部门的不同工作岗位的并且人数大于1的信息</p><p>select deptno ,job ,count(<em>) from emp group by deptno , job having count(</em>) &gt; 1</p><p>Select deptno,job ,count(<em>) from emp group where count(</em>) &gt; 1 by deptno ,job ; 这是错误的只是因为where语句比多行函数等级要高</p><p>​使用where语句进行筛选</p><p>​where条件语句sql执行顺序：from–&gt;where—&gt;group –&gt;select</p><p>​select count(<em>) from emp where count(</em>)&gt;1 group by deptno，job</p><p>​使用having语句进行筛选，having语句必须和分组函数进行使用，不允许单独使用</p><p>​having条件语句的执行顺序:from–&gt;group by –&gt;having–&gt; select</p><p>​select deptno, count(<em>) from emp  group by deptno having count(</em>)&gt;5</p><p>​select deptno,job ,count(*) from  emp  group by deptno,job  having deptno&gt;10 order by deptno</p><h3 id="插入数据学习及数据的备份"><a href="#插入数据学习及数据的备份" class="headerlink" title="插入数据学习及数据的备份"></a>插入数据学习及数据的备份</h3><p>1、插入数据(insert)</p><p>1、语法规范  insert into 表名(字段1，字段2，字段3，….)values(‘值1’,’值2’,’值3’…..)</p><p>如果是全字段插入，则可以省略字段名部分 insert into 表名 values(‘值1’，’值’，’值’。。。);</p><p>2、主键：用来唯一标识一条数据的字段通常设置主键，主键是唯一不可以重复的，在一张表中某个字段的值是非空唯一的，将此字段设置为主键</p><p>主键是唯一不可以重复的</p><p>4、事务的提交：如果一个事件是由多个动作组成，只要有一个动作没有执行成功则自动将数据回滚到原始状态，此们技术称之为事务</p><p>​ 保证数据的安全和完整</p><p>​ 事物的提交：</p><p>​ 使用第三放插件的提交按钮</p><p>​ 使用commit语句</p><p>2、创建数据的备份</p><p>注意：只会备份表结构和表的数据，约束不会备份</p><p>表级别备份</p><p>全部备份： create table 新的表名 as select * from 备份表名</p><p>部分备份： ceate table 新的表名 as select 字段名，字段名，….from 备份表名</p><p>数据整体插入</p><p>Insert into 插入表名 select  * from 表名</p><p>注意查询语句结果的字段数据必须和插入表名的字段数量一致，类型要一致</p><p>修改数据:update也是修改数据</p><p>语法结构：update 表名 set 字段名1&#x3D;’字段值1’,字段名2&#x3D;’字段值2’，…where 条件</p><p>删除数据：delete，不是删表，而是删除数据</p><p>​1)删除语句：delete 表名 where 条件</p><p>​–删除部门标号为70的数据</p><p>​delete dept where deptno&#x3D;’70’—删除指定数据</p><p>​select * from dept</p><p>​delete tdept—清空表数据</p><p>​truncate table tdept—清空表数据建议使用truncate关键字，truncate的效率高</p><h3 id="sql92标准"><a href="#sql92标准" class="headerlink" title="sql92标准"></a>sql92标准</h3><p>​—-笛卡尔积：一件事情的完成需要很多步骤，而每个步骤有很多种方式，完成这件事情的所有方式称之为笛卡尔积，将多个表的数据进行一一对应；</p><p>​select * from emp–14条数据</p><p>​select * from dept–7条数据</p><p>​select * from emp,dept order by ename–7*14&#x3D;98条数据</p><p>上面14条数据中的每条数据先与dept中的第一条数据进行笛卡尔积，然后emp中的每条数据在于dept中第二条数据进行笛卡尔积。。。然后可以按照操作一个表的方式对合表进行操作；</p><h3 id="等值连接筛选"><a href="#等值连接筛选" class="headerlink" title="等值连接筛选"></a>等值连接筛选</h3><p>​     –注意：条件为字段的值相同来进行筛选，字段的名字可以不同</p><p>​     –查询员工姓名，工作，薪资，部门名称</p><p>​     select * from emp,dept where emp.deptno&#x3D;dept.deptno–可以直接在select子句中使用字段直接获取数据，但是查看的效率比较低。建议字段前加上表名，</p><p>   –注意：如果是公共字段，则必须声明表名，否则系统无法进行区分</p><p>   select ename,job,sal,dname from emp,dept where emp.deptno&#x3D;dept.deptno–等值连接筛选</p><p>   select emp.ename,emp.job,emp.sal,dept.dname,emp.deptno from emp,dept where emp.deptno&#x3D;dept.deptno</p><p>   select e.ename,e.job,e.sal,d.dname from emp e,dept d where e.deptno&#x3D;d.deptno and sal&gt;2000–给表使用别名，因为执行顺序是from–》 where–》select</p><p>–不等值连接</p><p>–查询员工姓名，工作，工资，工资等级</p><p> select * from emp e,salgrade s where e.sal&gt;&#x3D;s.losal and e.sal&lt;&#x3D;s.hisal</p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接:"></a>自连接:</h3><p>将两个相同的表进行连接但是链接后会出现使用字段时无法区分的情况，所以需要使用别名进行区分字段</p><p> –查询员工姓名，工作，薪资，及上级领导姓名</p><p> select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr&#x3D;e2.empno</p><p>–外连接，因为多表查询会自动过滤掉字段值为null的情况（在多表查询种任何一个字段值为null就会被过滤掉）所以需要手动将过滤掉的数据还原回来</p><p> –左外连接:加在右边，显示满足条件且左边字段没有值（任何一个字段值为null）的数据</p><p> –查询员工姓名，工作，薪资，部门名称及没有部门的员工信息</p><p>​        select * from emp e,dept d where e.deptno&#x3D;d.deptno(+)  （指的是显示emp中 只要字段值为空的字段）</p><p>–右外连接:加在左边，显示右边满足条件且右边边对应字段没有值（字段值为null）的数据  （dept中字段值为空的字段）</p><p> –查询员工姓名，工作，薪资，部门名称及没有员工信息的部门</p><p> select * from emp e,dept d where e.deptno(+)&#x3D;d.deptno&#x2F;&#x2F;将右边的数据也显示出来</p><h3 id="SQL99多表查询"><a href="#SQL99多表查询" class="headerlink" title="SQL99多表查询"></a>SQL99多表查询</h3><p>  –注意1：依然可以给表添加别名</p><p>  –注意2：如果使用on或者usering关键对结果进行筛选，必须使用inner join作为表与表的连接（笛卡尔积），其中inner可以省略</p><p>  –注意3:外连接的 outer关键字可以省略不写</p><p>  –注意4：依然可以继续使用分组，having ，排序等</p><p>0.–笛卡尔积:使用cross join 关键字</p><p>​    —select 内容 from 表名 cross join </p><p>​       select * from emp cross join dept（这与sql92种使用from emp，dept是一样的）</p><p> –查询员工姓名，工作，薪资，部门名称</p><ol><li>–自然连接：使用关键字 natural join</li></ol><p>​      –使用：select 内容 from 表名 natural join 表名</p><p>​      –特点1：底层先笛卡尔积，然后按照两张表的相同的字段自动进行等值筛选（及底层实现了where语句中的同名同值字段筛选）。</p><p>select * from emp natural join dept</p><p>Select * from emp ,dept where emp.deptno &#x3D; dept.deptno(这是自然连接底层实现的方式)</p><p>​    –问题1：如果只想按照部分字段结果筛选怎么办？</p><p>​    –问题2：如果想按照字段名不同，但是值相同进行等值筛选怎么办？</p><p> –解决1：使用using关键字</p><p> –作用1：指明使用指定的字段对联合查询的结果进行等值筛选（使用using字段进行筛选时必须使用inner join关键字）</p><p>​    –注意：指明的字段必须是两表的同名同值字段</p><p>​    –使用:select 内容 from 表名 inner join 表名 using(字段名，字段名,….)</p><p>   select * from emp inner join dept using(deptno)</p><p>   –解决2：使用on关键字进行自定义连接条件筛选(等值筛选，不等值筛选，即可以自己定义筛选条件)（这种方式非常重要）</p><p>​    –注意：普通筛选条件使用where进行筛选，不要使用on进行。好处：SQL语句的阅读性变强。</p><p>​    –使用：select 内容 from 表名 inner join 表名 on 连接条件 where 普通筛选条件</p><p>   select * from emp inner join dept on emp.deptno&#x3D;dept.deptno where sal&gt;2000</p><h3 id="外连接："><a href="#外连接：" class="headerlink" title="外连接："></a>外连接：</h3><p>​       –左外连接:select 内容 from 表名 left outer join 表名 on 连接条件 </p><p>​         –查询员工姓名，工作，薪资，部门名称及没有部门的员工信息</p><p>​         select * from emp e left outer  join dept d on e.deptno&#x3D;d.deptno</p><p>​       –右外连接:select 内容 from 表名 right outer join 表名 on 连接条件 </p><p>​         –查询员工姓名，工作，薪资，部门名称及没有员工的部门信息</p><p>​         select * from emp e right outer  join dept d on e.deptno&#x3D;d.deptno</p><p>​       –全外连接：select 内容 from 表名 full outer join 表名 on 连接条件 </p><p>​         select * from emp e full  outer join dept d on e.deptno&#x3D;d.deptno</p><p>​    –自连接:</p><p>​       –查询员工及其上级领导姓名</p><p>​       select  e1.*,e2.ename from emp e1 inner join emp e2 on e1.mgr&#x3D;e2.empno</p><h3 id="自连接及三表联合查询"><a href="#自连接及三表联合查询" class="headerlink" title="自连接及三表联合查询"></a>自连接及三表联合查询</h3><p>​-SQL92&amp;SQL99实现三表联合查询</p><p> –完成三表联合查询</p><p>  –SQL92实现：查询员工信息及部门名称及所在城市名称并且员工的工资大于2000或者有奖金</p><p>​    –特点：易于书写，难于阅读</p><p>​    –缺点：92的SQL语句结构不清晰</p><p>​    –用法：</p><p>​       –select  内容 (别名，连接符，去除重复，oracle函数，逻辑运算)</p><p>​       –from  表名1，表名2，表名3…</p><p>​       –where  条件(连接条件，普通筛选条件，where子句关键字)</p><p>​       –group by 分组字段</p><p>​       –having 多行函数筛选</p><p>​       –order by 排序字段</p><p>​    select e.*,d.dname,c.cname </p><p>​    from emp e,dept d,city c</p><p>​    where (e.deptno&#x3D;d.deptno and d.loc&#x3D;c.cid and sal&gt;2000) or (e.deptno&#x3D;d.deptno and d.loc&#x3D;c.cid and comm is not null) </p><p>​    order by e.sal </p><p>  SQL99实现查询员工信息及部门名称及所在城市名称并且员工的工资大于2000或者有奖金</p><p>​    –特点：难于书写，易于阅读</p><p>​    –使用：</p><p>​       –select 内容 from 表名1</p><p>​       – inner join 表名2</p><p>​       – on 连接条件</p><p>​       –inner join 表名3</p><p>​       –on 连接条件</p><p>​       –where  普通筛选条件</p><p>​       –group by 分组</p><p>​       –having 多行函数筛选</p><p>​       –order by 排序</p><p>   select * from emp e </p><p>   inner join dept d </p><p>   on e.deptno &#x3D; d.deptno </p><p>   inner join city c </p><p>   on d.loc &#x3D;c.cid</p><p>   where e.sal&gt;2000 or e.comm is not null</p><p>   order by e.sal</p><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><p> –使用时机：当查询的筛选条件不明确时，考虑使用子查询。</p><p>–单行子查询:</p><p> –使用时机：筛选条件不明确需要执行一次查询，并且查询结果为一个字段这个字段所带的值只有一个（如果为多个字段则比较运算符无法进行比较，如果为多个值则比较运算不知道改以哪个为标准及进行比较）</p><p> –注意：where子句中允许出现查询语句，该查询语句称为子查询</p><p> –使用：select 内容 from 表名 where 字段名 比较运算符 子查询语句</p><p>  –查询所有比雇员“CLARK”工资高的员工信息</p><p>   select * from emp where sal&gt;(select sal from emp where ename &#x3D;’CLARK’)</p><p>  –查询工资高于平均工资的员工的名字和工资</p><p>  select ename,sal from emp where sal&gt;(select avg(sal) from emp )</p><p>  –查询和soctt属于同一部门且工资比他低的员工资料</p><p>  select * from emp where deptno&#x3D;(select deptno from emp where ename&#x3D;’SCOTT’) and sal&lt;(select sal from emp where ename&#x3D;’SCOTT’)</p><p>  –查询工资最高的员工资料</p><p>  select * from emp where sal&#x3D;(select max(sal) from emp)</p><p>  –查询职务和scott相同，雇佣时间早的员工信息</p><p>  select * from emp where job&#x3D;(select job from emp where ename&#x3D;’SCOTT’) and hiredate &lt;(select hiredate from emp where ename&#x3D;’SCOTT’)</p><p>  –查询工资比scott高或者雇佣时间早的员工编号和名字</p><p>   select empno,ename from emp where job&#x3D;(select job from emp where ename&#x3D;’SCOTT’) or hiredate &lt;(select hiredate from emp where ename&#x3D;’SCOTT’)</p><h3 id="多行子查询："><a href="#多行子查询：" class="headerlink" title="多行子查询："></a>多行子查询：</h3><p>   –使用:子查询的结果只有一个字段但是字段有n个值，考虑使用多行子查询，其实就是使用关键字</p><p>​    –关键字1:any 任意</p><p>​      –select 内容 from 表名 where 字段名 比较运算符 any 子查询语句</p><p>​    –关键字2：all 所有</p><p>​      –select 内容 from 表名 where 字段名 比较运算符 all 子查询语句</p><p>​    –关键字3：in 表示任意存在,相当于 &#x3D; any  </p><p>​      –select 内容 from 表名 where 字段名 in 子查询语句  </p><p>​      –select 内容 from 表名 where 字段名 not in 子查询语句  </p><p>  –查询工资高于任意一个CLERK的所有员工信息</p><p>   select * from  emp where sal&gt; any (select sal from emp where job&#x3D;’CLERK’)</p><p>  –查询工资高于所有SALESMAN的员工信息</p><p>  select * from emp where sal&gt; all (select sal from emp where job&#x3D;’SALESMAN’)</p><p>  –查询部门20中同部门10的雇员工作一样的雇员信息</p><p>  select job from emp where deptno&#x3D;10</p><p>  select *from emp where (job&#x3D;’MANAGER’ or job&#x3D;’PRESIDENT’ or job&#x3D;’CLERK’) and deptno&#x3D;20</p><p>  select * from emp where job  in (select job from emp where deptno&#x3D;10) and deptno&#x3D;20</p><p>   select * from emp where job &#x3D; any (select job from emp where deptno&#x3D;10) and deptno&#x3D;20</p><h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><p>​多行子查询学习：其实就使用使用关键字：any all in</p><p>​注意：子查询返回多个值建议使用多行子查询，返回的单个值使用单行子查询</p><p>​select * from emp where sal&gt; any (select sal from emp where job&#x3D;’CLERK’) and job&lt;&gt;’CLERK’</p><p>​查询工资高于所有SALESMAN的员工信息</p><p>​select * from emp where sal&gt;(select max(sal) from emp where job&#x3D;’SALESMAN’)–单行子查询的写法</p><p>​select * from emp where sal&gt;all (select sal from emp where job&#x3D;’SALESMAN’;</p><p>​查询部门20中同部门10的雇员工作一样的雇员信息</p><p>​select * from emp where deptno&#x3D;’20’ and (job&#x3D;’MANAGER’ or job&#x3D;’PRESIDENT’ or job&#x3D;’CLERK’)</p><p>​select * from emp where deptno&#x3D;’20’ and job in (‘MANAGER’, ‘PRESIDENT’ , ‘CLERK’)</p><p>​select * from emp where deptno&#x3D;’20’ and job in (select job from emp where deptno&#x3D;’10’)</p><p>​select * from emp where deptno&#x3D;’20’ and job&#x3D; any (select job from emp where deptno&#x3D;’10’)</p><p>​select job from emp where deptno&#x3D;’10’</p><h3 id="oracle的账户管理学习："><a href="#oracle的账户管理学习：" class="headerlink" title="oracle的账户管理学习："></a>oracle的账户管理学习：</h3><p>   – system 管理账户  bjsxt</p><p>​     –特点：具备大部分oracle的操作权限，主要用来管理普通账户及oralce的数据</p><p>​     –使用人：oracle数据维护工作人员</p><p>   – sys 超级管理员账户 bjsxt</p><p>​     –特点：具备system的所有权限，同时又具备其他的权限</p><p>​     –使用人：oracle攻城狮</p><p>  –创建账户</p><p>​     –使用system账户，并使用dba身份，登录oracle管理系统</p><p>​     –创建用户</p><p>​       create user bjsxt identified by bjsxt;     </p><p>  –维护账户</p><p>​      –赋予权限  grant 权限或者角色名 to 用户名</p><p>​       grant connect to bjsxt;–给用户赋予登录权限</p><p>​       grant resource to bjsxt;–给用户资源操作权限</p><p>​       grant dba to bjsxt;–给用户赋予dba权限</p><p>​       select * from scott.emp–查看其它用户的表 使用用户名.表名  </p><p>​      –删除权限 revoke 权限或者角色名 from 用户名</p><p>​       revoke dba from bjsxt;</p><p>  –删除账户 drop user 用户名</p><p>​      drop user bjsxt;</p><p> –创建表:</p><p>  –使用：create table 表名(字段名 类型，字段名 类型，….);</p><p>  –数据类型：</p><p>​    –number –数值类型</p><p>​          –整数类型 number(a)  总长度为a</p><p>​          –浮点数类型 number(a,b) 总长度为a，小数位长度为b，小数位可以不写。</p><p>​    –varchar2类型</p><p>​        –字符类型 varchar2(ln) ln表示字符的最大长度，实际存储内存长度是根据字符大小来分配，但是最大不能超过ln </p><p>​        –特点：动态分配存储空间，节省空间</p><p>​    –char类型</p><p>​        –字符类型 char(ln) 不管字符数据长度是多大，直接开辟ln大小的空间存储数据，char的存储效率比较高，而varchar2则比较省空间面试题会问varchar和char的区别</p><p>​        –特点：存储效率高于varchar2</p><p>​    –date类型</p><p> create table student(</p><p>   sno number(10),</p><p>   sname varchar2(100),</p><p>   sage number(3),</p><p>   ssex char(100),</p><p>   sfav varchar2(500),</p><p>   sbirth date  </p><p>  )</p><h3 id="修改表学习："><a href="#修改表学习：" class="headerlink" title="修改表学习："></a>修改表学习：</h3><p>​修改表</p><p>​在命令窗口查看表结构 desc 表名</p><p>​添加新字段  alter table 表名 add 字段名 类型</p><p>​ alter table student add phone number(11)</p><p>​修改字段类型   alter table 表名 modify 字段名 类型</p><p>​ alter table  student modify sname varchar2(200)</p><p>​删除字段   alter table 表名 drop column 字段名</p><p>​ alter table student drop column phone</p><p>​修改表名 rename 表名 to 新的表名</p><p>​rename student to stu</p><p>​rename stu to student </p><p>​删除表  drop table 表名</p><p>​drop table student</p><h3 id="Oralce的二维表操作"><a href="#Oralce的二维表操作" class="headerlink" title="Oralce的二维表操作"></a>Oralce的二维表操作</h3><p>–简单的创建语句：</p><p>create table student(</p><p>​    sno number(10)  ,</p><p>​    sname varchar2(100) ,</p><p>​    sage number(10) ,</p><p>​    ssex char(100) ,</p><p>​    sbirth date,</p><p>​    sfav varchar2(100),</p><p>​    sqq number(12) </p><p>)</p><h3 id="二维表创建约束学习：-主键约束，非空约束，检查约束，唯一约束"><a href="#二维表创建约束学习：-主键约束，非空约束，检查约束，唯一约束" class="headerlink" title="二维表创建约束学习：(主键约束，非空约束，检查约束，唯一约束)"></a>二维表创建约束学习：(主键约束，非空约束，检查约束，唯一约束)</h3><p>  –问题1：学号重复依然可以添加</p><p>​    insert into student values(1,’关晓彤’,18,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>​    insert into student values(1,’关晓彤001’,18,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>  –问题2：竟然可以没有名字</p><p>​    insert into student values(2,’’,18,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>  –问题3：年龄竟然可以超过200岁</p><p>​    insert into student values(3,’关晓彤002’,300,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>  –问题4：性别竟然可以为任意字符</p><p>​    insert into student values(4,’关晓彤’,18,’a’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>  –问题5：qq号竟然可以重复</p><p>​    insert into student values(5,’关晓彤003’,18,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>​    insert into student values(6,’关晓彤004’,18,’女’,’拍电影’,to_date(‘2000-01-01’,’yyyy-mm-dd’),’267889900’);</p><p>解决方式：</p><p>—解决：</p><p>  –问题1：添加主键，主键特点：非空唯一</p><p>​    –使用：(通常使用第一种方式比较简单)</p><p>​      –第一种方式：直接在创建表的字段后使用 primary key</p><p>​      –第二种方式：在创建表的语句的最后面使用 constraints pk_表名_字段名 primary key(字段名)（其中前面的名字是将主键名改为自己设置的名字，这样在报错时就可以清晰知道是什么错误了，通常使用pk_表名_字段名来表示）</p><p>​      –第三种方式：在创建表后使用 alter table 表名 add  constraints pk_表名_字段名 primary key(字段名);</p><p>​      –删除主键   alter table student drop  constraints 主键的约束名;</p><p>  –问题2：使用非空约束</p><p>​    –使用：</p><p>​      –直接在创建表的字段后使用 not null 关键字 </p><p>​      –在创建表的语句的最后面使用 constraints ck_表名_字段名 check(字段名 is not null)</p><p>​      –在创建表后使用 alter table 表名 add  constraints ck_表名_字段名 check(字段名 is not null);</p><p>​      –删除非空约束 alter table student drop  constraints 非空约束名;</p><p>  –问题3：使用检查约束</p><p>​      –直接在创建表的字段后使用 check(条件) 例如    sage number(3) check(sage&lt;150 and sage&gt;0)，</p><p>​      –在创建表的语句的最后面使用 constraints ck_表名_字段名 check(条件)</p><p>​      –在创建表后使用 alter table 表名 add  constraints ck_表名_字段名 check(条件);</p><p>​      –删除检查约束 alter table student drop  constraints 检查约束名;</p><p>  –问题4：使用检查约束</p><p>​      –直接在创建表的字段后使用 check(条件)</p><p>​      –在创建表的语句的最后面使用 constraints ck_表名_字段名 check(条件)</p><p>​      –在创建表之后使用alter table 表名 add  constraints ck_表名_字段名 check(条件);</p><p>​      –删除检查约束 alter table 表名 drop  constraints 检查约束名;</p><p>  –问题5：使用唯一约束</p><p>​      –直接在创建表的字段后使用 unique</p><p>​      –在创建表的语句后面使用 constraints un_表名_字段名 unique(字段名);</p><p>​      –在创建表后使用 alter table 表名 add  constraints un_表名_字段名 unique(字段名);</p><p>​      –删除约束：alter table 表名 drop  constraints 唯一约束名;</p><p>解决方式的代码</p><p> create table student(</p><p>​      sno number(10) ,–primary key</p><p>​      sname varchar2(100) ,–not null</p><p>​      sage number(3), –check(sage&lt;150 and sage&gt;0)</p><p>​      ssex char(4) ,–check(ssex&#x3D;’男’ or ssex&#x3D;’女’)</p><p>​      sfav varchar2(500),</p><p>​      sbirth date,</p><p>​      sqq varchar2(30) –unique（独一无二的）</p><p>​      –constraints pk_student_sno primary key(sno)–添加主键约束</p><p>​      –constraints ck_student_sname check(sname is not null)–非空约束</p><p>​      –constraints ck_student_sage check(sage&lt;150 and sage&gt;0)–检查约束</p><p>​      –constraints ck_student_ssex check(ssex&#x3D;’男’ or ssex&#x3D;’女’)–检查约束</p><p>​      –constraints un_student_sqq unique(sqq)–唯一约束</p><p>   )  </p><p>   –添加主键约束</p><p>​    alter table student add  constraints pk_student_sno primary key(sno); </p><p>​    alter table student drop  constraints pk_student_sno;</p><p>   –添加非空约束</p><p>​    alter table student add  constraints ck_student_sname check(sname is not null);</p><p>​     alter table student drop  constraints ck_student_sname; </p><p>   –添加检查约束</p><p>   alter table student add constraints ck_student_sage check(sage&lt;150 and sage&gt;0)</p><p>   alter table student drop  constraints ck_student_sage; </p><p>   –添加检查约束校验性别</p><p>​    alter table student add constraints ck_student_ssex check(ssex&#x3D;’男’ or ssex&#x3D;’女’)</p><p>​    alter table student drop  constraints ck_student_ssex; </p><p>​    –添加唯一约束</p><p>​    alter table student add constraints un_student_sqq unique(sqq)</p><p>​    select * from student</p><p>​    drop table student</p><p>外键约束学习：所谓外键约束就是这个约束是依附在其他表上面的，与其他表产生关系）</p><p>日常写法：</p><p>create table student(</p><p>​    sno number(12) primary key,</p><p>​    sname varchar2(100) not null,</p><p>​    sage number(10) check(sage &gt; 0 and sage &lt; 150),</p><p>​    ssex varchar2(10) check(ssex &#x3D; ‘男’ or ssex &#x3D; ‘女’),</p><p>​    sbirth date,</p><p>​    sfav varchar2(500),</p><p>​    sqq number(10) unique,</p><p>​    sid number(12) </p><p>​    </p><p>)</p><p>drop table student</p><p>select * from student</p><p>insert into student values(1,’张三01’,23,’男’,to_date(‘1998-12-03’,’yyyy-mm-dd’),’唱歌’,2359600717,1);</p><p>insert into student values(2,’张三02’,23,’男’,to_date(‘1998-12-03’,’yyyy-mm-dd’),’唱歌’,2359600714,2);</p><p>insert into student values(3,’李四01’,23,’男’,to_date(‘1998-12-03’,’yyyy-mm-dd’),’唱歌’,2359600712,2);</p><p>insert into student values(4,’李四02’,23,’男’,to_date(‘1998-12-03’,’yyyy-mm-dd’),’唱歌’,2359600715,2);</p><p>insert into student values(5,’李四03’,23,’男’,to_date(‘1998-12-03’,’yyyy-mm-dd’),’唱歌’,2359600716,3);（这里插入3班不会产生错误）</p><p>创建班级表</p><p>create table clazz(</p><p>​      cno number(10) primary key,</p><p>​      cname varchar2(100) not null,</p><p>​      cdesc varchar2(300)</p><p>​    </p><p>)</p><p>insert into clazz values(1,’java高级编程’,’一班’);</p><p>insert into clazz values(2,’java中级编程’,’二班’);</p><p>查询信息：</p><p> select * from student  s</p><p> inner join clazz c</p><p> on s.cno&#x3D;c.cno</p><p> –问题:竟然可以在学生表中插入一个不存在班级，这是不符合常理的</p><p>   insert into student values(5,’李四003’,18,’男’,’唱歌’,’657889905’,3);（即三班是不存在的，但是在插入学生数据的时候是可以插入进去的）</p><p> –解决方法：使用外键:</p><p>   –作用：<strong>当在子表中插入的数据在父表中不存在，则会自动报错</strong><strong>，<strong><strong>这样可以依靠父表约束插入的学生信息</strong></strong>。</strong></p><p>   –概念：当一张表的某个字段的值需要依赖另外一张表的某个字段的值，则使用外键约束。</p><p>​       –其中主动依赖的表称为子表，被依赖的表称为父表。外键加在子表中。</p><p>   –使用： </p><p>​       –第一种方法：在子表中的字段后直接使用  references 父表名(字段) 例如： sid number(10) references clazz(cno)</p><p>​       –第二种方法：在创建表语句的最后面使用  constraints fk_子表名_字段名 foreign key(字段名) references 父表名(字段名)</p><p>​       –第三种方法：在创建表后使用：alter table 表名 add constraints fk_子表名_字段名 foreign key(字段名) references 父表名(字段名)</p><p>​      –删除外键：alter table 表名 drop constraints 外键约束名</p><p>外键的代码展示  </p><p>–创建学生表</p><p>  create table student(</p><p>​     sno number(10) primary key,</p><p>​     sname varchar2(100) not null,</p><p>​     sage number(3) check(sage&gt;0 and sage&lt;150),</p><p>​     ssex char(4) check(ssex&#x3D;’男’ or ssex&#x3D;’女’),</p><p>​     sfav varchar2(500),</p><p>​     sqq varchar2(30) unique,</p><p>​     cid number(10) –references clazz(cno)（这是就是使用了外键）</p><p>​     –constraints fk_student_cid foreign key(cid) references clazz(cno)–外键使用的第二种方式</p><p>   )</p><p>   –添加外键第三种方式</p><p>   alter  table student add constraints fk_student_cid foreign key(cid) references clazz(cno) on delete set null（级联删除）</p><p>   alter  table student drop constraints fk_student_cid </p><p>   drop table student</p><p>   –添加测试数据</p><p>   insert into student values(1,’张三001’,18,’男’,’唱歌’,’657889900’,1);</p><p>   insert into student values(2,’张三002’,18,’男’,’唱歌’,’657889901’,1);</p><p>   insert into student values(3,’李四001’,18,’男’,’唱歌’,’657889903’,2);</p><p>   insert into student values(4,’李四002’,18,’男’,’唱歌’,’657889904’,3);（这里再插入学生数据时就会报错，因为再父表中不存在编号为3的班级）</p><p>  –创建班级表</p><p>   create table clazz(</p><p>​    cno number(10) primary key,</p><p>​    cname varchar2(100) not null,</p><p>​    cdesc varchar2(300)</p><p>   )</p><p>   –添加测试数据</p><p>​    insert into clazz values(1,’java高薪就业班’,’6666’);</p><p>​    insert into clazz values(2,’python高薪就业班’,’33333’);</p><p> –查询学生及其班级信息</p><p>   select * from student  s</p><p>   inner join clazz c</p><p>   on s.cno&#x3D;c.cno</p><p>   –外键选取：</p><p>​      –一般选取父表的主键作为子表的外键。</p><p>   –外键的缺点：</p><p>​      –无法直接删除父表数据（但是可以直接删除子表数据），除非级联删除（所谓级联删除就是父表删除的同时将子表也一并删除）</p><p>​      –级联删除：在添加外键约束时，使用关键字 on delete cascade</p><p> –作用：当删除父表数据时，自动删除子表相关所有数据。</p><p> –缺点：无法保留子表历史数据。</p><p> –解决办法：使用关键字 on delete set null</p><p> –作用：删除父表数据时，将子表中的依赖字段的值设置为null，而不是将子表一并删除。注意：子表依赖字段不能添加非空约束，如果字段设置为非空约束，那么级联删除也没有作用了。</p><p>–删除班级1的信息</p><p>​      delete from clazz where cno&#x3D;1 </p><h3 id="二维表的维护"><a href="#二维表的维护" class="headerlink" title="二维表的维护"></a>二维表的维护</h3><p>  –添加新的字段:</p><p>​    –alter table 表名 add 字段名 类型</p><p>​    –alter table student add sphone number(11)–在学生表中添加新的字段</p><p>  –修改原有字段</p><p>​     –修改字段类型</p><p>​      –alter table 表名 modify 字段名 新的类型</p><p>​      –alter table  student modify sphone varchar2(11)</p><p>​     –修改字段名</p><p>​       –alter table 表名 rename column 字段名 to 新的字段名</p><p>​     –删除字段</p><p>​       –alter table 表名 drop column 字段名</p><p>  –修改表名</p><p>​     –rename 原有表名 to 新的表名</p><p>​     rename student to student2</p><p>  –删除表</p><p>​    –drop table 表名</p><h3 id="oracle的序列的学习"><a href="#oracle的序列的学习" class="headerlink" title="oracle的序列的学习"></a>oracle的序列的学习</h3><p>  –创建序列</p><p>   –使用 create sequence 序列名</p><p>   –特点1：默认开始是没有值的，也就是指针指在了没有值的位置。</p><p>   –特点2：序列名.nextval每次执行都会自增一次，默认步长为1</p><p>   –特点3：序列名.currval查看当前序列的值。开始是没有值的。</p><p>   –作用：作为主键使用,动态的获取之间的值，这样新增数据的时候极大的避免了主键冲突</p><p>​      –使用的是 序列名.nextval作为主键</p><p>   –注意：主键是非空唯一就可以，不需要主键的值是连续的值。</p><p>​      –创建默认序列</p><p>​       create sequence cc;–创建序列cc</p><p>​       select cc.currval from dual–查看序列当前值</p><p>​       select cc.nextval from dual–查看序列的自增后的值。</p><p>​      –创建自定义序列</p><p>  重点： create sequence aa start with 5 （设置开始位置，默认从0开始）increment by 2 （设置步长，即每次增加的长度）</p><p>select aa.currval from dual </p><p>​       select aa.nextval from dual</p><p>​    –创建测试表</p><p>​      create table teacher(</p><p>​      tid number(10) primary key,</p><p>​      tname varchar(100) not null</p><p>​      )</p><p>​      insert into teacher values(cc.nextval,’张三’);</p><p>​      insert into teacher values(cc.nextval,’张三’);</p><p>​      </p><p>​      select * from teacher（这样使用序列作为主键，就不会出现添加重复的数据）</p><p>  –删除序列</p><p>​      –drop sequence 序列名</p><p>​      drop sequence aa</p><h3 id="索引学习："><a href="#索引学习：" class="headerlink" title="索引学习："></a>索引学习：</h3><p>   –作用：提升查询效率，再我们创建表的过程中，系统已经自动通过主键建立了索引，这样我们查询的速度就会加快，系统底部采用的算法是二分法进行查找，但是我们不能通过操作数据库显示出效果，只有在处理大量数据的时候才会看出效果，当我们在进行查找或者筛选等动作时，系统就是使用的该算法进行查找。</p><p>   –使用索引：</p><p>​     –创建（使用指定的字段进行查找工作，而不是使用系统指定的字段）</p><p>​      create index 索引名 on 表名(字段名)</p><p> create index index_teacher_tname on teacher(tname)–创建索引 </p><p>​     –删除索引</p><p>​      drop index 索引名</p><pre><code>drop index index_teacher_tname--删除索引</code></pre><p>select * from teacher where tname&#x3D;’张三’</p><pre><code>elect * from teacher where tid=8</code></pre><p>   –特点：</p><p>​     –显示的创建，隐式的执行</p><p>   –注意：</p><p>​     –oracle会自动给表的主键创建索引。</p><h3 id="视图学习"><a href="#视图学习" class="headerlink" title="视图学习:"></a>视图学习:</h3><p>​     –创建视图</p><p>​     create view 视图名 as select 对外提供的内容 from 真实表名</p><p>​     –删除视图</p><p>​     drop view 视图名</p><p>   –视图特点：管理员可以隐藏一些重要的字段，而只给程序员一些需要操作的字段，普通程序员是看不见这些隐藏的字段的，所以无法进行操作，这样可以隐藏数据。</p><p>​     –特点1：保护真实表，隐藏重要字段的数据。保护数据。</p><p>​     –特点2：在视图中的操作会映射执行到真实表中</p><p>​     –特点3：可以手动开启只读模式 使用关键字 with read only</p><p>   –注意：视图的创建必须拥有dba权限</p><p>   create view stu as select sno,sname,sage from  bjsxt.student</p><p>   create view stu2 as select sno,sname,sage from  student with read only（设置视图为只读格式） </p><p>–删除视图操作：drop view stu</p><p>​    select * from student</p><p>   select * from stu</p><p>   对视图中的字段进行更改时，原表中对应的字段也会更改update stu2 set sname&#x3D;’wollo’ where sno&#x3D;1</p><p>   grant dba to bjsxt</p><p>–6.找出部门10中所有经理(MANAGER),部门20中所有办事员(CLERK),既不是经理又不是办事员但其薪金大于或等于2000的所有员工的详细资料.</p><p>select * from emp where (job&lt;&gt;’MANAGER’ and job&lt;&gt;’CLERK’ and sal &gt;&#x3D; 2000) or(deptno&#x3D;10 and job&#x3D;’MANAGER’) or (deptno&#x3D;20 and job&#x3D;’CLERK’)</p><p>–7.找出收取佣金的员工的不同工作.</p><p>select distinct job from emp where comm is not null</p><p>–8.找出不收取佣金或收取的佣金低于100的员工.</p><p>select * from emp where comm is null or comm&lt;100</p><p>–13.显示不带有”R”的员工的姓名.</p><p>select * from emp where ename not like ‘%R%’;</p><p>-————————————————————————–</p><p>–1.列出所有雇员的姓名及其直接上级的姓名</p><p> select e1.ename,e2.ename from emp e1 inner join emp e2</p><p> on e1.mgr&#x3D;e2.empno</p><p>–2.列出部门名称和这些部门的雇员,同时列出那些没有雇员的部门;</p><p> select * from emp e</p><p> right join dept d</p><p> on e.deptno&#x3D;d.deptno</p><p>–3.显示所有部门在”洛阳”(dept表 loc字段)的员工姓名</p><p> select * from emp e</p><p> inner join dept d</p><p> on e.deptno&#x3D;d.deptno</p><p> inner join city c</p><p> on d.loc&#x3D;c.cid</p><p> where c.cname&#x3D;’洛阳’</p><p>–4.显示员工”WARD”的姓名，部门名称</p><p>select e.ename,d.dname from emp e</p><p>inner join dept  d</p><p>on e.deptno&#x3D;d.deptno</p><p>where e.ename&#x3D;’WARD’</p><p>–5.显示员工姓名，部门名称，工资，工资级别(salgrade表 grade字段),要求工资级别大于4级</p><p>select * from emp e </p><p>inner join dept d</p><p>on e.deptno&#x3D;d.deptno</p><p>inner join salgrade s</p><p>on e.sal&gt; &#x3D;s.losal and e.sal&lt;&#x3D;s.hisal</p><p>where s.grade&gt;4</p><p>–6.显示员工”KING”和”FORD”管理的员工姓名及其经理姓名</p><p> select * from emp e1</p><p> full join emp e2</p><p> on e1.mgr&#x3D;e2.empno</p><p> inner join emp e3</p><p> on e1.empno&#x3D;e3.mgr</p><p> where e1.ename&#x3D;’KING’ or e1.ename&#x3D;’FORD’</p><p>–7.显示员工名，参加工作时间，经理名，参加工作时间：参加工作时间比他的经理早</p><p>select e1.ename,e1.hiredate,e2.ename,e2.hiredate from emp e1</p><p>inner join emp e2</p><p>on e1.mgr&#x3D;e2.empno</p><p>where e1.hiredate&lt;e2.hiredate</p><p>–8、分别求出部门名称中，带’S’字符的部门员工的工资总和 、部门人数</p><p>select d.dname, sum(e.sal),count(*) from emp e</p><p>inner join dept d</p><p>on e.deptno&#x3D;d.deptno</p><p>where d.dname like ‘%S%’</p><p>group by d.dname</p><p>–9、列出所有员工的年工资，按年薪从低到高排序</p><p>select ename,(sal+nvl(comm,0))*12 年薪 from emp order by 年薪</p><p>–10、列出各种工作的最低工资以及从事此工作的雇员姓名</p><p>select * from emp e ,(select min(sal) msal,job from emp group by job) s where e.job&#x3D;s.job and e.sal&#x3D;s.msal</p><p>–11、列出所有部门的详细信息和部门人数</p><p>select * from dept d ,(select d.deptno, count(empno) from emp e,dept d where e.deptno(+)&#x3D;d.deptno group by d.deptno) s</p><p>where d.deptno&#x3D;s.deptno</p><p>第二种方式：select * from dept d,(select e.deptno, count(*) from emp e  group by deptno ) s where d.deptno &#x3D; s.deptno  ;（这种方式用于处理怎样将多行函数和普通字段同时显示出来，就是将它俩再重新进行组表，并判断之后选取）</p><p>–12、列出所有员工的姓名、部门名称和工资</p><p>select e.ename,d.dname,e.sal from emp e</p><p>inner join dept d</p><p>on e.deptno&#x3D;d.deptno</p><p>–13、查询员工信息： 员工的名字 老板的名字  </p><p>select e.ename,m.ename from emp e,(select * from emp where mgr is null) m</p><p>–14、要求查询出每一个雇员的编号、姓名、工资、部门名称、工资在所在公司的工资等级 </p><p>–15、按照职位分组，求出每个职位的最高工资、最低工资以及平均工资 </p><p>select job,max(sal),min(sal),avg(sal) from emp group by job</p><p>–16、统计平均工资大于2000的部门的详细信息</p><p>select * from dept d,(select deptno, avg(sal) asal from emp group by deptno) s</p><p>where d.deptno&#x3D;s.deptno and s.asal&gt;2000</p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/wps62AD.tmp.jpg" alt="img"> </p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/wps62AE.tmp.jpg" alt="img"> </p><p>—创建Employees</p><p>create table Employees(</p><p>​    employeeID varchar2(6) primary key,</p><p>​    ename varchar2(10) not null,</p><p>​    Birthday date not null,</p><p>​    sex char(4) not null,</p><p>​    address varchar2(20) ,</p><p>​    zip varchar2(6),</p><p>​    Phonenumber varchar2(12),</p><p>​    Emailaddress varchar2(30),</p><p>​    departmentID varchar2(3) not null</p><p>); </p><p>-————————————————————————–</p><p>  —添加外键约束 </p><p>  alter table Employees add constraints fk_e_d_departtmentID foreign key(departmentID) references Departments(departmentID) </p><p>  alter table Employees add constraints ck_sex check(sex&#x3D;’男’ or sex&#x3D;’女’)</p><p>  alter table Departments add constraints un_departmentName unique(departmentName)</p><p>  —增加字段</p><p>  alter table Employees add qq number(15)</p><p>-———</p><p>  update salary  set  income&#x3D;2890 where employeeID&#x3D;010001</p><p>  update  Departments set departmentName&#x3D;’生产计划部’ where departmentName&#x3D;’生产部’</p><h3 id="oracle的分页查询"><a href="#oracle的分页查询" class="headerlink" title="oracle的分页查询"></a>oracle的分页查询</h3><p>  –问题：当一个表中的数据量特别大的时候，如果一次性全部显示给用户，则造成页面过于庞大，体验极差。</p><p>  –解决：使用分页查询</p><p>  –使用：</p><p>   –rownum关键字：oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系。（即会增加一个rownum字段，按照从1开始递增，但不是插入的数据），</p><p>​    –注意：rownum关键字只能做&lt; 和 &lt;&#x3D;的判断，不能进行&gt; 和 &gt;&#x3D;的判断，因为每次执行完rownum筛选完之后，rownum都会自动又从1开始排序，而不是按照原来的数字进行排序</p><p>   select rownum ,e.* from emp e;</p><p>   –查询员工信息的前5条数据 第一页数据</p><p>   select rownum r,e.* from emp e where rownum &lt;&#x3D;5;</p><p>   select * from (select rownum r,e.* from emp e where rownum &lt;&#x3D;5) t where r&gt;0;</p><p>   –查询员工信息的6-10条数据 第二页数据（但是在显示的时候rownum列显示的仍然是1-5，但是实际查询的数据是6-10的数据）</p><p>   select rownum r,e.* from emp e where rownum &lt;&#x3D;10;</p><p>   select rownum,t.* from (select rownum r,e.* from emp e where rownum &lt;&#x3D;10) t where r&gt;5;</p><p>   –查询员工信息的11-15条数据 第三页数据</p><p>   select rownum r,e. * from emp e where rownum&lt;&#x3D;15;</p><p>   select * from (select rownum r,e. * from emp e where rownum&lt;&#x3D;15) t where r&gt;10;</p><p>   –分页规律总结：每页显示m条数据，查询第n页数据</p><p>   select * from (select rownum r,e. * from 要分页的表 e where rownum&lt;&#x3D;m<em>n) t where r&gt;m</em>n-m ;</p><p>​       –要分页的表既可以是真实的表，也可以是一个查询语句（实际上查出来的数据也是一个表）</p><p>   –分页查询员工信息按照工资排序</p><p>   select * from (select rownum r,t.* from (select * from emp  order by sal) t where rownum&lt;&#x3D;10 ) where r&gt;5</p><p>数据库备份</p><p><img src="/2026/01/29/%E6%95%B0%E6%8D%AE%E5%BA%93/assets/wps62BF.tmp.jpg" alt="img"> </p><p>使用PL&#x2F;SQL Developer导入&#x2F;出数据</p><p>Oracle Export&#x2F; Oracle Import</p><p>扩展名dmp</p><p>使用的就是exp&#x2F;imp命</p><p>Mysql连接bjsxt</p><p>账户名root</p><p>密码 123546</p><h3 id="mysql创建数据库"><a href="#mysql创建数据库" class="headerlink" title="mysql创建数据库"></a>mysql创建数据库</h3><p>​1：使用命令需按照abc三个步骤来进行</p><p>​create database 库名 default character set utf8;</p><p>​例：create database wollo default character default charater set utf8;</p><p>​ c：切换数据库到库名（否则会默认在a步骤打开的数据库中进行操作）</p><p>​use 库名；</p><p>​ 2： 使用图形界面</p><p>​在连接名上 右键–》new database –&gt;弹出新建数据库 –》输入库名 –&gt; 选择utf-8，点击ok</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>​ 使用命令</p><p>​b:drop database 库名</p><p>​ 使用图形界面</p><p>​选择要删除的库右键进行删除</p><h3 id="mysql语句"><a href="#mysql语句" class="headerlink" title="mysql语句"></a>mysql语句</h3><p>##创建表语句</p><p>create table student(</p><p>​sid int(10) not null auto_increment primary key,   ##auto_increment表示这个主键是自增的</p><p>​sname varchar (100) not null,##这里不是varchar2（）</p><p>​sage int(3) ,  ##MySQL中不再有number类型</p><p>​ssex char(4),  </p><p>​sbirth date</p><p>)</p><p>##增加字段</p><p>alter table student add money float;</p><p>##添加数据</p><p>insert into student values(default ,’张三’,16,’男’,’2018-10-12’,9000);##这里default就是使用了默认的主键</p><p>insert into student values(default ,’张三’,18,’a’,’2019-04-26’,6666)</p><p>##测试数据</p><p>select * from student</p><p>删除数据</p><p>delete from 表名 条件语句 (注意在Oracle中from是可以省略的而 在MySQL中是不能省略的)</p><p>注意：主键自增在创建表的字段后，使用auto_increment</p><h3 id="MySQL常见类型"><a href="#MySQL常见类型" class="headerlink" title="MySQL常见类型"></a>MySQL常见类型</h3><p>​数值类型：</p><p>​   int（长度）:表示整数类型的数据 （长度最大为10）</p><p>​   float&#x2F;doubel:表示浮点数</p><p>​ 字符类型</p><p>​   varchar（长度）:动态分配储存长度</p><p>​  char（长度）:分配固定长度</p><p>​日期类型</p><p>​   date：格式为yyyy-mm-dd</p><p>​   datetime：格式为yyyy-MM-dd hh：mm：ss (占用8个字节)</p><p>​   timestamp;特点：会自动进行时区的转换 占用四个字节</p><p>​           time：时间</p><p>​   year:年份</p><p>约束：<a href="https://blog.csdn.net/a909301740/article/details/62887992">https://blog.csdn.net/a909301740/article/details/62887992</a></p><p>主键约束</p><p>​在创建表示在字段后面使用primary key即可（这是最常用的方法，下面的两种方法作为了解即可）   </p><p>在创建表语句的最后面使用 constraint 约束名 primary key(主键字段名)</p><p>在创建表后使用alter table 表名 add constraint 约束名 primary key(约束名)</p><p>非空约束</p><p>在创建表的时候直接在字段后使用not null 即可</p><p>在创建表后面使用contraint 表名 not null</p><p>在创建表后使用alter table 表名 modify 字段名 类型 not null</p><p>注意：MySQL 的非空约束中空字符是可以存储进去的</p><p>检查约束</p><p>问题：在mysql 中是没有检查约束的，但是使用check关键字又不会报错</p><p>解决：</p><p>使用代码逻辑进行无效数据的过滤，即实际上不能进行过滤</p><p>唯一约束 </p><p>在字段名后直接使用unque即可(最常用)</p><p>在创建表的语句最后面使用 contraint 约束名 unique key(字段名)</p><p>在创建表后使用：alter table 表名 add constraint 约束名unique key(字段名)</p><p>外键约束</p><p>在字段名直接使用 referances 父表名（父表主键名）</p><p>在创建表的语句的后面使用contranint 外键约束名 foreign key(字段名) references 父表名（父表主键名）</p><p>在创建表之后 atler table 表名 add constraint 外键约束名 foreign(字段名) references 父表名（父表主键名）</p><p>表的修改与删除（凡是修改的话都是用到的alter into）</p><p>添加字段</p><p> alter into 表名 add 字段名 类型</p><p>删除字段</p><p>alter into 表名 drop 字段名</p><p>修改字段类型</p><p>alter into 表名 modify 字段名 新的类型</p><p>修改字段名</p><p>alter into 表名 change 字段名 新的字段名 类型 （注意在Oracle中使用的是 rename而不是change）</p><p>修改表名</p><p>alter into 表名rename as 新的表名</p><p>删除表</p><p>drop table 表名</p><p>展示所有表</p><p>Show tables </p><p>显示创建表语句</p><p>Show create table 表名</p><p>显示数据库</p><p> Show datebases</p><p>单表查询</p><p>别名：直接空格在字段后使用即可</p><p>去除 重复：使用distinct即可</p><p>连接符： 使用concat（字段名，字段名）（注意在MySQL中连接符不是使用的||符号）</p><p>排序：参照Oracle</p><p>Where语句：参照Oracle</p><p>函数 参照Oracle</p><p>having 参照Oracle</p><p>据库的备份</p><p>使用命令进行备份</p><p>导出数据库 Mysqldump -u root -p 数据库名 &gt;dbname_sql</p><p>导入数据库 mysql &gt; source 文件的路径名</p><p>使用图形化界面进行备份</p><p>直接导出和导入</p><h3 id="MySQL的分页"><a href="#MySQL的分页" class="headerlink" title="MySQL的分页"></a>MySQL的分页</h3><p>使用关键字limit</p><p>Select * from student limit 0,2 ##表示查询1-2的数据</p><p>select *from student limit 0,3  ##表示查询 1-3的数据</p><p>select * from student limit 3,7 ##表示查询4-7的数据</p><p>select * from student limit 7,16 ##表示查询8-16的数据</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/2026/01/29/%E5%89%8D%E7%AB%AF/"/>
      <url>/2026/01/29/%E5%89%8D%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>HTML是用来构建网页的结构的（骨架），而css是用来构建样式的（外貌）。</p><p>标签之间只有两种关系，1.嵌套关系2.并列关系</p><p>head和body之间是并列关系，head标签和title之间是嵌套关系</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;!--网页解析编码格式配置(HTML5):告诉浏览器使用指定的编码格式解析文档--&gt;</span><br><span class="line"></span><br><span class="line">&lt;metahttp-equiv=&quot;content-type&quot;content=&quot;text/html;charset=utf-8&quot;/&gt;&lt;!--HTML4:文档编码格式设置--&gt;</span><br><span class="line">&lt;metaname=&quot;keywords&quot;  content=&quot;HTML,SXT,张老师,506&quot;/&gt;&lt;!--网页关键字当在搜索该关键字时就会出现该网页--&gt;</span><br><span class="line">&lt;metaname=&quot;description&quot;  content=&quot;本网页上是关于HTML的head标签学习的,特别棒,6666.&quot;/&gt;&lt;!--网页描述--&gt;</span><br><span class="line">&lt;metaname=&quot;author&quot;content=&quot;张老师&quot;/&gt;&lt;!--网页作者--&gt;</span><br><span class="line">网页指定跳转标签:</span><br><span class="line">&lt;metahttp-equiv=&quot;refresh&quot;  content=&quot;5;url=http://www.baidu.com&quot;/&gt;&lt;!--5秒后自动跳转到百度网页--&gt;</span><br></pre></td></tr></table></figure><h2 id="标签学习"><a href="#标签学习" class="headerlink" title="标签学习"></a>标签学习</h2><p>​1.块元素(盒子)：（自己独占一行，里面可以放行内元素或者块元素，高度和宽度可以在里面设置）,：div，h1，p，ul，ol，li等，但是文字类元素里面不能放块元素；</p><p>​2.行内元素（相邻行内元素在一行，一行可以显示多个，设置宽和高是无效的）：a，strong，b，em，i，del，s，ins，u，span等</p><p>​3.行内块元素：行内元素一行可以显示多个，可以设置宽度和高度：img，input，td</p><p>《P》《&#x2F;P》标签：段落标签，将文字分成段落形式</p><p>《br&#x2F;》（单标签）：换行标签</p><p>《strong》或者b:加粗</p><p>《em或者i》：倾斜</p><p>《del或者s》：删除线</p><p>《ins或者u》：下划线</p><p>《div》：就是一个盒子，目的是将所有的元素都变成矩形，因为前端可能出现各种形状，所以为了方便干脆直接将所有的元素标签都放在盒子里，通过操作盒子进行也行页面设计。上面1中的各种块元素实际上就是一个一个的盒子所以div与1中的块元素是同级的关系，盒子与盒子之间可以分离，也可以嵌套，保持矩形形状才是盒子的重点。还一个原因就是为盒子规定了下面的四个属性，进而可以方便调整位置，div的特点是自带换行，即一个div默认占一行，但设置float后，div会根据内容的大小自动调整</p><p>​div的四个属性：</p><p>​外边距:margin 作用：用来设置盒子和盒子之间的间隔。</p><p>​居中设置:margin:0px auto;上下间隔是0px,水平居中。</p><p>​边框：border  作用：用来设置元素的边框大小</p><p>​内边距：padding，也叫间隙  作用：设置内容和边框之间的距离</p><p>《span》：也是一个盒子，一行可以放多个span</p><p>《img  》：单标签属性src：路径  alt：图像无法显示时出现的文本，title：提示文本，width：宽度，height：高度，border：边框</p><p>《a》：超链接标签《a href&#x3D;”跳转目标” target&#x3D;”弹出方式“》《&#x2F;a》。</p><p>锚点连接，当页面过长时，快速跳转到想要的地方是哟ing锚点连接：《a href&#x3D;”#two”》第二季《&#x2F;a》连接目标地址前需加#，《h1 id&#x3D; ”two“》第二季介绍《h1》：目标地址属性必须加上id，这样可以快速定位</p><p>《table》《&#x2F;table》:表格标签</p><p>​《thead》:表头标签，将某一行设置为表头，在table内，tr外面</p><p>​《tbody》:表格体标签，也是在table内，tr外</p><p>​《tr》：行标签，必须嵌套在table中</p><p>​</p><p>​《td》：列标签：必须嵌套在tr中</p><p>​colspan属性：跨列合并，并且删掉多余的单元格</p><p>​rowspan属性：跨行合并，并且删掉多余的单元格</p><p>​《th》：表头标签：相当于表格中的标题标签，但是放在tr中，与td是同级的。相当于对td进行了居中加粗</p><p>table的属性：1.align：（left，right，center）对齐方式，</p><p>​border：1或空：  边框</p><p>​cellpadding：单元边与内容之间的空隙</p><p>​cellspacing:单元之间的空隙</p><p>​width：表格的宽度</p><p>《ul》：无序列表</p><p>​《li》：内容</p><p>《ol》：有序列表</p><p>​《li》：内容</p><p>《form》：表单标签</p><p>表单里面的控件：1.《input  type&#x3D;”” name&#x3D; “”  value&#x3D;”” checked&#x3D;”checked“  maxlength&#x3D;”“》type的类型有button，checkbox（复选），file，hidden，image，password，radio（单选），reset，submit，text。value属性就是是传递给后台的数据，input框value值与输入的数据一样，但是option标签中的value与文本可以不一样，不一样的原因是若文本发生变化，传递给后台的数据可以不变（《option value&#x3D;”al”》alabama《&#x2F;option》）。checked属性是默认选择的按钮 ，maxlength规定最大长度。submit按钮：当点击提交按钮的时候就会将表单中的数据提交上去。reset按钮点击时会自动清除表单里面的所有元素。button按钮不提交任何数据，就是一个普通按钮，需与js配合使用。file按钮，提供文件上传</p><p>​2.《select 》：下拉列表</p><p>​《option》：选项</p><p>​3.《textarea rows&#x3D;“3” cols&#x3D;“20”》：多行文本，大小用rows和cols确定</p><p>注意，若是需要上传文件，必须在form表单中填写entype&#x3D;multipar&#x2F;form-data属性，同时后端定义的文件类型则是IFormFile接口，若是多个文件则使用LIst《IformFile》</p><p>《label》：标签</p><p>表单的属性：action：url地址</p><p>​method：提交方式</p><p>​name：名称</p><p>​</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>CSS可以给所有标签都更改样式，他的属性只属于CSS而不属于某个固定的标签</p><p>​CSS声明:三种方式</p><p> 1、在head标签中使用style标签声明：其实该style语法可以任何地方写在head中只是为了观看方便</p><p>作用：此声明一般声明当前网页的公共样式或者给某个标签的单独样式该声明解决了同一个网页中重复的样式问题</p><p>2、在标签上使用style属性进行声明：</p><p>​作用：此声明会将css样式直接作用于当前标签。</p><p>选择器：就是HTML标签 ，css使用是使用键值对的方式 例color:red;</p><h2 id="css的选择器学习："><a href="#css的选择器学习：" class="headerlink" title="css的选择器学习："></a>css的选择器学习：</h2><p>​1.标签选择器：例 div{color：red }</p><p>​作用：会将当前网页内的所有该标签增加相同的样式</p><p>​2.id选择器:每个标签只能有一个不同的id，id标签与类选择器的最重要的区别就是这个</p><p>​作用：给某个指定的标签添加指定的样式例#per {color:red}</p><p>​3.类选择器class：每个标签可以有相同的类选择器</p><p>​作用：给不同的标签添加相同的样式 例  .member{color:red}</p><p>​4.全部选择选择器</p><p>​作用：选择所有的HTML标签，并添加相同的样式例*{color：red}</p><h2 id="css的各种属性"><a href="#css的各种属性" class="headerlink" title="css的各种属性"></a>css的各种属性</h2><p>边框设置:border:solid 1px;</p><p>字体设置:</p><p>​font-size:10px;设置字体大小</p><p>​font-family:”黑体”;(设置字体的格式)</p><p>​font-weight：bold|normal| bolder|lighter|数值  设置字体加粗</p><p>​Font-style:normal|italic  正常字体&#x2F;斜体</p><p>字体颜色设置:color:颜色;</p><p>背景颜色设置:background-color:颜色;</p><p>背景图片设置</p><p>​background-img:url(图片的相对路径);</p><p>​background-repeate:no-repeate;设置图片不重复</p><p>​bacground-size:cover;图片平铺整个页面</p><p>浮动设置:float:left|right</p><p>行高设置:line-height:10;</p><p>下划线：text-decoration:line-through</p><p>删除线：text-decoration:line-through</p><p>上划线：text-decoration:overline</p><p>没有线text-decoration:null</p><p>首行缩进：text-indent:10px</p><p>行间距：line-height:36px</p><p>​</p><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h3 id="javascript的作用："><a href="#javascript的作用：" class="headerlink" title="javascript的作用："></a>javascript的作用：</h3><p>1.为了验证前端传递过来的数据，同时也可以使用后端进行验证，主要是为了双重保护，防止绕过</p><p>2.为了给前端做特效</p><h3 id="三种输出方式"><a href="#三种输出方式" class="headerlink" title="三种输出方式"></a>三种输出方式</h3><p>1.alert(“helloworld”);&#x2F;&#x2F;弹框显示</p><p>2.document.write(“helloword”);&#x2F;&#x2F;会输出到body体中，没有修饰标签，直接输出内容</p><p>3.console.log(“helloworld”);&#x2F;&#x2F;输出到浏览器的控制台中</p><h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><p>1.行内直接使用事件：不推荐使用，因为耦合性太强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = &quot;button&quot; value = &quot;按钮&quot; onclick =&quot;alert(&quot;helloword&quot;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>2.写在script标签中：（推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;helloworld&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>3.引入外部文件（最佳方式），如果引入外部文件，就不能再改script标签中写其他代码，解决方法是再创建一个新的script标签，然后写js代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script srt = &quot;main.js&quot;&gt;&lt;/script&gt;//外部</span><br><span class="line">&lt;script&gt;alert(&quot;我是内部js代码&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="js的数据类型及常用方法"><a href="#js的数据类型及常用方法" class="headerlink" title="js的数据类型及常用方法"></a>js的数据类型及常用方法</h2><p>number:数值类型，不要判断两个浮点数是否相等</p><p>string:字符串类型,注意：单引号和双引号都代表字符串类型。</p><p>boolean:布尔类型</p><p>object:对象类型</p><p>null：空</p><p>只声明未赋值的类型为Undefined</p><p>null 实际上是object类型</p><p>undefined 实际上是undefined类型</p><p>NaN 实际上是number类型</p><p>使用Number()函数：将其他数据类型转换为数值类型，转换失败返回NaN(not a number)</p><p>使用Boolean()函数：将其他数据类型转换为布尔类型即有值的话就返回true，无值的话就返回false</p><p>if(num){}&#x2F;&#x2F;判断num变量中是否有数据</p><p>parseInt(“123abc”):结果为123,从从变量往后寻找，到第一个非数字截止返回</p><p>循环的一种方式for(var key in arr){}；其中key表示的是数组的下标，如果arr表示的类对象，则key代表的是对象的属性</p><p>typeof(obj);用来判断obj的数据类型。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​数组的操作学习：</p><p>​1、数组的合并返回的仍然是该数组对象：arr.concat(b,c);&#x2F;&#x2F;数组的合并</p><p>​2、数组指定间隔符转换字符串，并返回该数组字符串:var b&#x3D;arr.join(“-“);用-将数组元素之间隔开</p><p>​3、数组移除最后一个元素并返回该元素:var ele&#x3D;arr.pop();</p><p>​4、数组的添加，在数组的末尾添加该元素，返回新的长度：var ln&#x3D;arr.push(“lol”);&#x2F;&#x2F;添加加的元素可以是一个数组，但是为作为一个角标值存在</p><p>​5、数组的移除第一个元素并返回数组字符串:var ele&#x3D;arr.shift();</p><p>​6、数组的在开始位置插入指定元素并返回该数组的长度:var a&#x3D;arr.unshift(“又是周五了”);</p><p>​7、数组删除指定位置元素返回的是整个数组对象splice(start,count,)第一个参数为开始索引，第二个参数为删除的数量：var arr2&#x3D;arr.splice(1,3,”a”);第三个参数及以后表示替换之前删除元素的位置</p><p>​8、用来提取指定位置的元素 slice(start,end);截取开始索引位置到结束位置的数组，包含start，但是不包含end，可以为负数，  表示从后往前截取</p><p>​</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1、函数的声明：</p><p>​方式一:function 函数名(形参名1,形参名2……){执行体}</p><p>​方式二:（类似c#中的委托）var 函数名&#x3D;new Function(“形参1”,”形参2”……,”函数执行体”);函数执行体放在参数的最后面注意：此声明表明在js中函数是作为对象存在的。（不推荐）</p><p>第二种方式中函数名存取的实际上是function对象值，该对象值存取了方法的所有信息，类似于反射中，Method类存取了所有方法的全部信息，同时它也是function的函数名</p><p>方式三:var 变量名&#x3D;function(形参名1,形参名2……){函数执行体}</p><p>推荐第一种方式和第三种方式。</p><p>2、函数的参数</p><p>​js中的函数在调用时，形参可以不赋值，不会报错，因为默认值是undefined</p><p>​js中的函数在调用时，形参赋值可以不全部赋值，不会报错，但是实参会依次进行赋值。</p><p>3、函数的返回值</p><p>​在js中如果函数有返回值则直接返回，没有返回值默认返回undefined</p><p>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1、函数的执行符</span><br><span class="line"></span><br><span class="line">​var test1=function()&#123;</span><br><span class="line"></span><br><span class="line">​alert(&quot;函数的执行符学习&quot;);</span><br><span class="line"></span><br><span class="line">​return &quot;js&quot;;</span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​//alert(test1());返回结果为js</span><br><span class="line"></span><br><span class="line">​//2、函数作为实参进行传递</span><br><span class="line"></span><br><span class="line">​var testParam=function()&#123;</span><br><span class="line"></span><br><span class="line">​alert(&quot;我是函数参数&quot;);</span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​testobj(testParam());//无返回值，因为括号里面调用的是函数</span><br></pre></td></tr></table></figure><p>4.函数的调用：</p><p>​1).函数名();</p><p>​2).函数名.call();或者函数名.apply();</p><p>这两种方式的结果都差不多，区别是第一种方式他的this一定是windows，而第二种方式可以在括号里面传递对象进而修改this </p><h2 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h2><p>第一种方式（一次性使用）：例如var stu&#x3D;{id:1,name:”张三”, show:function(){console.log(this.name+this.id)}},其中对象的类型是object类型。</p><p>var stus &#x3D; [{id:1,name:”张三”},{id:2,name:”李四”}]；</p><p>第二种方式：var obj &#x3D; new Object();obj.id &#x3D;1;obj.name &#x3D; “张三”；obj.show&#x3D;function(){console.log()}</p><p>第三种方式（推荐）：</p><p>function 类名(形参1，形参2……){</p><p>​this.属性名1&#x3D;形参1;</p><p>​this.属性名2&#x3D;形参2;</p><p>​……</p><p>​this.属性名&#x3D;fn&#x2F;&#x2F;fn为一个函数即fn为function（参数1，参数2）{  &#x2F;&#x2F;函数执行代码  }</p><p>​注意：类中的变量可以直接使用，不需要提前声明，因为即使声明也是用var来修饰，所以干脆不用修饰，js中类与方法的区别是类中有this而方法中没有this，且方法中都是执行代码，而类中的代码都是为属性值赋值（类与构造方法写在一起了），同时该类的属性是可以在类的外面进行扩充的。类的使用：var 对象名&#x3D;new 类名(实参1，实参2……);</p><p>第四种方式：在为属性赋值时可以使用另一种方式：var obj &#x3D; new Object(); obj[“test”] &#x3D;789；说明变量为test 值为789；（要能看懂）</p><p>in关键字：判断某对象中是否含有某属性，例如console.log(name in obj);</p><h3 id="类的”继承”：prototype关键字"><a href="#类的”继承”：prototype关键字" class="headerlink" title="类的”继承”：prototype关键字"></a>类的”继承”：prototype关键字</h3><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>js中总共有三种对象</p><p>1.内置对象：String ,Boolean,Number,Function,Object,Math…</p><p>2.宿主对象：由浏览器提供的对象，</p><p>​1.BOM，比如console.log();</p><p>​2.Dom对象，比如document.write();</p><p>3.自定义对象：与java中一样</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是根据函数调用方式的不同而不同，主要看是谁调用了该对象this就指向谁，不要使用c#的语法理解，c#中this只表示当前对象，而js中是指向调用该对象的东西。例如一个Person类中有this.color属性和this.getColor方法</p><p>1.若是在全局范围中调用this，this实际上指的就是windows对象例如Person(“red”)</p><p>2.若是在某个类中调用this，this指的就是该类对象,例如p.getColor();</p><p>3.若是在构造函数调用时，this是新创建的那个对象例如var p &#x3D; new Person(“yellow”);&#x2F;&#x2F;this为p</p><p>4.使用call，apply调用时，this是指定的那个对象p.setColor.call(obj,”black);&#x2F;&#x2F;this为obj</p><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments是一个类数组对象，在调用函数时我们传递的所有实参都会在arguments中保存，所以即使不定义形参，我们也可以获取到实参，方法是arguments[0],arguments[1]。</p><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><p>1.Date:   </p><p>​var d &#x3D; new Date(); console.log(d);&#x2F;&#x2F;获取当前时间</p><p>​var d &#x3D; new Date(“12&#x2F;03&#x2F;2016 11:10:30”); console.log(d);&#x2F;&#x2F;设置指定时间</p><p>​具体的方法参考文档</p><p>字符串常见方法：参考api</p><h2 id="DOM（文档对象模型）"><a href="#DOM（文档对象模型）" class="headerlink" title="DOM（文档对象模型）"></a>DOM（文档对象模型）</h2><p>document:一个网页就是一个document ，object：网页中每个标签，每个标签内中的内容就是一个对象，model：用来描述每个对象之间的关系即节点关系：如下图，每个html，head，body，title，内容都是一个对象（节点），而每个对象之间的关系就是右侧图为包含或者并列的关系，实际上节点就是对象，只不过节点描述了文档结构之间的关系。</p><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220409231643719.png" alt="image-20220409231643719"></p><p>在js中，js将html的每个标签都看为一个子对象，document将html的所有代码封装成一个对象，而每个标签又都是一个子对象，每个标签中的属性类似于每个对象的属性，</p><p>使用document获取HTML元素对象</p><p>​直接获取方式：</p><p>​通过id(缺点是id不能重复)</p><p>​通过name属性值;getElementByTagName(标签名)，getElementByTagName(name的值)（获取表单元素）</p><p>​通过标签名 如果该标签有多个元素，则返回的是该标签对应的数组</p><p>​通过class属性值 同理返回数组</p><p>​间接获取方式：父子关系，子父关系，兄弟关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--声明js代码域--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;img scr = &quot;d:&quot;id=&quot;img1&quot;&gt;</span><br><span class="line">&lt;img name=&quot;img2&quot;&gt;</span><br><span class="line">&lt;img class = “img3&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">​//document获取元素对象</span><br><span class="line">​//id方式</span><br><span class="line">​function testGetEleById()&#123;</span><br><span class="line">​var inp=document.getElementById(&quot;img1&quot;).src=&quot;C:&quot;;</span><br><span class="line">​alert(inp);</span><br><span class="line">​&#125;</span><br><span class="line">​//name方式</span><br><span class="line">​function testGetEleByName()&#123;</span><br><span class="line">​var favs=document.getElementsByName(&quot;img2&quot;);</span><br><span class="line">​alert(favs);</span><br><span class="line">​&#125;</span><br><span class="line">​//标签名</span><br><span class="line">​function testGetEleByTagName()&#123;</span><br><span class="line">​var inps=document.getElementsByTagName(&quot;img&quot;);</span><br><span class="line">​alert(inps);</span><br><span class="line">​&#125;</span><br><span class="line">​//class属性</span><br><span class="line">​function testGetEleByClassName()&#123;</span><br><span class="line">​var inps=document.getElementsByClassName(&quot;img3&quot;);</span><br><span class="line">​alert(inps.length);</span><br><span class="line">​&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//间接获取方式</span><br><span class="line">//父子关系</span><br><span class="line">function testParent()&#123;</span><br><span class="line">//获取父级元素对象</span><br><span class="line">var showdiv=document.getElementById(&quot;showdiv&quot;);</span><br><span class="line">//获取所有的子元素对象数组</span><br><span class="line">var childs=showdiv.childNodes;//获取包含空白文本在内的所有子节点</span><br><span class="line">varchilds = showdiw.children;//只包含子标签</span><br><span class="line">Var child2 = showdiv.getElementTageName(“span”);//获取div下的span标签元素</span><br><span class="line">alert(childs.length);</span><br><span class="line">&#125;</span><br><span class="line">//子父关系</span><br><span class="line">function testChild()&#123;</span><br><span class="line">//获取子元素对象</span><br><span class="line">var inp=document.getElementById(&quot;inp&quot;);</span><br><span class="line">var div=inp.parentNode;</span><br><span class="line">alert(div);</span><br><span class="line">&#125;</span><br><span class="line">//兄弟关系</span><br><span class="line">function testBrother()&#123;</span><br><span class="line">var inp=document.getElementById(&quot;inp&quot;);</span><br><span class="line">var preEle= inp.previousSibling;//弟获取兄</span><br><span class="line">var nextEle=inp.nextSibling;//兄获取弟</span><br><span class="line">alert(preEle+&quot;:::&quot;+nextEle);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js操作表格学习:</span><br><span class="line">1、删除行：</span><br><span class="line">行对象.rowIndex//返回行对象的角标</span><br><span class="line">表格对象.deleteRow(要删除的行对象的角标);</span><br><span class="line">2、修改单元内容</span><br><span class="line">单元格对象.innerHTML=&quot;新的内容&quot;;</span><br><span class="line">行对象.cells//返回当前行所有的单元格对象的数组</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>1.获取元素属性：元素对象名.属性名&#x2F;&#x2F;返回当前属性的属性值。—这是获取标签中的固有属性的方法</p><p>元素对象名.getAttribute(“属性名”);&#x2F;&#x2F;返回自定义属性的值—–自定义，如果使用对象名.属性名的方法获取自定义属性值，则会返回ununitified</p><p>2.获取元素内容：元素对象名.innerHTML&#x2F;&#x2F;返回当前元素对象的所有内容，包括HTML标签，因为标签里面也会有内嵌标签，所以innerHTML也会将内嵌标签名打印出来。</p><p>元素对象名.innerText&#x2F;&#x2F;返回当前元素对象的文本内容，不包括HTML标签，即使有内嵌标签也不会打印内嵌标签的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">例如&lt;button id=”btn1” onclick = “changeImage()”&gt;&lt;/button&gt;//通过标签执行js函数</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Functon changeImage()</span><br><span class="line">&#123;</span><br><span class="line">Console.log(“你好”);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">上面这段代码说明了当执行button按钮中的onclick事件的时候就会执行changeImage函数。如果是普通元素没有onclick事件怎么弄？如下示例</span><br><span class="line">&lt;a href = “” id = “a”&gt;百度&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;a&quot;).onclick=function()&#123;alert(“绑定”)&#125;；//通过这种方式绑定js与html的关系</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">2.通过js获取html</span><br><span class="line">&lt;a href=&quot;&quot; id=&quot;ccc&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;a&quot;).href=&quot;d&quot;;通过js修改a标签中的href属性</span><br><span class="line">document.getElementById(&quot;a&quot;).style.background=&quot;red&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="节点："><a href="#节点：" class="headerlink" title="节点："></a>节点：</h3><p>所谓节点实际上就是对象，子节点就是当前对象的子标签对象，包含空白文本，而子元素不包含文本内容，只是子标签</p><p>div.innerHTML&#x3D;div.innerHTML+”内容” &#x2F;&#x2F;增加节点例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var showdiv=document.getElementById(&quot;showdiv&quot;);</span><br><span class="line">//给div追加上传按钮</span><br><span class="line">showdiv.innerHTML=showdiv.innerHTML+&quot;&lt;div&gt;&lt;input type=&#x27;file&#x27; value=&#x27;&#x27; /&gt;&lt;input type=&#x27;button&#x27; value=&#x27;删除&#x27; onclick=&#x27;delInp(this)&#x27;/&gt;&lt;/div&gt;&quot;;</span><br></pre></td></tr></table></figure><p>div.innerHTML&#x3D;””&#x2F;&#x2F;删除所有子节点</p><p>父节点.removeChild(子节点对象)&#x2F;&#x2F;删除指定的子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">获取元素对象</span><br><span class="line">var obj=document.createElement(&quot;标签名&quot;);</span><br><span class="line">元素对象名.appendChild(obj);</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!--声明js代码域--&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function testOper2()&#123;</span><br><span class="line">//获取元素对象</span><br><span class="line">var  showdiv=document.getElementById(&quot;showdiv&quot;);</span><br><span class="line">//创建input元素对象</span><br><span class="line">var inp=document.createElement(&quot;input&quot;);</span><br><span class="line">inp.type=&quot;file&quot;;</span><br><span class="line">//创建按钮元素对象</span><br><span class="line">var btn=document.createElement(&quot;input&quot;);</span><br><span class="line">btn.type=&quot;button&quot;;</span><br><span class="line">btn.value=&quot;删除&quot;;</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">showdiv.removeChild(inp);</span><br><span class="line">showdiv.removeChild(btn);</span><br><span class="line">showdiv.removeChild(br);</span><br><span class="line">&#125;</span><br><span class="line">//创建换行符</span><br><span class="line">var br=document.createElement(&quot;br&quot;);</span><br><span class="line">//将创建的元素对象存放到div中</span><br><span class="line">showdiv.appendChild(inp);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">js操作form:</span><br><span class="line">获取form表单对象</span><br><span class="line">使用id:var fm=document.getElementById(&quot;fm&quot;);</span><br><span class="line">使用name属性:var frm=document.frm;</span><br><span class="line">获取form下的所有表单元素对象集合</span><br><span class="line">fm.elements</span><br><span class="line">form表单的常用方法</span><br><span class="line">表单对象.submit();//提交表单数据。这个方法是常用的，在提交之前可以进行验证</span><br><span class="line">form的属性操作：</span><br><span class="line">表单对象名.action=&quot;新的值&quot;//动态的改变数据的提交路径</span><br><span class="line">表单对象名.method=&quot;新的值&quot;//动态的改变提交方式</span><br><span class="line">js表单元素的通用属性</span><br><span class="line">只读模式:</span><br><span class="line">readonly=&quot;readonly&quot;//不可以更改，但是数据可以提交</span><br><span class="line">关闭模式：</span><br><span class="line">disabled=&quot;disabled&quot;//不可以进行任何的操作，数据不会提交。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">js操作多选框、单选框</span><br><span class="line">被选中状态下在js中checked属性值为true,未选中状态为false;</span><br><span class="line">js操作下拉框：</span><br><span class="line">被选择的option对象在js中selected属性值为true，未选中为false，在select和option中获取的select的对象，而值是在option的value</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">js修改样式</span><br><span class="line">元素.style.样式名 = 样式值例如</span><br><span class="line">box1.onclick = function()</span><br><span class="line">&#123;</span><br><span class="line">box1.style.height = &quot;300px&quot;;</span><br><span class="line">box1.style.backgroundColor = &quot;red&quot;;//js不支持减号，所以注意css中background-color中的-删掉并改为驼峰形式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BOM（Brower-Object-Model）"><a href="#BOM（Brower-Object-Model）" class="headerlink" title="BOM（Brower Object Model）"></a>BOM（Brower Object Model）</h2><p>就是windows类，Dom是通过js操作网页，Bom是通过js操作浏览器的，相当于浏览器里面的自带的各种硬件比如说c#中的windows编程等。</p><p>Bom的所有对象：</p><p>​1.windows：浏览器窗口,参考w3school</p><p>​2.Navigator：浏览器信息，通过该对象识别不同的浏览器，例如console.log(windows.navigator)或者直接</p><p>​3.Location：浏览器的地址栏信息，参考w3school</p><p>​4.History：浏览器的历史记录，操作网页向前或者向后翻页</p><p>​5.Screen：用户的屏幕信息</p><p>2.3.4.5都是作为windows的属性存在的，所以直接用windowsscreen即可访问</p><p>因为js不是完全面向对象的，所以变量可以不在类里面定义，那么就涉及到变量的定义范围。在js代码中，所有的在类外面的创建的变量都会作为windows的属性保存，在类外面定义的函数都会作为windows的方法保存，即实际上windows是一个最大的类，js中所有的方法，属性都数据window中的属性或者方法，或者子类的属性和方法。；例如外面定义一个var a&#x3D;13;那么调用就是 console.log(a);或者console.log(windows.a);两者是一样的</p><p>常用方法：alert();</p><p>框体方法</p><p>​alert:警告框提示一个警告信息，没有返回</p><p>​confirm:确认框  提示用户选择一项操作（确定&#x2F;取消），返回值为true或者false，以便根据返回值进行其他的用户操作，点击确定 返回true，点击取消  返回false</p><p>​prompt:提示框， 提示用某个信息的录入或者说收集，根据返回的用户输入数据可以进行数据库里面的操作，点击确定，返回当前用书录入的数据，默认返回空字符串，点击取消,返回null</p><p>定时和间隔执行方法</p><p>​setTimeout:指定的时间后执行指定的函数，参数1：函数对象 ，在api中查看该参数时为code expression即代码描述，所以我们直接将所要执行的函数写在里面作为参数，参数2：时间，单位毫秒。返回值：返回当前定时器的id id的作用：作为在调用clearTimeOut函数时的参数</p><p>​setInterval:每间隔指定的时间执行指定的函数，参数1：函数对象，参数2：时间，单位毫秒。返回值：返回当前间隔器的id</p><p>​clearTimeout:用来停止指定的定时器 在上面的间隔执行函数或者定时执行函数没有执行完之前触发该函数会立即取消上面函数的执行。参数：定时器的id</p><p>​clearInterval:用来停止指定的间隔器，参数：间隔器的id</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>1.事件就是用户鼠标操作，比如点击按钮，鼠标移动，关闭窗口等而script是用来处理事件的。共有几十种事件，参考w3school</p><p>2.事件与函数一般是相关联的，即触发某个事件而对应执行某个函数</p><p>3.要想为某个标签添加时间第一种方式是在标签属性上面之间直接添加事件但是耦合性太强。第二种方式是写在script代码中，这就体现出获取对象和获取属性的作用了，例如想为button按钮添加单击事件，那么首先获取button对象，然后为其属性中添加事件代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick = function()&#123;alert(&quot;点击了》》》&quot;)&#125;</span><br></pre></td></tr></table></figure><p>第三种方法：第二种方式只能对标签绑定一个函数，如果想要绑定多个函数就要使用addEventListener()函数了,共有三个参数</p><p>1.事件的字符串，但是不要on，即只用click</p><p>2.写函数</p><p>3.是否捕获阶段触发事件，一般为false；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListner(“click”,function()&#123;alert(1);&#125;,false);</span><br><span class="line">btn.addEventListner(“click”,function()&#123;alert(2);&#125;,false);</span><br><span class="line">这样就为btn控件的click事件添加了两个函数</span><br></pre></td></tr></table></figure><p>4.注意事项：通常我们将script标签写在head标签中，但是会出现一个问题，页面是从上向下执行的，如果body中遇到事件执行函数后发现函数在head中导致执行不了，解决方法有两个1.将js代码写在body中（不推荐）2.将js代码写在head中，但是所有js函数放在onload事件中，表示等待body加载完成再加载head里面的内容。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">window.onload=function()</span><br><span class="line">&#123;</span><br><span class="line">var btn = document.getElementById(&quot;btn&quot;);</span><br><span class="line">btn.onclick = function()&#123;alert(&quot;点击事件&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点击&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>注意：在合适的标签上加上合适的事件</p><p>​1、给合适的HTML标签添加合适的事件</p><p>​onchange—-select下拉框</p><p>​onload——body标签</p><p>​单双击——-用户会进行点击动作的HTML元素</p><p>​鼠标事件——用户会进行鼠标移动操作的。</p><p>​键盘事件——用户会进行键盘操作的HTML元素。</p><p>​2、给HTML元素添加多个事件时，注意事件之间的冲突</p><p>​举个例子：单击和双击当事件的触发条件包含相同部分的时候，会产生事件之间的冲突。</p><p>​3、事件的阻断</p><p>​当事件所监听的函数的将返回值返回给事件时：</p><p>​false：则会阻断当前事件所在的HTML标签的功能</p><p>​true:则继续执行当前事件所在的HTML标签的功能</p><p>​4、超链接调用js函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:函数名()&quot;&gt;调用js函数&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>事件类型：</p><p>单击事件 : onclick.</p><p>双击事件: ondblclick</p><p>鼠标移动事件:</p><p>鼠标悬停事件：onmouseover 当鼠标在html元素上时出发</p><p>鼠标移出事件：onmouseout当鼠标移出某个html元素时触发</p><p>键盘事件:键盘下压事件：onkeydown  当键盘被按下时触发，键盘弹起事件：onkeyup  当键盘弹起时触发</p><p> 焦点事件：获取焦点:onfocus  当获取焦点时触发，例如在输入框中单击后下面会提示需要的选项，焦点实际上就是输入框中的光标，当获取光标时就会出发该事件，失去焦点:onblur当失去焦点时触发，同样光标失去时就会出发该事件</p><p> 值改变事件：专门给select标签使用：onchange事件 当选择下拉框中的某个值时触发</p><p>页面加载事件：onload 当页面加载成功后触发,即先把html渲染完成之后再去触发事件，这样当js放在head中时就可以访问html元素，因为html元素是从上至下执行的，如果页面还没加载完就执行js会出现无法响应的问题。</p><p>注意：事件是作为HTML标签的属性来使用的</p><p>要想为</p><h1 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h1><p>1.创建文件夹结构</p><p>2.创建html骨架结构</p><p>3.引入相关样式文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; ref=&quot;bootstrap/3.4.1/css/bootstrap.min.css&quot; &gt;</span><br></pre></td></tr></table></figure><p>4.书写内容</p><h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>整个浏览器界面相当于一个容器。我们要做的就是往容器里面装东西</p><p>1.Container类：大屏宽度1170px（col-lg），中屏宽度：970px(col-md)，小屏宽度：750px(col-sm)，，超小屏(col-xs)：100%，容器在中间，两边都是边框</p><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/assets/image-20220208224014335.png" alt="image-20220208224014335"></p><p>2.Container-fluid：流式布局，100%，适合移动端开发。中间是容器，两个各有15px的边框</p><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/assets/image-20220208224105245.png" alt="image-20220208224105245"></p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>就是将容器划分成12个列（div），不管容器多大，都是12个列，所以会产生缩放效果即响应式。在栅格系统中，div默认是独占一行的，但是一旦加上了对栅格的设置（例col-lg-4），则会自动改为浮动式，即一行可以有多个div。内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。每一个div默认左右有15个像素的padding</p><p>container里面的内容是通过行row和列colum来控制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;//设置一个容器</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;//一个行div里面包含四个子div</span><br><span class="line">//在大屏幕下每行4个div，每个div四个栅格，在中屏幕下，共三个div，每div四个栅格，小屏幕下每行两列，每列6个栅格，超小屏幕下共一列，每列12个栅格</span><br><span class="line">  &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;1&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-6&quot;&gt;1&lt;/div&gt;独占6列</span><br><span class="line">  &lt;div class=&quot;col-lg-2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-2&quot;&gt;3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-lg-2&quot;&gt;4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/assets/image-20220208230134993.png" alt="image-20220208230134993"></p><h3 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h3><p>若一行内有三个div，其中一个div中还要再分为2个子div，那么该盒子再分为12个栅格，每个子div各占6个栅格即可。列嵌套最好加上一个行row，这样可以取消父元素的padding值，且高度和父级元素一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;col-lg-3 &quot;&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">&lt;div class = &quot;col-sm-6&quot;&gt;a&lt;/div&gt;</span><br><span class="line">&lt;div class = &quot;col-sm-6&quot;&gt;b&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h3><p>用来解决将两个盒子靠向两侧，而不是挨着：将右侧的盒子向右偏移 col-lg-offset-4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;col-lg-4&quot;&gt;a&lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;col-lg-4 col-lg-offset-4&quot;&gt;a&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/assets/image-20220209211617687.png" alt="image-20220209211617687"></p><h3 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h3><p>特殊情况下用于解决将左侧盒子移到右侧，将右侧盒子移到左侧。使用到了浮动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">       &lt;div class=&quot;col-md-4 col-md-push-6&quot;&gt;左侧&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-md-4 col-md-pull-4&quot;&gt;右侧&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/%E5%89%8D%E7%AB%AF/assets/image-20220209212204208.png" alt="image-20220209212204208"></p><h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><p>一些内容在大屏中屏，小屏是否显示不一样。例如广告，在大屏下显示，但是在小屏幕下隐藏</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>就是在浏览器中向服务器中发送请求，不会进行页面刷新，例如点击输入框输入关键字自动显示搜索量最多的信息，再比如局部页面可执行访问服务器的请求，但是整个页面无变化。（原生使用AJax，vue中使用axios）</p><p>优点：1.无需刷新页面前端即可向后端发起请求    2.允许根据事件更新部分页面内容</p><p>缺点：1.Ajax不能回退2.存在跨域3.SEO不友好</p><p>使用：XMLHttpRequest对象进行请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.const xhr = new HttpRequest();</span><br><span class="line">2.xhr.open(&#x27;get&#x27;,&#x27;http://baidu.com&#x27;);</span><br><span class="line">  xhr.setRequestHeader(key,value)</span><br><span class="line"> 3.xhr.send(body)</span><br></pre></td></tr></table></figure><p>xhr的五种状态</p><p>xhr.readstate&#x3D;0:实例出来的那一刻就是0</p><p>xhr.readstate&#x3D;1:open已经调用，但是send没有调用，此时可以修改请求头</p><p>xhr.readstate&#x3D;2:send已经调用，无法修改请求头</p><p>xhr.readstate&#x3D;3:已经回来一部分，小的数据已经回来，大的数据还没有回来</p><p>xhr.readstate&#x3D;4:所有数据均已经回来</p><p>get请求参数问题</p><p>​1.query参数：http：&#x2F;&#x2F;127.0.0.1：8080&#x2F;test?name&#x3D;‘zhangsan’&amp;age&#x3D;18</p><p>​2.params参数：http：&#x2F;&#x2F;127.0.0.1：8080&#x2F;test&#x2F;zhangsan&#x2F;18</p><p>post请求参数</p><p>​1.query参数：http：&#x2F;&#x2F;127.0.0.1：8080&#x2F;test?name&#x3D;‘zhangsan’&amp;age&#x3D;18</p><p>​2.params参数：http：&#x2F;&#x2F;127.0.0.1：8080&#x2F;test&#x2F;zhangsan&#x2F;18</p><p>​3.body请求体：xhr.send(‘name&#x3D;zhangsan”&amp;age&#x3D;18’);</p><p>后端返回json，前端如何处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例如后端返回一个 person=&#123;name:&#x27;张三&#x27;,age:18&#125;</span><br><span class="line"></span><br><span class="line">前端处理btn.onclick=()=&gt;&#123;const xhr=new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">​ xhr.onreadystatechange=()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">​if(xhr.readystate==4)</span><br><span class="line"></span><br><span class="line">​if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)</span><br><span class="line"></span><br><span class="line">​ const result = Json.parse(xhr.response)//直接将json转化为对象const&#123;name,age,sex&#125;=  Json.parse(xhr.response)</span><br><span class="line"></span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">《ul》</span><br><span class="line"></span><br><span class="line">《li》姓名:$&#123;name&#125;《/li》</span><br><span class="line"></span><br><span class="line">《li》年龄:$&#123;age&#125;《/li》</span><br><span class="line"></span><br><span class="line">《li》性别:$&#123;sex&#125;《/li》</span><br><span class="line"></span><br><span class="line">《/ul》</span><br></pre></td></tr></table></figure><p>问题1：如果后端返回不是json对象，而是字符串则使用json.parse()会出现异常，解决办法，在xhr.open后面加一个xhr.responseType&#x3D;’Json’。这样如果后端返回的不是json对象则使用json.parse返回null而不是报异常</p><p>问题2:若网络断开则提示报错：xhr.onerror&#x3D;()&#x3D;&gt;{console.log(“网络无连接”)}</p><p>问题3：网络延迟提示报错：xhr.timeOut&#x3D;2000; xhr.ontimeout()&#x3D;&gt;{console.log(“网速不给力”)}</p><p>问题4：请求时主动中断请求：xhr.abort()</p><p>问题5:Jquery封装ajax:$.ajax({url:’http：&#x2F;&#x2F;百度’,</p><p>​method:’get’,</p><p>​data:{school:’atg’}})e</p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>安装：直接安装脚手架，自带vue </p><p>使用vue的原因是可以将容器交给vue进行保管，然后在从vue中获取数据，好处是可以动态批量修改，一个容易只能对应一个vue即一个div只能new 一个vue。</p><p>如果是类，则el使用(.)进行容器获取，若是id则使用#进行容器获取。vue连接到容器有两种方法，一种是使用el属性，el:”#root”另一种是使用const v&#x3D; new vue({…}),v.$mount(‘#root’)推荐第一种</p><p>data的两种写法：1.对象式 data:{name:’’}     2.函数式data:function(){return{name:’’}}平时使用第一种，若是涉及到组件，必须使用第二种</p><p>常见vue组件库</p><p>1.BS:《httpss:&#x2F;&#x2F;youzan.github.io&#x2F;rant》《httpss:&#x2F;&#x2F;didi.github.io&#x2F;cube-ui》《httpss:&#x2F;&#x2F;mint-ui.github.io》</p><p>2.cs:《httpss:&#x2F;&#x2F;element.eleme.cn》《httpss:&#x2F;&#x2F;iviewui.com》</p><p>首先解决两个提示信息问题1.引入开发者工具vue-devtools该工具可以使用树结构提供各个组件之间的关系，还有调试信息等功能 2.关闭生产模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">&lt;title&gt;初始vue&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;hello,&#123;&#123;name&#125;&#125;&lt;/div&gt;//动态获取vue中的name，叫做绑定</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">Vue.config.productionTip=false</span><br><span class="line">const x = new Vue(&#123;</span><br><span class="line">el: &quot;#root&quot;,//el对应上面的root容器，也叫绑定</span><br><span class="line">data:&#123;</span><br><span class="line">name:&#x27;尚硅谷&#x27;,</span><br><span class="line">url:&#x27;http://www.baidu.com&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在vue中可以也封装对象，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new vue(&#123;</span><br><span class="line"></span><br><span class="line">​school:&#123;</span><br><span class="line"></span><br><span class="line">​name:&#x27;尚硅谷&#x27;,</span><br><span class="line">​url:&#x27;http//baidu.com&#x27;&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样在访问school中的数据的时候就需要使用《a :href&#x3D;”school.url”》《&#x2F;a》</p><p><strong>mvvm</strong></p><p>M:model，data中的数据就是M层</p><p>v：view就是html，整个template区域就是view层</p><p>vm：vue实例对象即new vue(){},所以通常用vm接收实例对象,将属性，方法等封装在vue对象里面，整个script区域代码就是viewmodel层</p><p><strong>数据代理</strong>：底层就是使用了getter和setter方法。vm.name&#x3D;”张三”。使用了setter方法，vm._data.name 调用了getter方法。如果没有数据代理，那么view在调用data中的数据时就要使用__data.name进行获取，而使用数据代理之后直接调用name即可。相当于数据代理将data中的数据复制了一份给vue对象作为属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**&#123;&#123;&#125;&#125;：**对文本内容进行插值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**v-bind:**属性名：对标签属性进行插值，简写为:属性名=&quot;变量名&quot; 例如《a :href=&quot;url&quot;》《/a》等价于《a v-bind:href=&quot;url&quot;》《/a》</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el:&quot;#root&quot;,</span><br><span class="line">data&#123;name:&quot;jack&quot;,</span><br><span class="line">url:&quot;http://baidu.com&quot;</span><br><span class="line">school:&#123;</span><br><span class="line">name:&#x27;上学&#x27;,</span><br><span class="line">url:&#x27;北京&#x27;</span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>**单项绑定：**v-bind:修改vue中data数据时，html中的变量值会动态变化，修改html中的变量值时（一般是输入类型标签中的value值），vue中的data对应的变量值不会修改</p><p>**双向绑定：**v-model:value修改vue中data数据时，html中的变量值会动态变化，修改html中的变量值时（一般是输入类型标签中的value值），vue中的data对应的变量值会修改。v-model:value可简化为v-model(它只能应用于输入类标签,例文本框，多行文本框，复选框，单选按钮，下拉列表控件)。</p><p>v-model.number&#x3D;””要求输入框中的数据转为 number类型</p><p>v-model.trim&#x3D;””将输入框中的输入值去除空格</p><p>v-model.lazy&#x3D;””  v-model每输入一个字符就会同步，使用v-model.lazy会在触发change事件时才会进行同步，比如单击事件，失去焦点时触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line">&lt;input type=&quot;text&quot;  :value=&quot;name&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot;  v-model=&quot;name&quot;&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;h1&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">name:&#x27;张三&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">实现原理：当input中的值改变时，v-model绑定的vue实例中对应的属性值也会改变,进而其他调用该属性的标签值也会随之改变</span><br></pre></td></tr></table></figure><p><strong>v-on</strong>:按钮与方法之间进行连接,直接简写为@</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click=&quot;show(66)&quot;&gt;&lt;/button&gt;简单写法为&lt;button @click=&quot;show&quot;&gt;&lt;/button&gt;</span><br><span class="line">new vue()&#123;</span><br><span class="line">el:&quot;#root&quot;,</span><br><span class="line">methods:&#123;</span><br><span class="line">show(number)&#123;alert(number);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">若函数不传参，则不用加小括号，但是不加小括号会默认传递一个event参数。可以通过event来获取html中的内容</span><br></pre></td></tr></table></figure><p>获取标签中的值就是使用event作为参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keydown.enter=&quot;showInfo(Event)&quot;&gt;</span><br><span class="line">new Vue()&#123;</span><br><span class="line">el:&quot;&quot;</span><br><span class="line">methods:&#123;</span><br><span class="line">showInfo(e)&#123;alert(e.target.value)&#125;//e.target表示获取当前标签的对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-show&#x3D;”false” 不显示内容，起隐藏标签作用</p><p>v-if&#x3D;”false” 不显示内容，并在运行时删除此处的标签。v-show与v-if的显示结果一样，只不过是底层的原理不一样，v-show适合于没有else分支的情况，v-if适合有分支的情况。同时，使用v-else时一定要与v-if相邻，一定不能分开</p><p>v-else-if&#x3D;”true” 类似于else if</p><p>v-for :遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li v-for=&quot;temp in arr&quot;&gt;&#123;&#123;temp&#125;&#125;&lt;/li</span><br><span class="line">   &lt;li v-for=&quot;(temp,key) in arr&quot;&gt;&lt;/li&gt;//key的作用是表示当前项的索引</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>v-text:向其所在的标签插入文本</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;</span><br><span class="line">new vue()&#123;</span><br><span class="line">data:&#123;name:&#x27;内容&#x27;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-html:将字符串里面的标签解析为html（为了安全不推荐使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">&lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;</span><br><span class="line">new vue()&#123;</span><br><span class="line">str:&#x27;&lt;h3&gt;你好&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v-cloak:提升效率</p><p>v-once:对应的变量只解析一次</p><p>v-pre:将所有的文本原样显示在页面上，不会进行任何解析，优化时使用，纯文本内容使用可以避免解析消耗时间</p><p><strong>列表渲染</strong></p><p>在vue中创建数组Persons:[{id:’001’,name:’张三’,age:18},{id:’002’,name:’李四’,age:19},{id:’003’,name:’王五’,age:20}]在传统html中遍历列表是使用创建三个li标签，而使用vue只需要使用v-for即可例如《li v-for&#x3D;”p in Persons :key&#x3D;”p.id”》NaN《&#x2F;li》注意必须加:key属性，根据key进行遍历，以保证唯一性且效率高。</p><p><strong>常见事件修饰符：</strong></p><p>1.prevent，阻止默认事件   例如《a href&#x3D;”…” @click.prevent&#x3D;”show”》《&#x2F;a》</p><p>2.stop:阻止事件冒泡《a href&#x3D;”…” @click.stop&#x3D;”show”》《&#x2F;a》</p><p>3.once:事件只触发一次《a href&#x3D;”…” @click.once&#x3D;”show”》《&#x2F;a》</p><p>4.capture：捕获</p><p>5.self：</p><p>6.passive</p><p><strong>输出过滤器</strong></p><p>本质是函数，作用是将页面传递过来的数据进行格式限制（例如字符串转为int），然后返回页面中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line"></span><br><span class="line">​...</span><br><span class="line">data:&#123;product:&#123;price&#125;&#125;</span><br><span class="line"></span><br><span class="line">​filters:&#123;</span><br><span class="line"></span><br><span class="line">​formatePrice:function(price)&#123;</span><br><span class="line"></span><br><span class="line">​...过滤过程</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">然后在页面中使用</span><br><span class="line">&#123;&#123;product.price|formatPrice&#125;&#125;//即将price参数传递到pormatePrice函数中进行过滤</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>监视属性</strong></p><p>生命周期：当vue实例首次实例化时 ，经历的一系列事件，这个过程叫生命周期（用来探明底层实现原理使用）</p><p>before create（创建） created</p><p>before mounted(挂载) mounted</p><p>beforeupdate（更新）  updated</p><p> beforeDestory（销毁） destoryed</p><p><strong>计算属性：</strong></p><p>计算属性通常不是自定义的属性，而是通过data中的属性进行计算得到的，只不过是将计算的结果赋给一个新的变量叫计算属性，他是依赖于data中的属性，所以当data中的值变化时，计算属性算得的结果也会随之改变。这种属性一般是用户交互的结果，而不是来自于数据库</p><p>属性名就是函数名，返回的值直接赋给属性名，所以一旦html中使用了的形式是data中配置的数据，还是method中配置的方法，还是computed中配置的计算属性 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">new Vue()&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">​firstName:&#x27;张&#x27;,</span><br><span class="line">​lastName:&#x27;三&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">computed:&#123;</span><br><span class="line"></span><br><span class="line">fullName()&#123;</span><br><span class="line">​return this.firstName+&#x27;-&#x27;+this.lastName。//相当于fullName是Vue中的一个属性，他可以操作data中的属性，形式类似与函数，但不是函数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组件</strong></p><p>一个组件包含一个template（模板），script，style，其中template中存在一个根标签div或者header均可</p><p>定义组件时原本使用对象形式定义data{}和使用函数形式定义data(){}均可以，但组件可能被引用多次，若是使用对象形式，则使用的是同一个对象，页面之间的数据相互影响，若使用data函数形式，则可避免数据污染。</p><p>非单文件组件（一般不用）：一个文件包含多个组件</p><p>单文件组件：一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">举例</span><br><span class="line">const s= &#123;</span><br><span class="line">name:&#x27;atg&#x27;,</span><br><span class="line">template:&#x27;&lt;div&gt;&lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;&lt;h2&gt;&#123;&#123;address&#125;&#125;&lt;/h2&gt;&lt;/div&gt;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">new vue()&#123;</span><br><span class="line">return&#123;name:&#x27;上学&#x27;,address:&#x27;北京&#x27;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件写法const school &#x3D; vue.extend(options)简写后为const school &#x3D; options</p><p>自己创建组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.创建组件</span><br><span class="line">const xuxiao=&#123;</span><br><span class="line"></span><br><span class="line">​data()&#123;</span><br><span class="line"></span><br><span class="line">​return&#123;</span><br><span class="line"></span><br><span class="line">​schoolName:&#x27;尚学堂&#x27;,</span><br><span class="line"></span><br><span class="line">​address:&#x27;北京&#x27;</span><br><span class="line">​&#125;&#125;&#125;</span><br><span class="line">2.组件注册</span><br><span class="line">new vue()&#123;</span><br><span class="line">el:&quot;#root&quot;</span><br><span class="line">components:&#123;</span><br><span class="line">school:xuexiao//或者直接写xuexiao即可，表示注册名也为xuexiao</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">3.使用组件</span><br><span class="line">&lt;xuexiao&gt;&lt;/xuexiao&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>单文件组件</strong></p><p>即一个组件对应一个文件，包含html，css和js，对应的html组件结构代码写在template标签中，vue组件交互代码写在script标签中，css组件样式代码写在style标签中。推荐高亮插件vetur，输入&lt;v即可生成上面的三个结构</p><p>简单流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">第一步，写school组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">&lt;h2&gt;学校名称:&#123;&#123;SchoolName&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;学校地址:&#123;&#123;Address&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&#x27;showName&#x27;&gt;提示&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;School&#x27;,</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">SchoolName:&#x27;尚学堂&#x27;,</span><br><span class="line">Address:&#x27;北京&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">methods&#123;</span><br><span class="line">showName()&#123;</span><br><span class="line">alert(this.SchoolName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">demo&#123;</span><br><span class="line">background-color: orangered;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">第二部：写App.vue，将所有组件汇总到一起</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;School&gt;&lt;/School&gt;//组件使用</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//引入school组件</span><br><span class="line">import School from &#x27;./test.vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;//注册组件</span><br><span class="line">school</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第三步：main.js作为入口，引入App.vue</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line"></span><br><span class="line">el: &quot;#root&quot;,</span><br><span class="line">components:&#123;App&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第五步：使用组件App</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;&lt;App&gt;&lt;/App&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>组件传递</strong></p><p>组件传递只能从父组件向子组件传递，父组件更新属性值时，子组件随之更新</p><p>使用：在子组件中使用props来声明期望接收的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.字符串直接传递</span><br><span class="line">在父组件中注册完子组件后，&lt;my-component text=&quot;world&quot;&gt;&lt;/my-component&gt;来使用，注意world这个字符串是在父组件中传递给子组件的,所以一旦发现在使用组件时添加了属性就要想到是不是父组件传递过来的</span><br><span class="line">在子组件中声明props:[&#x27;text&#x27;]用来接收world字符串</span><br><span class="line">2.动态传递</span><br><span class="line">即父组件中的data中的属性传递给子组件使用</span><br><span class="line">父组件中有一个message：“parents&quot;&quot;,在子组件注册完成后，使用时为&lt;my-componet v-bind:text=&quot;message&quot;&gt;&lt;/my-component&gt;实现父组件的message与子组件的text绑定，并且在定义子组件时使用props:[&#x27;text&#x27;]来接收，这样在子组件的任意地方可以使用text了</span><br></pre></td></tr></table></figure><p><strong>插槽</strong></p><p>在子组件中添加一个占位符，当父组件使用子组件时，在组件起始和结束标签之间添加的数据会补充到占位符上，占位符用slot,原本使用子组件时，在开始标签和结束标签之间不能添加内容，使用插槽之后，里面的内容会自动替换到slot上，所以一旦在使用标签之间发现了内容，则一定是使用了插槽，在使用组件添加了属性，则一定是使用到了props</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;//占位符</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/scipt&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;child&gt;天气很好&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &#x27;&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;father&#x27;</span><br><span class="line">components:&#123;child&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/scipt&gt;</span><br><span class="line"></span><br><span class="line">具名插槽：</span><br><span class="line">上面使用slot只能解决传递一个属性，但是若想要解决多个属性，那引入一个slot是不够的</span><br><span class="line">解决办法：使用具名插槽，即 为slot命名一个名字</span><br><span class="line">在子组件中&lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;</span><br><span class="line">在父组件中&lt;child&gt;</span><br><span class="line">&lt;label slot=&quot;title&quot;&gt;jjdlfd&lt;/label&gt;//将该标签插入到child指定的地方</span><br><span class="line">&lt;/child&gt;</span><br></pre></td></tr></table></figure><p><strong>脚手架</strong></p><p>执行npm命令时一旦遇到sill idealTree buildDeps错误，则说明服务器在国外，此时先使用下面的命令设置淘宝镜像，npm config set registry httpps:&#x2F;&#x2F;registry.npm.taobao.org 或者设置第二种镜像npm config set registry https:*&#x2F;&#x2F;registry.npmjs.org，在执行一下npm config get registry命令，在重新执行npm命令</p><p>作用，将vue代码解析，类似于c#与.net的作用</p><p>安装：npm install -g @vue&#x2F;cli        在项目目录下vue create xxx     进入项目文件夹启动项目npm run serve</p><p>结构目录：其他非App.vue组件放在components文件夹下，App.vue放在src下，图片等放在Assets下 ，html放在public下，main.js是一切程序的开端，</p><p>main.js中render函数：引入模板解析器</p><p>ref属性就是id属性的代替者，对于普通标签没有区别，但是对于组件，通过document.getElementById(‘sch’)获取的是Dom对象，而通过this.$ref.sch获取的是组件实例对象</p><p>配置项：props：问题，一个student组件，name，age，sex&#x3D;》张三，23，男。当别人引用该组件时，用户想要修改数据值，不能将name，age，sex写在组件里面，而是写在标签里面，并且告诉vue对象里面props属性添加属性，告诉该组件都有哪些属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> export default&#123;</span><br><span class="line"> name:&#x27;Student&#x27;,</span><br><span class="line"> data()&#123;</span><br><span class="line"> return&#123;</span><br><span class="line"> msg:&#x27;尚学堂&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> //第一种写法</span><br><span class="line"> props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;]</span><br><span class="line"> //第二种写法推荐</span><br><span class="line"> props:&#123;</span><br><span class="line"> name:&#123;type:string,required:true&#125;</span><br><span class="line"> age:&#123;type:number,default:99</span><br><span class="line"> sex:string</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>插件</strong></p><p>放到src问价夹目录中</p><p>mixin：将两个不同的组件中相同的东西抽取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义一个插件</span><br><span class="line">export default&#123;install()&#123;</span><br><span class="line">console.log();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">应用插件</span><br><span class="line">import 文件名 from 路径名</span><br><span class="line">使用</span><br><span class="line">Vue.use(插件名)</span><br></pre></td></tr></table></figure><p><strong>Scoped样式</strong></p><p>vue中会将所有组件的style汇总到一起，这就会产生问题，不同组件一旦在style中使用了相同类名，汇总到一起之后会出现冲突，解决方法，在style标签中写一个scoped属性表明该属性只应用于该组件（注意App.vue中style不要写scoped ）</p><p><strong>本地储存</strong></p><p>例如浏览器搜索记录，这个都是保存到浏览器中的，下次再点击搜索框的时候自动显示。</p><p>常见方法:</p><p>1.localStorage.setItem(‘msg’,’hello’);&#x2F;&#x2F;键值对key&#x3D;msg，value&#x3D;hello</p><p>2.localStorage.getItem(‘msg’);</p><p>3.localStorage.removeItem(‘msg’);</p><p>4.localStorage.clear();</p><p><strong>this的指向</strong></p><p>1.组件配置中，data函数，methods函数，watch函数，computed函数，他们的this均是vuecomponent实例对象</p><p>2.new vue配置中，methods函数，watch函数，computed函数，他们的this均是vue实例对象</p><p><strong>Axios</strong></p><p>前后端访问原理：实际上是页面提交数据到前端服务器（有自己的域名和端口），然后前端的服务器将数据发送给后端服务器(与前端端口不一定一致)，所以会涉及到跨域的问题。解决方法参考杨中科webapi项目</p><p>首先下载axios:   npm install axios</p><p>第一种方式</p><p>发起get请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#x27;http://localhost:3000/comments&#x27;).then(response=&gt;&#123;console.log(response.data)&#125;).catch(error=&gt;&#123;console.log(error)&#125;);其中commments是后端的控制器中的action名称,response.data就是vue中的data数据，其中then表示响应成功时返回response对象，catch表示相应失败时返回error对象</span><br></pre></td></tr></table></figure><p>post</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#x27;http://localhost:3000/comments&#x27;,&#123;&quot;id&quot;:1,&quot;body&quot;:&quot;some comment&quot;,&quot;postId&quot;:1&#125;).then(response=&gt;&#123;console.log(response.data)&#125;).catch(error=&gt;&#123;console.log(error)&#125;);//post方式传入json对象</span><br></pre></td></tr></table></figure><p>put</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.put(&#x27;http://localhost:3000/comments/1&#x27;,&#123;&quot;id&quot;:1,&quot;body&quot;:&quot;some comment&quot;,&quot;postId&quot;:1&#125;).then(response=&gt;&#123;console.log(response.data)&#125;).catch(error=&gt;&#123;console.log(error)&#125;);</span><br></pre></td></tr></table></figure><p>delete</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.delete(&#x27;http://localhost:3000/comments/1&#x27;).then(response=&gt;&#123;console.log(response.data)&#125;).catch(error=&gt;&#123;console.log(error)&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简写写法(不必写then和catch了)：async()=&gt;&#123;const result=await axios.get(&#x27;http://localhost:5000/lll&#x27;)&#125;，若出现相应错误则会调用响应拦截器中的error，成功则将response对象返回result</span><br></pre></td></tr></table></figure><p>第二种请求方式：对象方式（推荐：更加灵活）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios(</span><br><span class="line">&#123;</span><br><span class="line">mehod:&#x27;post&#x27;,</span><br><span class="line">url:&#x27;user/123456&#x27;,</span><br><span class="line">data:&#123;</span><br><span class="line">userName:&#x27;fred&#x27;,</span><br><span class="line">passWord:&#x27;123456&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(response=&gt;&#123;console.log(response.data)&#125;).catch(error=&gt;&#123;console.log(error)&#125;);</span><br><span class="line">其他请求类似</span><br><span class="line">可以在axios对象外面添加一些默认配置，如果有多个请求，不用再每个axios里面对象都配置一样的参数，使用默认配置会自动调取这些参数</span><br><span class="line">axios.default.timeout=2000;</span><br><span class="line">axios.default.header=&#123;school:&#x27;atg&#x27;&#125;;</span><br><span class="line">axios.default.baseURL=&quot;http://localhost:8000&quot;</span><br></pre></td></tr></table></figure><p>第三种请求方式：自己创建对象，该方式与第二种的区别是如果有多个请求，一般会将某些参数拿出来写成默认参数（如上），但是个别的请求有自己的参数，不想使用默认参数，就使用下面的方法在对象里面配置即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create(&#123;</span><br><span class="line">url:&#x27;/login&#x27;,</span><br><span class="line">method:&#x27;get&#x27;,</span><br><span class="line">baseURL:&#x27;http://localhost:3210&#x27;,//注意baseURL表示域名+端口，后面加上url才表示一个完整的请求路径</span><br><span class="line">data:&#123;</span><br><span class="line">userName:&#x27;fred&#x27;,</span><br><span class="line">passWord:&#x27;123456&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>拦截器：本质是函数，在发起请求之前先执行拦截器里面的函数，处理完成后返回请求包发送出去。在响应返回之前同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use((config)=&gt;&#123;&#123;函数体&#125;&#125;;return config&#125;,error=&gt;&#123;return Promis.error(error)&#125;)</span><br></pre></td></tr></table></figure><p>响应拦截器同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(response=&gt;&#123;if(response.status==200)&#123;return Promise.resolve(response)&#125;return Promise.reject(response)&#125; error=&gt;&#123;if(error.response.status)</span><br><span class="line">&#123;switch(error.response.status)</span><br><span class="line">case 404: console.log(&quot;找不到你想要的页面&quot;；</span><br><span class="line">break; </span><br><span class="line">case 401:console.log(&quot;你没有权限&quot;); break;</span><br><span class="line">case 500; console.log(&quot;服务器内部错误&quot;));break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">return new promise(()=&gt;&#123;&#125;)&#125;);//promise对象的作用是设置中断</span><br></pre></td></tr></table></figure><p>axious取消请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const CancelToken=axios.CancelToken;</span><br><span class="line">然后在请求体里面添加canceltoken属性</span><br><span class="line">cancelToken:new CancelToken((c)=&gt;&#123;c())&#125;)//c是一个取消请求函数，如果使用的话直接调用即可</span><br><span class="line">但是不能像上面刚请求就取消，而是在点击按钮或者事件时取消，所以在外面定义一个变量用来接收c函数</span><br><span class="line">1.let temp;</span><br><span class="line">2.const CancelToken=axios.CancelToken;</span><br><span class="line">3.请求体里面添加cancelToken:new CancelToken((c)=&gt;&#123;temp=c)&#125;);</span><br><span class="line">4.在事件或者函数中调用temp()即可;</span><br></pre></td></tr></table></figure><p>axios批量发送请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async()=&gt;&#123;axios.all([axios.get(&#x27;url&#x27;),</span><br><span class="line"> axios.get(&#x27;url2&#x27;),</span><br><span class="line"> axios.get(&#x27;url3&#x27;)]).then(response=&gt;&#123;console.log(response),error=&gt;&#123;console.log(error)&#125;&#125;)&#125;</span><br></pre></td></tr></table></figure><p><strong>vuex</strong></p><p><strong>路由</strong></p><p>vue-cli没有创建路由文件，所以需要自己创建文件并引入</p><p>key+value&#x3D;路由，最直观的是，左侧为导航区，右侧为展示区，点击导航区的按钮，在展示区显示对应的内容</p><p>单页面应用：点击一个连接，只在一个页面中跳转，不会创建新标签，多页面相反</p><p>路由规则：key就是url value就是组件或者函数</p><p>使用方法：</p><p>1.安装vue-router :npm i vue-router@3，先设置镜像，通过package.json中是否有vue-router判断是否安装成功</p><p>2.使用import vuerouter from ‘vue-router’      vue-router:Vue.use(VueRouter)；（写在main.js中）</p><p>3.创建一个新文件夹router，新建index.js文件，专门创建路由器，专门用来进行路由器配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import vueRouter from &#x27;Vue-router&#x27;</span><br><span class="line">import About from &#x27;路径&#x27;//引入About组件</span><br><span class="line">import Home from &#x27;组件&#x27;//引入Home组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建路由器,声明组件并设置访问的url</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">routers:[&#123;path:&#x27;/about&#x27;,component:About&#125;,</span><br><span class="line"> &#123;path:&#x27;/home&#x27;,component:Home&#125;]//routers数组中至少都有path和component</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">然后在main.js中引入路由器</span><br><span class="line">import router from &#x27;./router/index&#x27;</span><br><span class="line">并且在vue实例中创建对应的路由器属性,因为得需要使用index.js里面的路由就是这种使用方式</span><br><span class="line">router:router</span><br><span class="line">//使用路由器，将组件与路由联系起来利用router-link代替a标签</span><br><span class="line">&lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line">//将组件显示到指定地方</span><br><span class="line">&lt;router-view&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>嵌套路由</strong></p><p>在导航区对应的展示区中还有局部导航区和局部展示区，也叫做多级路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default new VUeRouter(&#123;</span><br><span class="line">routes:[&#123;</span><br><span class="line">path:&#x27;./home&#x27;,</span><br><span class="line">component:Home</span><br><span class="line">children:[&#123;</span><br><span class="line">path:&#x27;news&#x27;,//二级路由</span><br><span class="line">components:News//不用再写/</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>问题：如果展示区是100个列别，即100个li标签，需要100个组件，而且结构相同，内容不同</p><p>解决办法：将内容作为变量传递过去，即query，或者params传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">以三级路由为例</span><br><span class="line">export default new VUeRouter(&#123;</span><br><span class="line">routes:[&#123;</span><br><span class="line">path:&#x27;./home&#x27;,</span><br><span class="line">component:Home</span><br><span class="line">children:[&#123;</span><br><span class="line">path:&#x27;news&#x27;,//二级路由</span><br><span class="line">components:News//不用再写/</span><br><span class="line">children:[&#123;path:&#x27;detail&#x27;&#125;,</span><br><span class="line">component:Detail]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用时：发送，将id和title传送到detail组件中</span><br><span class="line">&lt;router-link to=&quot;/home/message/detail?id=666&amp;title=&#x27;你好&#x27;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">再detail.vue中接收</span><br><span class="line">&lt;li&gt;消息编号：[&#123;$router.query.id&#125;]&lt;/li&gt;</span><br><span class="line">&lt;li&gt;消息标题：[&#123;$router.query.title&#125;]&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">第二种方式，使用params传递（推荐）</span><br><span class="line">&lt;router-link :to=&quot;&#123;</span><br><span class="line">path:&#x27;/home/news/detail&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">id:m.id</span><br><span class="line">title:m.title</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">第二种接收方式，使用props</span><br><span class="line">发送者中props:[a:1,b:&#x27;hello&#x27;]</span><br><span class="line">接收者中props:[&#x27;a&#x27;,&#x27;b&#x27;]</span><br><span class="line">使用时直接&#123;&#123;a&#125;&#125;,&#123;&#123;b&#125;&#125;即可</span><br></pre></td></tr></table></figure><p>编程式路由：前面都是提供使用router-link标签进行连接跳转，现在想要button等其他标签自定义实现跳转，叫做编程式路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&#x27;pushShow(m)&#x27;&gt;&lt;/button&gt;</span><br><span class="line">再vue对象中</span><br><span class="line">methods:&#123;</span><br><span class="line">pushShow(m)&#123;</span><br><span class="line">this.$route.push(&#123;</span><br><span class="line">name:&#x27;xiaomi&#x27;,</span><br><span class="line">query:&#123;id:m.id,title:m.title&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><p>vue3+vite代替vue2+webpack</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">差别：在vue2的main.js文件中</span><br><span class="line">import Vue from &#x27;&#x27;</span><br><span class="line">import App from &#x27;&#x27;</span><br><span class="line">const vm=new Vue(&#123;</span><br><span class="line">render:h=&gt;h(App)</span><br><span class="line">&#125;)</span><br><span class="line">vm.$mount(&quot;#app&quot;)</span><br><span class="line">在vue3的main.js文件中</span><br><span class="line">import &#123;createApp&#125; from &#x27;&#x27;</span><br><span class="line">import App from &#x27;&#x27;</span><br><span class="line">createApp(App).mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">在vue3中，在vue对象中将没有data来保存数据，也将没有methods来保存方法，而是都放在setup中</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">let name=&#x27;张三&#x27;,</span><br><span class="line">let age=18,</span><br><span class="line">function sayhello()&#123;</span><br><span class="line">alert(&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return &#123;name,age,sayhello&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref函数</p><p>reactive函数</p><p><strong>elementUI</strong></p><p>1.安装npm i element-ui -S</p><p>2.引入，在main.js中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from &#x27;element-ui&#x27;;</span><br><span class="line">import &#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><p>3.直接赋值粘贴使用</p><p><strong>Vue路由的两种模式</strong></p><p>hash和history：vue的路由默认是hash模式，⼀般开发的单页应⽤的URL都会带有#号的hash模式，因为整个应⽤本⾝⽽⾔就只有⼀个HTML简单介绍下两种模式：<br>hash —— 即地址栏 URL 中的 # 符号。⽐如这个 URL：<a href="http://www.abc.com/#/hello%EF%BC%8Chash">http://www.abc.com/#/hello，hash</a> 的值为 #&#x2F;hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页⾯。<br>history —— 利⽤了 HTML5 History Interface 中新增的 pushState() 和 replaceState() ⽅法。这两个⽅法应⽤于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进⾏修改的功能。只是当它们执⾏修改时，虽然改变了当前的 URL，但浏览器不会⽴即向后端发送请求。.<br>使⽤场景<br>⼀般场景下，hash 和 history 都可以，除⾮你更在意颜值，# 符号夹杂在 URL ⾥看起来确实有些不太美丽。如果不想要很丑的 hash，我们可以⽤路由的 history 模式，hash模式下url需要带“#”符号，不仅看起来不舒服，⽽且有些场景下是会破坏路由中的”#”（微信分享页⾯就会</p><h3 id="postman使用"><a href="#postman使用" class="headerlink" title="postman使用"></a>postman使用</h3><p>get:query和params请求都是选择params按钮，但是params需要自己拼接url而query可以填入key和value</p><p>post:选择post，选择body，选择raw，选择json</p><p>put：选择body，选择x-www-form-urlencoded,因为必须是查询之后才可修改，所以先输入params查询</p><p>delete：使用params按钮 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>winform</title>
      <link href="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/"/>
      <url>/2026/01/29/winform%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h3><p>有些控件是不能添加到图形界面上的，例如time控件，tooltip控件，到时候我们直接使用即可。</p><p>winform中，this指的是当前窗体的对象，而sender指的是控件</p><p>this.close事件和Application.exit()的区别：后者是关闭所有进程，一般用在主窗口里面退出，而前者是只关闭当前窗口</p><p>当弹出另一个窗口隐藏当前窗口，新窗口关闭时显示原来的窗口操作方法。</p><span id="more"></span><p>​this.Hide();</p><p>​新窗口.ShowDialog();</p><p>​this.Show();</p><p>当在解决方案管理器中创建第二个项目的时候，运行后发现执行的仍然是上一个项目，在新创建的项目上右键&#x3D;》设为启动项目即可。</p><p>那些无法在设计界面的时候显示的控件不必进行拖拽(例如timer控件)，而是直接创建一个该控件对象，然后调用其中的方法即可</p><h3 id="打开选择文件的窗体控件"><a href="#打开选择文件的窗体控件" class="headerlink" title="打开选择文件的窗体控件"></a>打开选择文件的窗体控件</h3><p>OpenFileDialog，选择文件，选择文件的时候使用，filename属性获取路径名。</p><p>SaveFileDialog;保存文件,返回结果dialogResult，一般用来创建文件的时候使用</p><p>FoldBrowersDialog，选择文件夹，它的selectedPath用来获取用户选择路径</p><p>OpenFileDialog方法，返回结果为DialogResult</p><p>设置只能打开图片文件和txt文件：openDialog.Filter &#x3D; “ *.jpg| *.bmp | *.txt”;</p><h4 id="为按钮添加快捷键："><a href="#为按钮添加快捷键：" class="headerlink" title="为按钮添加快捷键："></a>为按钮添加快捷键：</h4><p>在text属性里面使用“&amp;”+字母即可进行快捷键设置。</p><h3 id="日历控件"><a href="#日历控件" class="headerlink" title="日历控件"></a>日历控件</h3><p>MonthCalendar控件</p><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>窗体：</p><p>​标题：外观&#x3D;》text</p><p>窗口图标：窗口样式&#x3D;》icon属</p><p>是否允许用户拖动更改窗体大小：布局&#x3D;》autoSizeMode&#x3D;》Growandshrink</p><p>窗体出现的位置：布局&#x3D;》startPosition&#x3D;&gt;居中显示</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930112651982.png" alt="image-20220930112651982"></p><p>属性：autosize是否启用自动修改窗体大小：一般用于文本标签，当输入文字超过窗体大小时，就会自动增大</p><p>​backcolor：控件的背景色</p><p>​backgroundimage:背景图片</p><p>​backgroundimagelayout:背景图片布局：拉伸，平铺，。。。</p><p>​cursor:鼠标样式</p><p>​doublebuffer：双缓冲，设置背景图时，修改控件的大小时需要闪屏则开启。win10则不闪</p><p>​Font:对字体的设置，字形，字号，加粗，斜体等。用法：new font(“字体”,”字号”,”加粗”,”斜体”)。</p><p>​formboderstyle:窗体边框设置，无边框，有边框。。。</p><p>​opacity:透明度</p><p>​padding:内边距</p><p>​margin：外边距</p><p>​showicon:是否显示图标</p><p>​showIntaskbar:是否显示在任务栏中</p><p>​            startPosition:窗体启动时的起始位置</p><p>​topmost:是否始终显示在最前方</p><p>​this.windowstate &#x3D; fomwindowstate.normal:窗体最大化，最小化，正常化显示</p><p>​topMost：设为true之后，即使该窗体失去鼠标焦点，仍然显示在最上层，否则显示获得焦点的窗体。</p><p>​this.FormBorderStyle&#x3D;…：设置窗体边框样式。比如说无边框。。。,固定边框为fixedDialog</p><p>​this.width &#x2F;height&#x3D; ….;设置窗体宽度、高度</p><p>​anchor&#x3D;top;将控件绑定到容器上边缘，当窗体改变时，控件的其他位置可能改变，只有上边缘位置不变。</p><p>窗体与容器之间的距离设置</p><p>this.left &#x3D; …</p><p>this.top &#x3D; …</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930113756747.png" alt="image-20220930113756747"></p><p>窗体基本事件：</p><p>​控件对应的事件是在窗体进入构造方法中进入InitializeComponent()方法后会发现自动调用控件对应的事件。如果想要解绑控件，即不是运行后就自动执行该控件对应的事件，可以在事件&#x3D;》属性&#x3D;》load属性中删除该控件名称</p><p>调整容器距边界距离的三种方式：</p><p>1.不许用户调节窗口大小：AutoSizeMode&#x3D;&gt;GrowAndShark：缺点不人性化</p><p>2.容器距边界调整的方式的第三种方法，是调整anchor属性：建议使用</p><p>3.dock:可能不太美观。</p><p>最大化功能关闭：this.maximizeBox &#x3D; false</p><p>Winform中窗体sender参数就表示传递过来的按钮对象，默认为object类型，使用的时候我们需要将其强转。例如一个点击一个button1，平时我们是直接使用button1.text&#x3D;…进行设置。而sender使用方式是Button b &#x3D; (Button)sender; B.text &#x3D; …返回的结果是一个类。这两种方式结果一样，但是sender只表示当前控件的对象，可以传递任意一种控件。而button1是一种指定使用哪种的方式。</p><p>而EventArgs表示的将鼠标的所有动作或者位置封装在该参数里面</p><p>每次设计winform窗体的时候，拉伸窗体的时候导致窗体与初始的窗体设置不一样。</p><p>解决方法：1.划分区域，使用工具箱中的容器里面的划分区域的工具。Split，table，tab等</p><p>2．将winform的AutoSizeMode改为GrowAndShrink,这种方式是不让用户更改窗体大小，治标不治本。</p><p>关闭窗体标题栏：<br>            this.Text &#x3D; “”;<br>            this.ControlBox &#x3D; false;</p><p>窗体闪烁来引起用户注意</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930164828130.png" alt="image-20220930164828130"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void timer1_Tick(object sender, EventArgs e)</span><br><span class="line">       &#123;</span><br><span class="line">           FlashWindow(this.Handle, true);</span><br><span class="line">       &#125;</span><br><span class="line">       [System.Runtime.InteropServices.DllImport(&quot;user32.dll&quot;)]</span><br><span class="line">       private static extern bool FlashWindow(IntPtr hanle, bool bInvert);</span><br><span class="line">       private void button1_Click(object sender, EventArgs e)</span><br><span class="line">       &#123;</span><br><span class="line">           timer1.Enabled = true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private void button2_Click(object sender, EventArgs e)</span><br><span class="line">       &#123;</span><br><span class="line">           timer1.Enabled = false;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="获取显示器和工作区的大小"><a href="#获取显示器和工作区的大小" class="headerlink" title="获取显示器和工作区的大小"></a>获取显示器和工作区的大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取显示器屏幕的大小和工作区的大小，工作区不包括工具栏等</span><br><span class="line">            int screen_width = Screen.PrimaryScreen.WorkingArea.Width;</span><br><span class="line">            int screen_height = Screen.PrimaryScreen.WorkingArea.Height;</span><br><span class="line">            </span><br><span class="line">            this.Width = Convert.ToInt32(screen_width * 0.8);</span><br><span class="line">            this.Height = Convert.ToInt32(screen_height * 0.8);</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930161336376.png" alt="image-20220930161336376"></p><h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><p>获取鼠标位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c = e as MouseEventArgs;</span><br><span class="line">           MessageBox.Show(c.X.ToString()+ c.Y.ToString());</span><br></pre></td></tr></table></figure><p>判断鼠标按下哪个键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var c = e as MouseEventArgs;</span><br><span class="line">            if (c.Button == MouseButtons.Left)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(&quot;鼠标左键&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (c.Button == MouseButtons.Right)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(&quot;鼠标右键&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(c.Button == MouseButtons.Middle)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(&quot;鼠标中键&quot;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>定义鼠标的形状</p><p>label1.Cursor &#x3D; Cursors.Hand;</p><p>鼠标绘图</p><h3 id="键盘控制"><a href="#键盘控制" class="headerlink" title="键盘控制"></a>键盘控制</h3><p>判断是否为B键</p><p> var a &#x3D; e as KeyEventArgs;<br>            MessageBox.Show((a.KeyCode &#x3D;&#x3D; Keys.B).ToString());</p><p>按下enter键实现tab键的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (e.KeyCode == Keys.Enter)</span><br><span class="line">           &#123;</span><br><span class="line">               SendKeys.Send(&quot;&#123;Tab&#125;&quot;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>判断同时按下那些键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(e.Alt&amp;&amp;e.keyValue == 115)判断是否按下alt+F4键</span><br><span class="line">&#123;</span><br><span class="line">e.Handled = true;屏蔽Alt+f4键，handled表示已经处理过了，就跳过，不进行处理了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理屏蔽，ctrl+c,ctrl+v</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(e.Control&amp;&amp;e.Code==V)</span><br><span class="line">&#123;</span><br><span class="line">e.handled =true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开和关闭系统自带输入法</p><p>修改textbox的ImeMode属性即可</p><h3 id="button控件"><a href="#button控件" class="headerlink" title="button控件"></a>button控件</h3><p>Button中MouseClick事件与click事件的区别：mouseClick会接受鼠标其他按键（右键、中键、其他），而click仅支持鼠标左键的点击</p><p>设置控件的外观</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20221002104234240.png" alt="image-20221002104234240"></p><h3 id="获取计算机系统信息"><a href="#获取计算机系统信息" class="headerlink" title="获取计算机系统信息"></a>获取计算机系统信息</h3><p>获取系统时间：datatime.now</p><p>访问系统路径即system32文件路径:MessageBox.Show(Environment.SystemDirectory);</p><p>获取计算机名称：Environment.MachineName+E);</p><p>获取当前程序所在目录：Environment.CurrentDirectory</p><p>获取系统版本：nvironment.OSVersion.VersionString</p><p>获取软件启动后所经历的时间 Environment.TickCount &#x2F; 1000 + “秒”</p><p>获取cpu信息</p><p>获取硬盘信息</p><p>获取主板信息</p><p>获取驱动器信息：</p><p>获取屏幕的分辨率：SystemInformation.VirtualScreen.ToString()</p><p>获取打印机信息：PrintSetting </p><p>获取ip地址：Dns.GetHostByName(Dns.GetHostName()).AddressList.ToString()</p><p>判断是否联网：if (SystemInformation.Network)<br>            {<br>                MessageBox.Show(“已经联网”);<br>            }</p><p>判断是否链接了电源：if (SystemInformation.PowerStatus.PowerLineStatus &#x3D;&#x3D; PowerLineStatus.Offline )<br>            {<br>                MessageBox.Show(“没有连接电源”);<br>            }</p><p>获取日志信息：</p><h3 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a>Label控件</h3><p>​Borderstyle 为fixSingle：为里面的内容添加方框，但是文字不是居中的</p><p>​Textalien:文字居中</p><h3 id="TextBox控件"><a href="#TextBox控件" class="headerlink" title="TextBox控件"></a>TextBox控件</h3><p>​基本特性：</p><p>​解决textBox控件可以进行纵向拖拽或者多行输入，控件图像上单击小三角形，然后选择multltyLines即可。或者修改属性中&#x3D;》行为&#x3D;》multiline设置为true即可</p><p>​外观&#x3D;》ScrollBars：当多行文本框写入的字数过多时，文本框右侧出现滚动的滚动滑块（vertual垂直滑块，both加上一个水平滑块）</p><p>​当在文本框中输入密码的时候，需要将密码设置为*，则在属性&#x3D;》行为&#x3D;》passwordChars&#x3D;》添加一个*即可（只允许设置单行文本，多行文本不允许设置）</p><p>弹出对话框的代码：是个静态写法：即MessageBox.show(string str);</p><p>​若文本设置为只读时，设置readonly为true即可</p><p>​与enable的区别：readonly允许复制内容，enable不允许</p><p>​Readonly可直接看到变成灰色，enable运行后才可以</p><p>​TextChange事件获取的是文本框中的所有内容</p><p>​textbox添加滚动条，在属性中的scrollbars</p><p>设置多行属性：将multiline属性改为true；</p><p>password属性设为*，即可保密</p><p>给输入的字体设置下划线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void textBox1_TextChanged(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            textBox1.Font = new Font(new Font(&quot;宋体&quot;,15),FontStyle.Underline);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="禁用鼠标右键和禁用ctrl-v的功能"><a href="#禁用鼠标右键和禁用ctrl-v的功能" class="headerlink" title="禁用鼠标右键和禁用ctrl+v的功能"></a>禁用鼠标右键和禁用ctrl+v的功能</h4><p>shortcutsenable&#x3D; false;即可</p><h3 id="Datagridtext"><a href="#Datagridtext" class="headerlink" title="Datagridtext:"></a>Datagridtext:</h3><p>不让用户添加行和添加列，只展示给用户，不让用户操作，将allowUserAddRows和allowUserdeleteRows的值改为false；</p><p>不让用户一次选择多个单元格：将multiselect改为false；</p><p>每次选择一行而不是一个单元格，将selectionMode改为fullRowSelecte;</p><h3 id="DataGridView"><a href="#DataGridView" class="headerlink" title="DataGridView"></a>DataGridView</h3><p>该控件的常见属性和操作<a href="https://wenku.baidu.com/view/8e0c30d1b90d4a7302768e9951e79b8969026858.html">https://wenku.baidu.com/view/8e0c30d1b90d4a7302768e9951e79b8969026858.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1、获得某个（指定的）单元格的值：</span><br><span class="line">dataGridView1.Row[i].Cells[j].Value;</span><br><span class="line">2、获得选中的总行数：</span><br><span class="line">dataGridView1.SelectedRows.Count;</span><br><span class="line">3、获得当前选中行的索引：</span><br><span class="line">dataGridView1.CurrentRow.Index;</span><br><span class="line">4、获得当前选中单元格的值：</span><br><span class="line">dataGridView1.CurrentCell.Value;</span><br><span class="line">5、取选中行的数据</span><br><span class="line">string[] str = new string[dataGridView.Rows.Count];</span><br><span class="line">for(int i;i&lt;dataGridView1.Rows.Count;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(dataGridView1.Rows[i].Selected == true)</span><br><span class="line">&#123;</span><br><span class="line">str[i] = dataGridView1.Rows[i].Cells[1].Value.ToString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">7、获取选中行的某个数据</span><br><span class="line">int a = dataGridView1.SelectedRows.Index;</span><br><span class="line">dataGridView1.Rows[a].Cells[“你想要的某一列的索引，想要几就写几”].Value;</span><br><span class="line"></span><br><span class="line">获得某个（指定的）单元格的值： dataGridView1.Row[i].Cells[j].Value; Row[i] 应该是Rows[i]</span><br><span class="line"></span><br><span class="line">int a=dataGridView1.CurrentRow.Index;</span><br><span class="line">string str=dataGridView1.Row[a].Cells[“strName”].Value.Tostring();</span><br><span class="line"></span><br><span class="line">selectedRows[0]当前选中的行</span><br><span class="line">.cell[列索引].values 就是当前选中行的某个单元格的值</span><br><span class="line"></span><br><span class="line">DataGridView1.SelectedCells(0).Value.ToString 取当前选择单元内容</span><br><span class="line">DataGridView1.Rows(e.RowIndex).Cells(2).Value.ToString 当前选择单元第N列内容</span><br></pre></td></tr></table></figure><p>就是可以直接显示数据库中的数据的控件。</p><p>绑定数据源的方式是将集合赋给DataSource属性，不必将数据一个一个读取到表格里面，通常是直接将该控件绑定到数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dataGridView1.DataSource = new List&lt;Student&gt;()</span><br><span class="line">            &#123;</span><br><span class="line">                new Student(&quot;张三&quot;,23),</span><br><span class="line">                new Student(&quot;李四&quot;,24),</span><br><span class="line">                new Student(&quot;王五&quot;,25)</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"> 设置为仅显示</span><br><span class="line"> dataGridView1.AllowUserToAddRows = false;</span><br><span class="line">            dataGridView1.AllowUserToDeleteRows = false;</span><br><span class="line">            dataGridView1.ReadOnly = true;</span><br><span class="line">            </span><br><span class="line"> 实现用户可以在datagridview里面可以进行选项选择，而不必手动输入</span><br><span class="line"> datagridviewcomboboxcoclum dgv = new datagridviewcomboboxcolum;</span><br><span class="line"> dgv.itmes.add(&quot;苹果&quot;);</span><br><span class="line"> dgv.items.add(&quot;橘子&quot;);</span><br><span class="line"> dataGridView1.Columns.Add(dgv);</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20221005205808702.png" alt="image-20221005205808702"></p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20221005203626127.png" alt="image-20221005203626127"></p><p>​        </p><h3 id="ComboBox下拉框"><a href="#ComboBox下拉框" class="headerlink" title="ComboBox下拉框"></a>ComboBox下拉框</h3><p>​下拉框选项，类似于枚举，选项设置：在图像选中小三角&#x3D;》编辑项添加即可。第二种方式在属性&#x3D;》数据&#x3D;》itmes中添加枚举即可</p><p>默认第一项为空值，如果想要设置默认项，则改为</p><p>cbox_select.selectIndex &#x3D; 0;表示将items中的第一个设为默认值</p><p>如果选择下拉框的值触动事件的时候，就使用selectindexchanged，如果是手动写入的值触动事件的时候，就用textchanged事件。Selectvaluechanged表示值，枚举中可能有相同的值</p><p>​获取下拉框中的值，使用Text属性或者selectItem属性其中Text返回的是字符串，而selectItem返回的是对象。</p><p>​string str &#x3D; comboBox1.Text;</p><p>​      string obj &#x3D; comboBox1.SelectedItem.ToString();</p><p>​      MessageBox.Show(str+obj);</p><p>禁止用户在下拉框中输入数据：将属性中的DropDownStyle更改为dropdownlist模式。 </p><h3 id="RichTextBox"><a href="#RichTextBox" class="headerlink" title="RichTextBox"></a>RichTextBox</h3><h3 id="checkBox复选框"><a href="#checkBox复选框" class="headerlink" title="checkBox复选框"></a>checkBox复选框</h3><p>​修改大小：在布局&#x3D;》aotusize改为false，然后可以拖动更改大小，但是意义不大。</p><p>​设置默认选中，在外观&#x3D;》checked改为true即可</p><p>​Checkbox的三种状态：checked，unchecked，Indeterminate（树结构时，全选则显示对号，部分选择则显示篮筐，未选则为空框）</p><p>​获取所有checkBox，根据源码发现，所有checkBox都放在controls这个集合里面</p><p>​for(int I;i &lt; this.controls.count;i++){</p><p>​CheckBox1  cb1 &#x3D; (CheckBox1)this.Controls[i];</p><p>}</p><h3 id="进度条：Trackbar控件。"><a href="#进度条：Trackbar控件。" class="headerlink" title="进度条：Trackbar控件。"></a>进度条：Trackbar控件。</h3><p>修改步长：将maxxmum实际上它的大小取决于每个歌曲的时间长度，maximum是最大值，value是图片中的小游标。</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/wpsD638.tmp.jpg" alt="img"> </p><h3 id="Progressbar（进度条）控件"><a href="#Progressbar（进度条）控件" class="headerlink" title="Progressbar（进度条）控件"></a>Progressbar（进度条）控件</h3><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20210228133139651.png" alt="image-20210228133139651"></p><p>​</p><p>​基本属性：MaxNum最大值，</p><p>​minNum最小值，</p><p>​value，当前值。</p><p>​step。每次调用PerformStep方法时的进度。默认为10，调用一次增加10%，但是这种方式是固定增量，在实际应用中不可能这样应用 。所以通过操控value值进行进度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">       &#123;</span><br><span class="line">           //为button1设置后退</span><br><span class="line">           if (progressBar1.Value &gt; progressBar1.Minimum)</span><br><span class="line">           &#123;</span><br><span class="line">               progressBar1.Value = progressBar1.Value - progressBar1.Step;</span><br><span class="line">               button1.Text = progressBar1.Value.ToString();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private void button2_Click(object sender, EventArgs e)</span><br><span class="line">       &#123;</span><br><span class="line">           //为button2设置前进</span><br><span class="line">           //progressBar1.PerformStep();这种方法不够实际，因为他是每次固定增加一定的step</span><br><span class="line">           </span><br><span class="line">           //使用下面这种方法，通过操控value值进行增加</span><br><span class="line">           for (int i=0; i &lt;= progressBar1.Maximum; i++)</span><br><span class="line">              &#123;  </span><br><span class="line">              progressBar1.Value = i;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           button1.Text = progressBar1.Value.ToString();</span><br><span class="line">               </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="NumericUpDown（数字输入框）控件"><a href="#NumericUpDown（数字输入框）控件" class="headerlink" title="NumericUpDown（数字输入框）控件"></a>NumericUpDown（数字输入框）控件</h3><p>​属性：只能输入数字，负号，小数点</p><p>​textAlin：设置文本显示的位置，左对齐，居中，右对齐</p><p>​Hexadecimal：以16进制显示数据</p><p>​Increment：按向上或向下键进行增减。</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20210228135015953.png" alt="image-20210228135015953"></p><h3 id="ToolTip（提示信息）控件"><a href="#ToolTip（提示信息）控件" class="headerlink" title="ToolTip（提示信息）控件"></a>ToolTip（提示信息）控件</h3><p>​toolTip1.InitialDelay &#x3D; 1000;&#x2F;&#x2F;悬停时间<br>​            toolTip1.AutoPopDelay &#x3D; 1000;&#x2F;&#x2F;提示保存的时间<br>​            toolTip1.AutomaticDelay &#x3D; 1000;&#x2F;&#x2F;延迟时间<br>​            toolTip1.ReshowDelay &#x3D; 1000;&#x2F;&#x2F;转换到其他控件时的时间间隔；</p><h3 id="Notifylcon-托盘控件"><a href="#Notifylcon-托盘控件" class="headerlink" title="Notifylcon(托盘控件)"></a>Notifylcon(托盘控件)</h3><p>就是点击最小化之后显示在桌面右下角的最小化窗口中，例如360等，注意只有为控件添加背景图片之后才能够看得见。如果想要双击之后仍然能够打开原来的窗口，则在事件doubleClick中写入Windowstate &#x3D; FormWindowState.Normal即可</p><h3 id="ConTextMenuStrip（右键之后显示菜单）控件"><a href="#ConTextMenuStrip（右键之后显示菜单）控件" class="headerlink" title="ConTextMenuStrip（右键之后显示菜单）控件"></a>ConTextMenuStrip（右键之后显示菜单）控件</h3><h3 id="timer（时钟）控件"><a href="#timer（时钟）控件" class="headerlink" title="timer（时钟）控件"></a>timer（时钟）控件</h3><p>当调用timer.start()的时候，就会执行timer事件,一般将需要频率执行的方法写在timer方法里面，然后通过设置time.start()来启动执行timer事件里面的方法。执行timer里面的方法有两种方式：1.使用timer.start()  2.设置timer.enable&#x3D;true;</p><h3 id="DateTimePicker（日期选择）控件"><a href="#DateTimePicker（日期选择）控件" class="headerlink" title="DateTimePicker（日期选择）控件"></a>DateTimePicker（日期选择）控件</h3><p>​属性：Format：long（年月日），</p><p>​short（xx&#x2F;xx&#x2F;xx），</p><p>​time（时：分：秒），</p><p>​custom自定义（同时设置格式属性customFormat按照yy-MM-dd HH:mm:ss）。</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20210228172837013.png" alt="image-20210228172837013"></p><h3 id="TreeView（树）控件"><a href="#TreeView（树）控件" class="headerlink" title="TreeView（树）控件"></a>TreeView（树）控件</h3><p>​属性：Nodes  每个子节点作为一个选项。最直接的例子是windows中的注册表</p><p>​HotTracking：移动至该节点的时候，该节点的文字会自动添加下划线</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20210228180018611.png" alt="image-20210228180018611"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //添加节点第一中方式</span><br><span class="line">            treeView1.Nodes.Add(&quot;添加的第一个节点&quot;);</span><br><span class="line"></span><br><span class="line">            //第二种方式</span><br><span class="line">            TreeNode tn = new TreeNode();</span><br><span class="line">            tn.Name = &quot;tn2&quot;;</span><br><span class="line">            tn.Text = &quot;第二个节点&quot;;</span><br><span class="line">            treeView1.Nodes.Add(tn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void button2_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            //移除最后一个节点</span><br><span class="line">            treeView1.Nodes.RemoveAt(treeView1.Nodes.Count-1);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="LIstVIew（列表）控件"><a href="#LIstVIew（列表）控件" class="headerlink" title="LIstVIew（列表）控件"></a>LIstVIew（列表）控件</h3><p>属性：view：显示模式，常用为details</p><p>项：就是行（每个ListViewItem就是一行）。Items中的列就是列（SubItems是子列）</p><p>Gridines:显示出网格</p><h3 id="单选框radioButton"><a href="#单选框radioButton" class="headerlink" title="单选框radioButton"></a>单选框radioButton</h3><p>​Checked的属性：true和false,默认选中和非默认选中</p><h3 id="GroupBox的作用："><a href="#GroupBox的作用：" class="headerlink" title="GroupBox的作用："></a>GroupBox的作用：</h3><p>1.为radioBox划定区域,控制整个界面的整体边界。</p><p>2.为其他控件划定区域，将其他控件直接拖到gruopBox上即可，相当于背景墙一样。</p><p>容器的作用：</p><p>1， 当需往页面上使用代码添加控件的时候，容器的作用就体现出来了，使用使用容器中的添加方法进行控件的操作。例如groupbox，panel等。容器上面的控件就属于容器的一种子控件。如果不使用容器，那么无法动态加载控件。比如说抽奖系统抽取哪个人就在容器上添加某个人图片。</p><p>2， 所有控件需要整体移动的时候体现出容器的作用。</p><p>3， Dock的作用：第一个控件占用了一部分区域，那么第二个控件就占用剩下的区域，而不是占用整个父容器的区域。</p><h3 id="ListBox：列表框"><a href="#ListBox：列表框" class="headerlink" title="ListBox：列表框"></a>ListBox：列表框</h3><p>与多行的textBox差不多，只不过ListBox里面的数据是一个数组，每一行是个数组元素。它集合了textBox和comboBox的所有优点。即多行同时显示和每行数据都是个数组元素。不管是listbox还是combox等这些存放集合的控件，里面的行集合就是items属性。</p><p>​获取所选中的所有对象集合object o &#x3D; listBox1.SelectedItems;</p><p>​往listbox中添加数据：fileName是个string数组</p><p>foreach (string item in fileName)</p><p>​        {</p><p>​          listBox1.Items.Add(item);&#x2F;&#x2F;往listbox中添加</p><p>​        }</p><p>​Listbox中每个元素选择对应一个索引，不同于自己设置的数组，listbox中selectIndex就是高亮显示的对应的元素(即被激活的元素)。对其进行赋值就是激活哪个元素。使用listbox.selectIndex &#x3D; listBox.selectIndex-1本身就是个错误，因为该索引要求最小为0，否则报异常，即使使用ifelse语句排除，上面这个索引本身已经发生了改变无法规避，所以借用第三方变量i,进行取值和赋值操作。（在音乐播放器项目中有所体现）</p><p>​Listbox中的selectIndex和selectItem的区别，前者是int类型，通过赋值进行激活元素的更改。而selectItem只表示当前选中的元素，只有获取当前选中元素的名称的作用</p><p>获取集合中某个选项最好的办法就是获取它的索引。</p><h3 id="PictureBox图片显示"><a href="#PictureBox图片显示" class="headerlink" title="PictureBox图片显示"></a>PictureBox图片显示</h3><p>Image属性：设置显示图片的属性</p><p>​为Image属性添加图片手动代码。获取文件路径之后picture.Image &#x3D; Image.FromFile(Path);&#x2F;&#x2F;Path为图片的路径</p><p>​Sizemode属性：显示图片的方式，normal（不做任何效果显示），stretchImage铺满整个图片控件（通常使用这个模式），AntoSize：自动大小（控件的大小随着图片的大小而改变）CenterImage：显示中间。Zoom：缩放</p><h3 id="Timer控件"><a href="#Timer控件" class="headerlink" title="Timer控件"></a>Timer控件</h3><p>​Interval：改为1000，每次间隔时间为1秒，它只有一个tick事件，timer1.enable &#x3D; true开始调用tick事件。即在其他方法中写入timer1.enable &#x3D; true开始按照设定间隔1秒执行tick里面的代码。</p><p>OpenFileDialog和FileBrowerDialog文件选择控件</p><p>注意，是在其他控件的click事件中，调用打开文件的方法</p><h3 id="listview"><a href="#listview" class="headerlink" title="listview"></a>listview</h3><p>listview与listbox的区别是，listview多了一个view属性，可以显示多列，而listbox只能显示一列。即listview相当于一个表格</p><p>属性：每一个ListViewItem都是一行，它的text属性，就是该行该列中对应的内容，它的subItem都是该位置对应的后面的所有列</p><p>​CheckBox属性设为true，同时listViewItem中的checked属性设为true，才会出现默认选中框</p><p>​FullRowSelect：整行都被选中</p><p>​第一列只能左对齐，其余列可以设置居中显示</p><p>​Items：是所有行的集合，ListViewItem是一行，也就是所有列的集合。</p><h3 id="checkedlistbox"><a href="#checkedlistbox" class="headerlink" title="checkedlistbox"></a>checkedlistbox</h3><p>和checklistbox差不多，只不过是将checkbox的集合，里面可以放多个checkbox</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20221004210355938.png" alt="image-20221004210355938"></p><h3 id="MenuStrip菜单栏"><a href="#MenuStrip菜单栏" class="headerlink" title="MenuStrip菜单栏"></a>MenuStrip菜单栏</h3><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930170649613.png" alt="image-20220930170649613"></p><h3 id="ContextMenustrip"><a href="#ContextMenustrip" class="headerlink" title="ContextMenustrip:"></a>ContextMenustrip:</h3><p>右键时候出现的菜单。将ContextMenuStrip绑定在listView上方法：当添加ContextMenuStrip控件之后，默认在ListView属性中会有ContextMenustrip属性，将其选择即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line"></span><br><span class="line">​    private void 添加ToolStripMenuItem_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //当右键点击添加的时候，为表格添加一列</span><br><span class="line"></span><br><span class="line">​      ListViewItem lvi = new ListViewItem();</span><br><span class="line"></span><br><span class="line">​      lvi.Text = i.ToString() ;//第一列</span><br><span class="line"></span><br><span class="line">​      lvi.SubItems.Add(&quot;3&quot;);//第二例</span><br><span class="line"></span><br><span class="line">​      lvi.SubItems.Add(&quot;3&quot;);//第三列</span><br><span class="line"></span><br><span class="line">​      lvi.SubItems.Add(&quot;3&quot;);//第四列</span><br><span class="line"></span><br><span class="line">​      lvi.SubItems.Add(&quot;3&quot;);//第五列</span><br><span class="line"></span><br><span class="line">​      listView1.Items.Add(lvi);</span><br><span class="line"></span><br><span class="line">​      i++;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  private void 删除ToolStripMenuItem_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      //从第一个开始进行删除</span><br><span class="line"></span><br><span class="line">​      ListViewItem lvi = listView1.SelectedItems[i];</span><br><span class="line"></span><br><span class="line">​      listView1.Items.Remove(lvi);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="TreeView："><a href="#TreeView：" class="headerlink" title="TreeView："></a>TreeView：</h3><p>最直观的是注册表</p><p>​Showlines:是否显示树控件的引导线。</p><p>FullRowSelect:点击文字所在的行也可以进行展开显示</p><p>​Nodes:是所有节点的集合</p><p>​ToolTip：气泡提示控件</p><p>​TooltipIcon:提示方式。信息，警告，错误。</p><p>手动添加节点的代码：</p><p>​TreeNode ankai &#x3D; treeView1.Nodes[0].Nodes[4];</p><p>​      ankai.Nodes.Add(new TreeNode() { </p><p>​        Text &#x3D; “保利通”</p><p>​      });</p><p>​ShowPlusMinus:设置是否显示文字前面的折叠符号。去掉前面的折叠符号后，发现点击后不能显示其子项：解决方法：使用AfterSelect事件，在方法中显示子项即可，实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)  &#123;</span><br><span class="line"></span><br><span class="line">​      TreeNode tn = e.Node;//获取当前点击的node</span><br><span class="line"></span><br><span class="line">​      if (tn != null) &#123; </span><br><span class="line"></span><br><span class="line">​        //判断是否有子节点</span><br><span class="line"></span><br><span class="line">​        //判断是否为根节点，是：展开子项，否（子节点）：全部展开</span><br><span class="line"></span><br><span class="line">​        if (tn.Nodes.Count &gt; 0)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          if (tn.Parent == null)//该节点是否为根节点</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            tn.Expand();//展开二级节点</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else &#123;//若点击的是为二级节点，展开后折叠</span><br><span class="line"></span><br><span class="line">​            if (tn.IsExpanded)</span><br><span class="line"></span><br><span class="line">​            &#123;</span><br><span class="line"></span><br><span class="line">​              tn.Collapse();</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            else&#123; //全部展开</span><br><span class="line"></span><br><span class="line">​              tn.ExpandAll();</span><br><span class="line"></span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="Toolstripcombobox-他是toolstrip中的一个子控件"><a href="#Toolstripcombobox-他是toolstrip中的一个子控件" class="headerlink" title="Toolstripcombobox,他是toolstrip中的一个子控件"></a>Toolstripcombobox,他是toolstrip中的一个子控件</h3><p>为toolstripcombox添加选择值，在属性中的item添加集合即可。 而combobox是一个单独的控件。</p><h3 id="打开文件组件"><a href="#打开文件组件" class="headerlink" title="打开文件组件"></a>打开文件组件</h3><p>OpenFileDialog方法，返回结果为DialogResult</p><p>设置只能打开图片文件和txt文件：openDialog.Filter &#x3D; “ *.jpg| *.bmp | *.txt”;</p><h3 id="保存组件"><a href="#保存组件" class="headerlink" title="保存组件"></a>保存组件</h3><p>SaveFileDialog的showdialog方法。返回结果为dialogResult</p><h3 id="选择文件夹组件"><a href="#选择文件夹组件" class="headerlink" title="选择文件夹组件"></a>选择文件夹组件</h3><p>FolderBrowerDialog的showdialog方法，返回结果为DialogResult</p><h3 id="设置字体组件"><a href="#设置字体组件" class="headerlink" title="设置字体组件"></a>设置字体组件</h3><p>FontDialog</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20221004213517565.png" alt="image-20221004213517565"></p><h3 id="设置颜色组件"><a href="#设置颜色组件" class="headerlink" title="设置颜色组件"></a>设置颜色组件</h3><h3 id="Panel面板"><a href="#Panel面板" class="headerlink" title="Panel面板"></a>Panel面板</h3><p>相当于背景板，可以批量操作子控件。与GroupBox的区别是GroupBox在左上角有个标签提示，如果使用Dork属性发现一个控件被另一个控件覆盖了了，那么右键将其置于底层即可。·</p><p>打开多个文件：设置multiselect属性为true</p><h3 id="SplitContainer"><a href="#SplitContainer" class="headerlink" title="SplitContainer"></a>SplitContainer</h3><p>可以在运行时进行拖拉的控件，类似于QQ窗口一样。点击右上角的小三角可以将水平更改为垂直</p><p>属性isSplitterFixed为false时设置可以拖动，true时不可以拖动</p><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/wps3239.tmp.jpg" alt="img"> </p><h4 id="toolStrip工具栏"><a href="#toolStrip工具栏" class="headerlink" title="toolStrip工具栏"></a>toolStrip工具栏</h4><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/image-20220930170538802.png" alt="image-20220930170538802"></p><h3 id="RichTextBox控件"><a href="#RichTextBox控件" class="headerlink" title="RichTextBox控件"></a>RichTextBox控件</h3><p>功能强大：可以添加文本，图片等。</p><p>可以添加文本链接：可以使用Text属性添加，2.使用richTextBox1.AppendText(“<a href="http://www.tengxun.com" );方法进行添加、 ">www.tengxun.com&quot;);方法进行添加、</a></p><h3 id="Tabcontrol选项卡"><a href="#Tabcontrol选项卡" class="headerlink" title="Tabcontrol选项卡"></a>Tabcontrol选项卡</h3><p><img src="/2026/01/29/winform%E5%AD%A6%E4%B9%A0/assets/wps323A.tmp.jpg" alt="img"> </p><h3 id="用户控件：（UserControl）。"><a href="#用户控件：（UserControl）。" class="headerlink" title="用户控件：（UserControl）。"></a>用户控件：（UserControl）。</h3><p>将窗体中已经布局好界面一部分单独创立一个文件独立出去，这样可以节约主窗体中的代码，使用的时候直接引用即可。样式与panel差不多</p><p>用户控件UserControls，相当于一个不带边框的窗体</p><p>拆分层级的方法：</p><p>1． 如果两个控件交互较多时，选择单一层级</p><p>2． 如果当前界面不确定因素较多（功能改动&#x2F;界面改动）较多，采用多层级方式</p><p>​Usercontrol作为一个独立控件，拥有自己的设计界面和代码，它是一个控件，可以在工具箱中引用，但是它是一个独立的文件。Panel则不是。</p><p>​UserControl拥有的load事件，但是panel没有。Load时间当usercontrol复制到窗体的时候会自动执行。</p><p>​UserControl可以跨窗体使用，但是panel没有。</p><p>​复制之后usercontrol可以将里面的所有控件和代码进行复制，而panel仅仅能复制panel一个控件，里面的内容和代码无法赋值</p><p>引用方法：文件资源管理器项目文件夹右键生成，在工具箱中会自动出现usercontrol控件</p><p>​优点：加载不同控件的集合，对主窗体的功能进行分区，从而加载不同的控件。类似于GroudBox</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>对文件进行简单操作(增删改查)使用File类，或者使用FileInfo,两者都能实现相同的操作，后者比前者功能更多。</p><p>使用场景：如果对同一个文件频繁操作，使用FileInfo类，如果是仅操作一次使用File类，因为涉及到安全检查。</p><p>File文件类是个静态类，无法创建对象。File.Create()（增加),File.Delete()(删除),File.Exists()（查询）;File.Move()（修改），File.Copy();</p><p>FileStream一般不使用，只有在操作字节的时候才会使用（进行对文件内容的读写操作），比如大文件的复制操作。而File类用来进行整个文件的操作。只有文件open()打开之后，才能对文件里面的内容进行操作。</p><h4 id="FileInfo对象"><a href="#FileInfo对象" class="headerlink" title="FileInfo对象"></a>FileInfo对象</h4><p>​f.Attributes&#x3D; FileAttribute.readonly设置为只读</p><p><strong>获取路径+文件名</strong></p><p>通过OpenFiledialog的filename获取文件名，</p><p>fileInfo的FullName属性</p><p><strong>仅获取文件名</strong></p><p>获取文件名FileInfo的Name属性</p><p><strong>获取路径名</strong></p><p>获取路径名使用FolderBrowerDialog.SeletedPath获取路径</p><p>FileInfo的DirectoryName用来获取路径名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(1)File 提供用于创建、复制、删除、移动和打开文件的静态方法，并协助创建 FileStream。</span><br><span class="line"></span><br><span class="line">    FileStream fs = File.Open(txtpath, FileMode.Open);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    File可以直接调用各种方法(Open、Delete、Exists等)</span><br><span class="line"></span><br><span class="line">    例如： if (File.Exists(txtpath))</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                File.Delete(txtpath);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">(2)FileInfo 提供用于创建、复制、删除、移动和打开文件的实例方法，并协助创建 FileStream。</span><br><span class="line"></span><br><span class="line">    FileInfo fi = new FileInfo(txtpath); //实例化</span><br><span class="line"></span><br><span class="line">    FileStream fs = fi.Open();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(3)FileStream 支持通过其 Seek 方法随机访问文件。默认情况下，FileStream 以同步方式打开文</span><br><span class="line"></span><br><span class="line">   件，但它也支持异步操作。</span><br><span class="line"></span><br><span class="line">   利用FileStream 我们可以得到一个文件的Streams，接着就是来读取。</span><br><span class="line"></span><br><span class="line">(4)StreamReader 通过使用 Encoding 进行字符和字节的转换，从 Streams 中读取字符。</span><br><span class="line"></span><br><span class="line">    StreamWriter 通过使用 Encoding 将字符转换为字节，向 Streams 写入字符。</span><br><span class="line"></span><br><span class="line">    StreamReader sr = new StreamReader(fs);</span><br><span class="line"></span><br><span class="line">            string str = null;</span><br><span class="line">            string temp=null;</span><br><span class="line">            while((temp=sr.ReadLine())!=null)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">               str+=” “+temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">     得到一个字符串，再可以对字符串进行处理。</span><br></pre></td></tr></table></figure><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><p>获取文件夹创建时间：DirectoryInfo对象的CreationTime属性</p><p>获取应用程序所在目录：MessageBox.Show(Application.StartupPath);</p><p>判断文件夹是否存在：DirectoryInfo 对象的Exsits属性</p><p>与文件操作一样，文件夹操作也有DirectoryInfo和Directory两种方法，推荐使用前者，后者是对文件进行一次操作的时候使用</p><p>包含create，  delete，move，exisits等操作</p><p>DirectoryInfo类的GetFilesSystemInfos()方法可以获取文件夹中的所有子文件夹和文件(统一使用),返回类型为FileSystemInfo数组，他包含对文件和文件夹操作的所有方法。FileSystemInfos是FileInfo和DirectoryInfo的集合。</p><h3 id="文件流操作"><a href="#文件流操作" class="headerlink" title="文件流操作"></a>文件流操作</h3><p>文件流是对文件里面的内容进行操作的，比如说文字，图片等。</p><p>streamWriter和StreamReader</p><p>write()写入数据</p><p>readLine()读取一行</p><p>readTiEnd()读到末尾</p><h4 id="二进制文件读取"><a href="#二进制文件读取" class="headerlink" title="二进制文件读取"></a>二进制文件读取</h4><p>使用binaryWriter和BinaryReader类</p><h3 id="WebBrower控件"><a href="#WebBrower控件" class="headerlink" title="WebBrower控件"></a>WebBrower控件</h3><h3 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h3><p>通过代码去开启对应的程序：Process.Start(“程序名称”);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"> Process.Start(&quot;main.cpl&quot;);开启鼠标设置</span><br><span class="line"> Process.Start(&quot;desk.cpl&quot;);开启桌面设置窗口</span><br></pre></td></tr></table></figure><p>是否将图标显示在任务栏上：this.ShowInTaskBar &#x3D; true;设置窗口的showintaskbar属性为显示</p><p>调用外部的可执行文件：同理使用Process.Start()函数。</p><h2 id="winform加载word"><a href="#winform加载word" class="headerlink" title="winform加载word"></a>winform加载word</h2><p>1.在winform中浏览网页或者浏览word文件：（前提是联网），主要使用的menustrip控件创建菜单，然后使用webBrower控件添加一个浏览的页面，使用webbrower中的navigate方法，代码如下，定义在“打开”控件里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void 打开ToolStripMenuItem_Click(object sender, EventArgs e)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      OpenFileDialog of = new OpenFileDialog();</span><br><span class="line"></span><br><span class="line">​      DialogResult dr =  of.ShowDialog();</span><br><span class="line"></span><br><span class="line">​      if (dr == DialogResult.OK)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        webBrowser1.Navigate(of.FileName);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><p>2.创建新word文件</p><p>首先创建applacation对象，它的documents属性返回documents对象，它是操作word程序的集合，使用add方法即可创建新word。</p><p>需要引入com组件中的mircosoft word。。。文件</p><h3 id="sqldataAdapter，dataset，datatable，sqldatareader，sqlcommand。"><a href="#sqldataAdapter，dataset，datatable，sqldatareader，sqlcommand。" class="headerlink" title="sqldataAdapter，dataset，datatable，sqldatareader，sqlcommand。"></a>sqldataAdapter，dataset，datatable，sqldatareader，sqlcommand。</h3><p>sqldataadapter和sqlcommand是同一类作用：是用来封装sql语句命令对象的。</p><p>dataset，datatable，sqldatareader是同一类作用，用来确定查询结果的返回方式。</p><p>sqldatareader是通过键值对的方式访问返回结果。sqldatareader与sqlcommand匹配使用。sqldataadapter与dataset，datatable匹配使用。</p><p>DataSet ds 是放在内存里面的，你可以把它想像成里面有多张表，里面的内容就是你查询得到的内容。当我们要使用这些数据的时候（如显示查询的内容，统计里面的值等）直接用ds访问。修改ds的内容，不会影响到数据库的数据。如果你要修改数据库的数据，要启用到 Update 或者 Inster等SQL语句，这是要另外写程序的</p><p>datatable是具体的某一张表，它是dataset的一部分。一个dataset可以包括多个datatable。实际上dataset相当于一个临时内存数据库，datatable相当于一个临时内存数据表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SqlSugar</title>
      <link href="/2026/01/29/SqlSugar/"/>
      <url>/2026/01/29/SqlSugar/</url>
      
        <content type="html"><![CDATA[<p>nuget:sqlsugarcore</p><p>注：所有不能完成增删改查并且报错的原因是因为使用了sqlsugar的包而不是sqlsugarcore的包</p><p>注意：使用第一种方式进行IOC注入的时候，不用通过构造函数再进行注入了，而是直接使用Dbscope.sugarScope这个全局对象即可。但是不推荐第一种方法，而是直接使用第二种方法（net注入），因为第一种方法无法使用SimpleClient中的特有方法。</p><p>首先根据表生成实体类</p><p>sqlClient：不能跨上下文，若出现错误则换成sqlscope</p><p>SqlScope：线程安全，必须使用异步方式</p><p>0.里面的所有的db都是为sqlclient对象。</p><span id="more"></span><p>1.在main方法中通过创建对象的方式引入SqlClient。<a href="https://www.donet5.com/Home/Doc?typeId=1181">https://www.donet5.com/Home/Doc?typeId=1181</a></p><p>2.通过特性设置主键，自增。<a href="https://www.donet5.com/Home/Doc?typeId=1182">https://www.donet5.com/Home/Doc?typeId=1182</a></p><p>3.连接一个数据库，和同时连接多个数据库（租户事务）：<a href="https://www.donet5.com/Home/Doc?typeId=1183">https://www.donet5.com/Home/Doc?typeId=1183</a></p><p>4.查询：当从Querable变成非Querable的时候会自动执行操作数据库，而不需要再使用executecommand，所以执行查询时，querable后面必有一个tolist（），或者First（）等改变Querable类型的方法。</p><p>​1）查所有，按条件查询，多条件查询，动态查询，模糊查询，主键查询，查询第一条，查询前几条，获取查询结果的行数。。。<a href="https://www.donet5.com/Home/Doc?typeId=1187">https://www.donet5.com/Home/Doc?typeId=1187</a></p><p>​2）分页查询，<a href="https://www.donet5.com/Home/Doc?typeId=2242">https://www.donet5.com/Home/Doc?typeId=2242</a></p><p>​3）分组查询，去重查询，<a href="https://www.donet5.com/Home/Doc?typeId=2243">https://www.donet5.com/Home/Doc?typeId=2243</a></p><p>​4）排序，<a href="https://www.donet5.com/Home/Doc?typeId=2312">https://www.donet5.com/Home/Doc?typeId=2312</a></p><p>​5）异步查询：<a href="https://www.donet5.com/Home/Doc?typeId=1189">https://www.donet5.com/Home/Doc?typeId=1189</a></p><p>5.插入：<a href="https://www.donet5.com/Home/Doc?typeId=1193">https://www.donet5.com/Home/Doc?typeId=1193</a></p><p>6.删除：<a href="https://www.donet5.com/Home/Doc?typeId=1195">https://www.donet5.com/Home/Doc?typeId=1195</a></p><p>7.修改：<a href="https://www.donet5.com/Home/Doc?typeId=1191">https://www.donet5.com/Home/Doc?typeId=1191</a></p><p>8.建库建表：<a href="https://www.donet5.com/Home/Doc?typeId=1206">https://www.donet5.com/Home/Doc?typeId=1206</a></p><p>9.注意前面都是通过自动创建sqlclient对象的方式获取的，如果使用IOC容器，需要注册的。</p><p><strong>10</strong>，当仓储层继承了SimpleClient时，里面自带了与前面不同的方法，直接调用即可（不用执行后面的执行语句ExecuteCommad,这是优点），当然也可以使用前面中的方法而且前面中的方法更加全面。其中base指的是父类及simpleClient中的方法。<a href="https://www.donet5.com/Home/Doc?typeId=1228">https://www.donet5.com/Home/Doc?typeId=1228</a></p><p>在创建仓库时分析代码里面的含义：原本应该是应该在Reposiroy里面定义一个变量来接受IsqlSugarClient对象，这样就可以使用里面的方法，但是换一种思路，我们可以将该对象传入给SimpleClient构造函数，使用base的方式使用SqlSugar对象里面的方法也是一样的，同时可以使用SimpleClient里面特有的方法。这样有一个弊端，那就是如果实现Reposity的子类如果想要使用sqlsugar对象中的方法，其构造方法也必须写成Repository中构造方法的样子，因为父类的有参构造，子类必须继承。</p><p><img src="/2026/01/29/SqlSugar/assets/image-20220205121645864.png" alt="image-20220205121645864"></p><p>观察SimpleClient类发现，这才是标准的构造注入，获取了IsqlSugarCilent对象，使用里面的方法。</p><p><img src="/2026/01/29/SqlSugar/assets/image-20220205120923215.png" alt="image-20220205120923215"></p><p>11.使用sqlsugar第一种方式注入时，应使用services.addsqlsugar,而不是sugarservices.addsugar();</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>net5项目</title>
      <link href="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/"/>
      <url>/2026/01/29/net5%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>项目技巧：根据页面去写类的技巧：无论是写wpf还是web前端，划分类时，将局部页面的一些除了数据不一样其他都一样的部分写成类，（该种类型的数据占大部分，但是数据不是可变的而是固定的，若是可变的，则写在viewmodel中）然后使用前端语言去加载该类并进行绑定，而不是直接使用标签将显示的内容写死，因为会出现大量重复代码。同时，类只是最基础的，因为它是相似数据，所以必须使用创建集合去封装该类。</p><span id="more"></span><p>遵循技巧如下：</p><p>1.分析每个页面中的所有部分，需分成可变部分和不变部分</p><p>2.对于每个页面中的可变部分，需使用ViewModel，对于不可变部分并且重复，需使用基础类和集合通过已有的ViewModel进行绑定</p><p>3.如果需要封装类和集合，那么考虑里面所有的元素封装成类之后都有哪些属性</p><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20230204210400351.png" alt="image-20230204210400351"></p><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20230204203216222.png" alt="image-20230204203216222"></p><p>如上：上面图片的所有元素都是不可变元素，并且导航部分都是重复的，所以构建一个类进行封装，属性包含图片，标题，以及导航的路径。对于不可变部分最终都是被应用到ViewModel里面，不过不是自己的ViewModel而是整体页面的ViewModel</p><p>如下：将页面划分为2行2列</p><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20230214195728686.png" alt="image-20230214195728686"></p><h1 id="项目1："><a href="#项目1：" class="headerlink" title="项目1："></a>项目1：</h1><h2 id="1-在返回的Json中修改时间格式"><a href="#1-在返回的Json中修改时间格式" class="headerlink" title="1.在返回的Json中修改时间格式"></a>1.在返回的Json中修改时间格式</h2><p><a href="https://bxshare.top/index.php/archives/11/">https://bxshare.top/index.php/archives/11/</a></p><h2 id="2-修改swagger中的界面"><a href="#2-修改swagger中的界面" class="headerlink" title="2.修改swagger中的界面"></a>2.修改swagger中的界面</h2><p><a href="https://bxshare.top/index.php/archives/12/">https://bxshare.top/index.php/archives/12/</a></p><h2 id="3-Sqlsugar注入"><a href="#3-Sqlsugar注入" class="headerlink" title="3.Sqlsugar注入"></a>3.Sqlsugar注入</h2><p><a href="https://www.donet5.com/Home/Doc?typeId=2247%E6%B3%A8%E6%84%8F%E6%98%AFsqlsugarcore%E7%9A%84%E5%8C%85%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFsqlsugar%E7%9A%84%E5%8C%85">https://www.donet5.com/Home/Doc?typeId=2247注意是sqlsugarcore的包，而不是sqlsugar的包</a></p><p>注意：使用sqlsugar的第二种方式进行注入时，在SqlsugarSetup类中应将                ConnectionString &#x3D; configuration.GetConnectionString(dbName),换为ConnectionString &#x3D;Configuration[dbname],因为前者无法获取数据库连接字符串。</p><p>配置连接字符串</p><p>创建控制器利用codefirst生成数据库,建表</p><h2 id="4-三层架构"><a href="#4-三层架构" class="headerlink" title="4.三层架构"></a>4.三层架构</h2><ul><li><strong>表示层</strong>(User Interface layer)&#x3D;web&#x3D;UI&#x3D;Controller&#x3D;控制器：主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。</li><li><strong>业务逻辑层</strong>(Business Logic Layer)&#x3D;BLL&#x3D;service：业务逻辑层 BLL 的功能是对具体问题进行逻辑判断与执行操作，接收到表现层 UI 的用户指令后，会连接数据访问层 DAL。业务逻辑层用于做一些有效性验证的工作。如完成数据添加、修改和查询业务用户登录，<font color="red">凡是用到需要调用dal层中数据库增删改查的操作都是写在BLL层中，比如登录，注册等，而dal层只是基本的增删改查功能</font>&gt;；不允许指定的文本框中输入空字符串，数据格式是否正确以及数据类型验证；用户权限的合法性判断等；通过以上的诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。之前所有的判断都是放在了Controller中，实际上这都是错误的，而是应该放在BLL层，Controller只是起到UI的作用。它是DAL的上一层，他需要引用ef，dal层，dto层，model层，它对应dal层的Service，一个manager对应一个Service。在manager方法中调用Service方法即可。</li><li><strong>数据访问层</strong>(Data access layer)&#x3D;dao&#x3D;Mapper&#x3D;Repository：数据访问层 DAL 是对数据库主要操控，实现数据的增加、删除、修改、查询等操作，并将操作结果反馈到业务逻辑层 BLL。</li><li><strong>实体类库</strong>（model&#x2F;entity）：就是数据表中对应的实体类</li><li><strong>通用层</strong>：（Common）：一些通用的辅助类和工具类</li></ul><p>MVC与三层架构的关系，MVC中的V和C就是三层架构中的UI层，而三层架构中的BLL和DAL和Model层就是MVC中的Model层,在webapi中没有了V所以C就是UI层</p><p>而调用流程是Repository引用Models层，Service层引用Repository层，Net（UI）引用Service层</p><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20220202215116862.png" alt="image-20220202215116862"></p><h3 id="Model层"><a href="#Model层" class="headerlink" title="Model层"></a>Model层</h3><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20220202220005580.png" alt="image-20220202220005580"></p><h3 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h3><p>repository的作用：实际上他是等价于Dao层的，只不过dao层中进行增删改查，因为数据库中有很多表，所以dao层中，每个表的增删改查都需要重写一边，那么就重复性工作，所以单独创建一个Repository层，该层创建一个Repository的实体类和泛型接口，该接口封装了对所有的表的操作的常用方法，这样，我们在调用的时候只需要传入对应的实体类即可完成增删改查操作。对于一些更细致的方法，让Dao层自己去实现。</p><p><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20220202220242360.png" alt="image-20220202220242360"></p><h2 id="5-添加泛型仓储，重新注入"><a href="#5-添加泛型仓储，重新注入" class="headerlink" title="5.添加泛型仓储，重新注入"></a>5.添加泛型仓储，重新注入</h2><p><a href="https://www.donet5.com/Home/Doc?typeId=1228">https://www.donet5.com/Home/Doc?typeId=1228</a></p><h2 id="6-设置路由"><a href="#6-设置路由" class="headerlink" title="6.设置路由"></a>6.设置路由</h2><p><a href="https://bxshare.top/index.php/archives/22/">https://bxshare.top/index.php/archives/22/</a></p><h2 id="7-fluentvalidation"><a href="#7-fluentvalidation" class="headerlink" title="7.fluentvalidation"></a>7.fluentvalidation</h2><h2 id="8-跨域"><a href="#8-跨域" class="headerlink" title="8.跨域"></a>8.跨域</h2><p><a href="https://bxshare.top/index.php/archives/24/">https://bxshare.top/index.php/archives/24/</a></p><h2 id="9-JWT"><a href="#9-JWT" class="headerlink" title="9.JWT"></a>9.JWT</h2><h1 id="项目二：MyBlog"><a href="#项目二：MyBlog" class="headerlink" title="项目二：MyBlog"></a>项目二：MyBlog</h1><p>1.创建数据库表，添加主键，特性</p><p>2.创建仓储层接口，并对应实现仓储类,使用泛型仓储</p><p>IBaseRepository中有如下通用方法，每个实体层接口在继承IRepository接口的情况下还有自己的方法。接口只写Ipository即可，剩下的都是实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Task&lt;bool&gt; CreateAsync(TEntity enitity);</span><br><span class="line">     Task&lt;bool&gt; DeleteAsync(TEntity enitity);</span><br><span class="line">     Task&lt;bool&gt; DeleteAsync(int id);</span><br><span class="line">     Task&lt;bool&gt; UpdateAsync(TEntity enitity);</span><br><span class="line">     Task&lt;TEntity&gt; FindAsync(int id);</span><br><span class="line">     Task&lt;TEntity&gt; FindAsync(Expression&lt;Func&lt;TEntity,bool&gt;&gt; func);</span><br><span class="line">     Task&lt;List&lt;TEntity&gt;&gt; QueryAsync();</span><br><span class="line">     Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; func);</span><br><span class="line">     Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(int page,int size,RefAsync&lt;int&gt; total);</span><br><span class="line">     Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; func,int page,int size,RefAsync&lt;int&gt; total);</span><br></pre></td></tr></table></figure><p>通用仓储类BaseRepository如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class BaseRespository&lt;TEntity&gt; :SimpleClient&lt;TEntity&gt; ,IBaseRespository&lt;TEntity&gt; where TEntity : class, new()</span><br><span class="line">    &#123;</span><br><span class="line">        public BaseRespository(ISqlSugarClient context =null) : base(context)</span><br><span class="line">        &#123;</span><br><span class="line">            base.Context= DbScoped.Sugar;</span><br><span class="line">            base.Context.DbMaintenance.CreateDatabase();</span><br><span class="line">            base.Context.CodeFirst.InitTables(typeof(BlogNews),typeof(TypeInfo),typeof(Writer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //注册</span><br><span class="line"></span><br><span class="line">        public async Task&lt;bool&gt; CreateAsync(TEntity enitity)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.InsertAsync(enitity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;bool&gt; DeleteAsync(TEntity enitity)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.DeleteAsync(enitity);</span><br><span class="line">        &#125;</span><br><span class="line">        public async Task&lt;bool&gt; DeleteAsync(int id)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.DeleteByIdAsync(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;TEntity&gt; FindAsync(int id)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.GetByIdAsync(id);</span><br><span class="line">        &#125;</span><br><span class="line">        public async Task&lt;TEntity&gt; FindAsync(Expression&lt;Func&lt;TEntity,bool&gt;&gt; func)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.GetSingleAsync(func);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;List&lt;TEntity&gt;&gt; QueryAsync()</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.GetListAsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; func)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.GetListAsync(func);</span><br><span class="line">        &#125;</span><br><span class="line">        //翻页</span><br><span class="line">        public async  Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(int page, int size, RefAsync&lt;int&gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.Context.Queryable&lt;TEntity&gt;().ToPageListAsync(page, size, total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async  Task&lt;List&lt;TEntity&gt;&gt; QueryAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; func, int page, int size, RefAsync&lt;int&gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.Context.Queryable&lt;TEntity&gt;().Where(func).ToPageListAsync(page, size,total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;bool&gt; UpdateAsync(TEntity enitity)</span><br><span class="line">        &#123;</span><br><span class="line">            return await base.UpdateAsync(enitity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.在注册时候，可能注册的东西太多，所以为IServiceCollection写个扩展类，在扩展类里面进行注册。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static class IOCExtend</span><br><span class="line">&#123;</span><br><span class="line">    public static IServiceCollection AddCustomIoc(this IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.AddScoped&lt;BlogNewsIRespository, BlogNewsRespository&gt;();</span><br><span class="line">        services.AddScoped&lt;TypeInfoIRespository, TypeInfoRespository&gt;();</span><br><span class="line">        services.AddScoped&lt;WriterIRespository, WriterRespository&gt;();</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.封装返回结果，使其什么类型都可以返回</p><p>创建ApiResult类作为返回类型和ApiResultHelper类来操作方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class ApiResult</span><br><span class="line">        &#123;</span><br><span class="line">            public int Code &#123; get; set; &#125;</span><br><span class="line">            public string? Message &#123; get; set; &#125;</span><br><span class="line">            public int Total &#123; get; set; &#125;</span><br><span class="line">            public dynamic? Data &#123; get; set; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static class ApiResultHelper</span><br><span class="line">    &#123;</span><br><span class="line">        public static ApiResult Success(dynamic data) &#123;</span><br><span class="line">            return new ApiResult()</span><br><span class="line">            &#123;</span><br><span class="line">                Code = 200,</span><br><span class="line">                Data = data,</span><br><span class="line">                Message=&quot;操作成功 &quot;,</span><br><span class="line">                Total=0               </span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        public static ApiResult Success(dynamic data,RefAsync&lt;int&gt; page) &#123;</span><br><span class="line">            return new ApiResult()</span><br><span class="line">            &#123;</span><br><span class="line">                Code = 200,</span><br><span class="line">                Data = data,</span><br><span class="line">                Message = &quot;操作成功&quot;,</span><br><span class="line">                Total = page</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        public static ApiResult Error(dynamic data) &#123;</span><br><span class="line">            return new ApiResult()</span><br><span class="line">            &#123;</span><br><span class="line">                Code = 404,</span><br><span class="line">                Data = data,</span><br><span class="line">                Message = &quot;操作失败&quot;,</span><br><span class="line">                Total = 0</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5.实现controller即可</p><p>6.将密码加密保存到数据库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Md5Helper</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 密码加密</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;password&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        public static string MD5Encrypt32(string password)</span><br><span class="line">        &#123;</span><br><span class="line">            string pwd = &quot;&quot;;</span><br><span class="line">            MD5 md5 = MD5.Create();</span><br><span class="line">            byte[] s = md5.ComputeHash(Encoding.UTF8.GetBytes(password));</span><br><span class="line">            for (int i = 0; i &lt; s.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                pwd = pwd + s[i].ToString(&quot;X&quot;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            return pwd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    使用静态方法进行加密</span><br></pre></td></tr></table></figure><p>7.JWT校验</p><p>在LoginController登录功能中实现JWT，在其他控制器中实现授权</p><p>8.automapper进行映射，创建模型类DTO,将原模型类与DTO映射好，使用aotumapper</p><p>9.分页查询</p><h1 id="项目三：BlogWebApiApp"><a href="#项目三：BlogWebApiApp" class="headerlink" title="项目三：BlogWebApiApp"></a>项目三：BlogWebApiApp</h1><p>其他层都是创建一个类库实现的，不要创建文件夹</p><h1 id="项目四：Blazor购物车"><a href="#项目四：Blazor购物车" class="headerlink" title="项目四：Blazor购物车"></a>项目四：Blazor购物车</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通过blazor与webapi进行前后端分离：</span><br><span class="line">前端通过HttpClient对象访问后端的webapi，如下进行httpclient的注入baseurl</span><br><span class="line">builder.Services.AddScoped(sp =&gt; new HttpClient &#123; BaseAddress = new Uri(&quot;https://localhost:7125/&quot;) &#125;);</span><br><span class="line">如下在blazor的c#代码中访问webapi</span><br><span class="line"> var productDtos = await  httpClient.GetFromJsonAsync&lt;IEnumerable&lt;ProductDto&gt;&gt;(&quot;api/products&quot;);</span><br></pre></td></tr></table></figure><p>balzor实现前端端分离：</p><p>方式1.创建一个c#类进行ComponentBase类，然后blazor页面@inherit 该类即可。</p><p>方式2.直接创建一个c#类，该类名为blazor页面的名字+Base即可。</p><p>手写实体类转dto的linq语句：</p><h1 id="项目五：ToDOWPF"><a href="#项目五：ToDOWPF" class="headerlink" title="项目五：ToDOWPF"></a>项目五：ToDOWPF</h1><ol><li>使用了materialdesign.themes（4.1.0）,Prism.dryIoc包(不是模板)（8.1.97）</li><li>字段和属性：对外操作都是使用属性，字段在类中不起任何作用，它的所有操作已经在属性中操作完成，属性委托，方法委托都是绑定在构造方法里面的。</li><li>BaseDTO中存在的必有字段为Id，CreateTime,UpdateTime</li><li>分层：Dto层放在Commons里面，，Service层，ViewModels层，Views层其他类放在Extension</li><li>要知道在wpf是没有program的，所以要想注入，则使用<a href="https://blog.csdn.net/weixin_43542114/article/details/128104044%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%80%8Cprism%E6%8F%90%E4%BE%9B%E4%BA%86%E6%B3%A8%E5%85%A5%EF%BC%8C%E5%AF%BC%E8%88%AA%E7%AD%89%E5%A4%A7%E9%87%8F%E5%8A%9F%E8%83%BD%E3%80%82">https://blog.csdn.net/weixin_43542114/article/details/128104044中的方法，而prism提供了注入，导航等大量功能。</a></li><li>在本项目中完美的实现了在一个Base里面写完增删改查方法具体实现，通过泛型传递实现类，而不必每个实现类去实现同样的方法。实现了类似efcore中构造AADbContext构造方法中只通过Base往DbContext里面传入DbContextOptions的形式。。</li></ol><p>7.wpf项目结构如下：</p><p>1.前端wpf部分<img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20230424200430692.png" alt="image-20230424200430692"><img src="/2026/01/29/net5%E9%A1%B9%E7%9B%AE/assets/image-20230424200615760.png" alt="image-20230424200615760">2.后台webapi部分</p><p>8.窗体的属性部分都是复制mateiraldesign的demo源码</p><p>9.裁剪图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image.Clip&gt;</span><br><span class="line">                                    &lt;EllipseGeometry</span><br><span class="line">                                        Center=&quot;27,18&quot;</span><br><span class="line">                                        RadiusX=&quot;20&quot;</span><br><span class="line">                                        RadiusY=&quot;20&quot;&gt;&lt;/EllipseGeometry&gt;</span><br><span class="line">                                &lt;/Image.Clip&gt;</span><br></pre></td></tr></table></figure><p>10.在Views创建新窗体，并将MainWindow里面的东西复制到新窗体里面，以后使用MainView新窗体作为主窗体。</p><p>11.将图片拷贝到文件夹之后，右键属性，需要将‘生成操作’改为‘资源’，否则运行之前显示，运行之后不显示</p><p>12.设置窗体可拖动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colorZone.MouseMove += (s, e) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                if (e.LeftButton == MouseButtonState.Pressed)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.DragMove();</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>13.修改app.xaml.cs中的resource中的light为dart会将主题变为dart模式</p><p>14.listbox如何绑定事件。以及它是如何向后端传递一个对象的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox </span><br><span class="line">                       x:Name=&quot;menuBar&quot;</span><br><span class="line">                       ItemsSource=&quot;&#123;Binding MenuBars&#125;&quot;//绑定数据源</span><br><span class="line">                       SelectionChanged=&quot;ListBox_SelectionChanged&quot;</span><br><span class="line">                       &gt;</span><br><span class="line">                   &lt;i:Interaction.Triggers&gt;</span><br><span class="line">                       &lt;i:EventTrigger</span><br><span class="line">                           EventName=&quot;SelectionChanged&quot;&gt;</span><br><span class="line">                           &lt;i:InvokeCommandAction</span><br><span class="line">                               Command=&quot;&#123;Binding NavigateCommand&#125;&quot;</span><br><span class="line">CommandParameter=&quot;&#123;Binding ElementName=menuBar, Path=SelectedItem&#125;&quot; /&gt;</span><br><span class="line">                           </span><br><span class="line">                       &lt;/i:EventTrigger&gt;</span><br><span class="line">                   &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">                   &lt;ListBox.ItemTemplate&gt;</span><br><span class="line">                       &lt;DataTemplate&gt;</span><br><span class="line">                           &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt;</span><br><span class="line">                               &lt;materialDesign:PackIcon Kind=&quot;&#123;Binding Icon&#125;&quot;  /&gt;</span><br><span class="line">                               &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Margin=&quot;20,0,0,0&quot;/&gt;</span><br><span class="line">                           &lt;/StackPanel&gt;</span><br><span class="line">                       &lt;/DataTemplate&gt;</span><br><span class="line">                   &lt;/ListBox.ItemTemplate&gt;</span><br><span class="line">               &lt;/ListBox&gt;</span><br></pre></td></tr></table></figure><p>15.返回导航日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提前创建一个日志属性public IRegionNavigationJournal journal &#123; get; set; &#125;</span><br><span class="line">第一个参数为url，第二个参数返回一个导航日志对象。所以它的对象创建方式上比较特殊</span><br><span class="line">_manager.Regions[RegionManagerName.RegionName].RequestNavigate(menuBar.NameSpace,back =&gt; &#123; </span><br><span class="line">                    journal = back.Context.NavigationService.Journal;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><p>16.如何注册一个区域</p><p>17.string.isNullOrWhiteSpace();判断字符串是空或者全部是空格字符串。</p><p>18.md中的提示控件pop，md中的textbox控件中的提示功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Width=&quot;200&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;10,5&quot; md:HintAssist.Hint=&quot;查找代办事项&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>19.属性，方法绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ObservableCollection&lt;ToDoDtos&gt; ToDoDtos</span><br><span class="line">        &#123;</span><br><span class="line">            get &#123; return toDoDtos; &#125;</span><br><span class="line">            set &#123; toDoDtos = value; RaisePropertyChanged(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> 方法绑定的是ViewModel中的委托名字，而不是方法名字</span><br><span class="line"> public MainViewModel(IRegionManager regionManager)</span><br><span class="line">        &#123;</span><br><span class="line">            GoBackCommand = new DelegateCommand(GoBack);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public DelegateCommand GoBackCommand &#123; get; set; &#125;</span><br></pre></td></tr></table></figure><p>20.实现将两个元素分别放在某一行的两端，即两端对齐。1.使用grid，然后使用位置布局2.使用dockpanel（将lastfill改为false，同时将dockpanel.dock改为right,如果仍然没有分布，则可能是因为集合控件里面没有将HorizontalContentAlignment&#x3D;”Stretch”）</p><p>21.net5无法使用  Configuration.GetConnectionString(“connectionstring”);的方式去获取字符串，只能使用Configuration[“MyTodo2ConnectionString”]的方式去获取</p><p>22.UnitOfWork的作用就是底层的手写Repository的逻辑已经被泛型的方式封装好了，我们只需要拿来使用即可。需要导入Microsoft.EntityFrameworkCore.AutoHistory的包</p><p>然后往unitofwork里面导入上下文，和同时导入相关的数据库。这样工作单元就可以获取每个类的仓储以及数据库上下文。</p><pre><code>services.AddDbContext&lt;MyTodoContext&gt;(option =&gt;            {            option.UseSqlServer(Configuration[&quot;MyTodo2ConnectionString&quot;]);            }).AddUnitOfWork&lt;MyTodoContext&gt;()  .AddCustomRepository&lt;ToDo,TodoRepository&gt;()            .AddCustomRepository&lt;User,UserRepository&gt;()            .AddCustomRepository&lt;Memo,MemoRepository&gt;();            以后可以通过在服务层注入unitofwork对象，再通过对象.GetRepository&lt;ToDo&gt;()去获取TodoRepository的仓储类，执行后续操作</code></pre><p>23.封装返回结果，让其返回结果进行统一。</p><p>24.使用到了需要对泛型进行约束的情况，尽量将泛型进行约束，否则需要传入对象类型结果传入的是string类型则会报异常。</p><p>25.不能将增删改查的实现写在一个ServiceBase里面，然后具体某个Todoservice去继承ServiceBase，因为使用泛型的不知该泛型具体有哪些属性，在ServiceBase里面无法获取该属性，使用泛型约束也无法顾全所有情况，解决办法1.就是让每个实体Service都去实现一遍增删改查。2.不使用实体类中的属性去增删改查，而是直接使用实体类去实现。</p><p>26：predicte：&#x2F;&#x2F;观察源码，predicte解决了unitofwork中的二义性问题，GetFirstOrDefaultAsync该方法行参数有多个委托类型，此时不知应向哪个形参传递实参，使用形参名+冒号的方式指定向哪个形参传递</p><p>27.automapper：在service层实现转换，只有具体操作到数据库的时候才传递原型，其他都是dto，而且是将参数全部转成dto</p><p>​1.导入automapper包（预发行）&#x3D;》 2.创建一个类继承MapperConfigurationExpression如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AutoMapperProfile:MapperConfigurationExpression</span><br><span class="line">    &#123;//构造方法里面注册</span><br><span class="line">        public AutoMapperProfile() &#123; </span><br><span class="line">            CreateMap&lt;ToDo,ToDoDto&gt;().ReverseMap();</span><br><span class="line">            CreateMap&lt;Memo,MemoDto&gt;().ReverseMap();</span><br><span class="line">            CreateMap&lt;User,UserDto&gt;().ReverseMap();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 3.注册：var automapperconfig &#x3D; new MapperConfiguration(config &#x3D;&gt; { config.AddProfile(new AutoMapperProfile()); }) ;<br>            services.AddSingleton(automapperconfig.CreateMapper());</p><p>引入静态类：&lt;ContentControl prism:RegionManager.RegionName&#x3D;”{x:Static ext:}”</p><p> 4.在service层注入automapper对象，并在需要转换对应的方法里面完成转换，如下,service层及以上的传参部分全部转换为dto，repository与数据库交互不需要转换，别人的库中的泛型不能使用dto，因为别人的库肯定是针对具体某个类进行操作的。自定义的类视情况而定。</p><pre><code>public TodoService(IMapper mapper)    {        Mapper = mapper;    }    //添加    public async Task&lt;ApiResponse&gt; AddAsync(ToDoDto model)    {        try        {            var todo = Mapper.Map&lt;ToDo&gt;(model);//转换            await Work.GetRepository&lt;ToDo&gt;().InsertAsync(todo);//使用</code></pre><p>28.分页查询，直接从前端传递过来三个参数，封装为一个参数对象。参考p34</p><p>29.登录控制器实现的功能就是登录和注册的功能，其中登录实际上就是查询，注册实际上就是添加</p><p>30.controller层就用一行代码解决，剩下的代码都交给service层。</p><p>31，封装restsharp，封装请求参数</p><p>32.如果ServiceBase需要某个类型，则使用泛型的方式传入，如果需要某个具体的值（不针对依赖注入），则一种是使用构造方式赋值（交给子类去new），一种是当前使用new方式，前者实际上是在最顶层的父类里面已经new了，而后者是在需要的时候new的。</p><p>32.shared项目包含dto层，apiresponse，因为wpf端viewmodel中需要dto，同时webapi也需要dto，同理，两者都需要返回值。</p><p>33.wpf项目一定不要引用webapi项目，因为Service层类名一样，会导致各种错误，中间的共同类通过创建一个shared项目来引用</p><p>34.针对具有相同类型参数的方法进行绑定时，如果每个方法都创建一个委托，则代码太多，此时体现了委托的好处，就是创建一个公共委托，该委托对应的方法使用swith方法去根据传回来的参数值决定调用哪个方法。</p><p>35.listbox和itemsControl的dataContext问题</p><p>36.TextBox默认为单向绑定，需改为TwoWay</p><p>37.在前端写回车执行某方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox&gt;</span><br><span class="line">                   &lt;TextBox.InputBindings&gt;</span><br><span class="line">                       &lt;KeyBinding Key=&quot;Enter&quot; Command=&quot;&#123;Binding ExecutCommand&#125;&quot; CommandParameter=&quot;搜索&quot;&gt;&lt;/KeyBinding&gt;</span><br><span class="line">                   &lt;/TextBox.InputBindings&gt;</span><br><span class="line"> &lt;/TextBox&gt;</span><br></pre></td></tr></table></figure><p>38，出错页面如何显示：略，使用了转换器</p><p>39.在prism的mvvm中启动弹窗的功能是依赖注入IDialogService接口，然后进行showdialog(“窗口名”);窗口名是自己创建的xaml窗口，同时在app中注册registerdialog<AddDialog>（）;进行注册</AddDialog></p><p>40.窗体间传值：1.通过设置弹框的返回值DialogResult</p><p>41.前端数据是如何传递到后端的：就是通过绑定。</p><p>42.关于如何设置margin使其仅右侧和下侧起作用，使用位置进行约束即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">      Grid.Row=&quot;0&quot;</span><br><span class="line">      Margin=&quot;0,0,16,-20&quot;</span><br><span class="line">      HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">      VerticalAlignment=&quot;Bottom&quot;</span><br></pre></td></tr></table></figure><p>43，如果想要给grid，stackpanel等添加圆角等操作，有两种方法：</p><p>​       1.在外面套一层border，在border里面才有cornerradius属性，缺点是不能使用background(不推荐)</p><p>​   2.创建一个border，然后使用grid.row 附加属性将其附加上去，stackpanel的话就是外面套一个grid，然后创建border将其附加在grid.row,可以随意更改背景色（推荐）。</p><p>44.stackpanel什么时候外面套grid？需要添加背景色，比如使用border为某个布局添加背景色，使用border中的grid.row为某个区域添加背景色。</p><p>45.解决listbox或者itemscontrol无法滚动的问题，在外层加上scrollerviewer</p><p>46.针对变量类型Object的另一种等价的方式是使用泛型，这样在需要使用指定类型的话不必进行强转了，而是通过泛型直接指定了方式</p><p>47.所有的增删改查方法必须具有返回类型，不要使用void，所以需要封装一个ApiResponse类，一个bool属性，一个Object属性，而代替Object的方式的另一种解决办法就是使用泛型，参考46。一般两者都需要写，带泛型一般用在多个方法具有同一个返回类型上，例如add，update，而非泛型用在不具有特定返回类型的地方例如delete</p><p>48.prism官方文档：<a href="https://prismlibrary.com/docs/index.html">https://prismlibrary.com/docs/index.html</a></p><p>49.部署</p><p>复制数据库到webapi目录下</p><p>50.自定义询问窗口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>net core</title>
      <link href="/2026/01/29/net5/"/>
      <url>/2026/01/29/net5/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><p>创建项目时 .net framwork:只能应用在微软平台，</p><p>​.net core：跨平台，</p><p>​.net standard: 是.netframwork和core中必须遵守这个标准，即framwork和core中必须都有standard中的类库和方法。.standard代码中只有定义方法和类，但是没有具体的实现，而framework和core都实现了具体的方法。</p><span id="more"></span><h3 id="2-项目的发布"><a href="#2-项目的发布" class="headerlink" title="2.项目的发布"></a>2.项目的发布</h3><p>视频参考杨中科1-6：点击项目右键，发布，文件夹，文件夹，点击所有设置观察信息其中依赖框架指的是要求目标计算机上已有.net运行环境，而独立指的是在打包过程中将.net环境包含进去，保存，发布。</p><p><img src="/2026/01/29/net5/assets/image-20220118152015612.png" alt="image-20220118152015612"></p><p>若选择生成单个文件，启用readytorun则表示将所有的文件打包到.exe文件中（pdb文件无用），则产生的文件只有一个.exe文件（仅适用于.nect core3）。</p><p><img src="/2026/01/29/net5/assets/image-20220118154815553.png" alt="image-20220118154815553"></p><h3 id="net5中的program-cs文件分析："><a href="#net5中的program-cs文件分析：" class="headerlink" title=".net5中的program.cs文件分析："></a>.net5中的program.cs文件分析：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">   &#123;</span><br><span class="line">       public static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           CreateHostBuilder(args).Build().Run();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public static IHostBuilder CreateHostBuilder(string[] args) =&gt;</span><br><span class="line">           Host.CreateDefaultBuilder(args)</span><br><span class="line">               .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                   webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">               &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>main方法中如果什么也没有则是控制台应用，添加了上面的代码之后则变成了.net core应用程序，其中里面的startup是一个启动类，对应右侧的startup文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> CreateHostBuilder(args).Build().Run();这段代码改为如下代码分析</span><br><span class="line">1. IHostBuilder builder = CreateHostBuilder(args);//创建一个构建器，用来构造主机的</span><br><span class="line">2.builder.Build();//得到一个主机，该主机是core内置的主机（Kerstrel主机），这也是跨平台的原因（window主机为iis，linux主机为。。。，）而内置主机是什么系统都可以使用，该方法将asppsetting.json ,log,等一些注入的服务托管到主机上</span><br><span class="line">3.builder.Run();//主机运行起来</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) =&gt;//这里是在创建构建器时执行的。</span><br><span class="line">            Host.CreateDefaultBuilder(args)  //该方法也是创建一个web构建器，用来构建主机类型，同时底层注入了很多的默认的服务</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();//这段代码明确了要构建一个web类型的主机</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><h3 id="Pages文件夹"><a href="#Pages文件夹" class="headerlink" title="Pages文件夹"></a>Pages文件夹</h3><p>里面的index.cshtml为默认访问页面与.net framework的index差不多，在代码界面右键转到pageModel则跳转到index.html.cs文件中，当前端有get请求时这个文件的onGet()方法就会被调用</p><p>_layout页面：母版页</p><p>_ViewImports.cshtml文件：专门用来引入命名空间的文件 ，相当于mvc中的@model  命名空间，只不过这里单独创建了一个文件进行引入</p><p>_viewstart.cshtml：用来存放默认启动页的页面</p><h3 id="properties文件夹"><a href="#properties文件夹" class="headerlink" title="properties文件夹"></a>properties文件夹</h3><p>里面的launchSetting.json的就是一种配置文件，可视化配置是右键项目，属性，调试，这两种配置方式完全一样</p><h3 id="wwwroot文件夹"><a href="#wwwroot文件夹" class="headerlink" title="wwwroot文件夹"></a>wwwroot文件夹</h3><p>就是存放图片，js文件，视频等等的文件夹</p><h3 id="startup文件"><a href="#startup文件" class="headerlink" title="startup文件"></a>startup文件</h3><p>代码分析如下</p><p><strong>获取配置文件中数据的方法</strong>1.使用【key】，即Configuration[“ConnectionString”]</p><p>2.使用getSection(name)方法：即configuration.getSection(“ConnectionString”)</p><p>3.使用getChildren()获取子节点：configuration.getSection(“ConnectionString”).getChildren();</p><p>4.GetValue《T》(keyName);获取值并将其转化为类型T</p><p>5.GetValue《T》(KeyName,defaultvalue);同上，如果键没有值则使用默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">  &#123;</span><br><span class="line">      public Startup(IConfiguration configuration)//这是通过构造方法进行了注入，构造注入</span><br><span class="line">      &#123;</span><br><span class="line">          Configuration = configuration;//获取Configuration对象，使用它来获取配置文件中的配置参数</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      public IConfiguration Configuration &#123; get; &#125;//定义属性用来接受，使用Configuration才能调用配置文件中的参数。</span><br><span class="line">      //这里表示一种配置服务，各种第三方的服务通过这里进行添加</span><br><span class="line">      public void ConfigureServices(IServiceCollection services)</span><br><span class="line">      &#123;</span><br><span class="line">          services.AddRazorPages();//这也是注册了razor。参考依赖注入只不过时扩展方法</span><br><span class="line">          servies.AddTransient&lt;ItansientService,TansientService&gt;();//这就是注册</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //Congigure是个管道，里面全都是调用的中间件，其中IApplicationBuilder app, IWebHostEnvironment env这两个接口是在programs中CreateDefaultBuilder(args)方法的底层进行了注入，该方法是再programs中的run方法执行时被调用的，app就是管道。</span><br><span class="line">      public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">      &#123;</span><br><span class="line">          if (env.IsDevelopment())//判断是否是开发环境，共三种环境：1.isstaging（预览）2.isdevelopment（开发）3.isproduction(生产环境)，如果改为生产环境，最显著的特点是报错的时候返回的结果不会将具体的信息返回给前端，比如说具体的某一行出现的错误</span><br><span class="line">          &#123;</span><br><span class="line">              app.UseDeveloperExceptionPage();//启用异常中间件</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              app.UseExceptionHandler(&quot;/Error&quot;);</span><br><span class="line">              // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/asp</span><br><span class="line">              netcore-hsts.</span><br><span class="line">              app.UseHsts();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          app.UseHttpsRedirection();//使用https进行访问</span><br><span class="line">          app.UseStaticFiles();//处理静态文件系统，例如图片</span><br><span class="line"></span><br><span class="line">          app.UseRouting();//分配路由该中间件与UseEndpoints中间件是成对使用，而拆开的原因是因为他们俩之间还可以插入其他的中间件，如身份验证</span><br><span class="line"></span><br><span class="line">          app.UseAuthorization();//授权</span><br><span class="line"></span><br><span class="line">          app.UseEndpoints(endpoints =&gt;</span><br><span class="line">          &#123;</span><br><span class="line">              endpoints.MapRazorPages();</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码分析：在       </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public void ConfigureServices(IServiceCollection services)</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddRazorPages();//这也是注册。参考依赖注入</span><br><span class="line"></span><br><span class="line">​services.AddControllers();          </span><br><span class="line"></span><br><span class="line">  servies.AddTransient&lt;ItansientService,TansientService&gt;();//这就是注册</span><br></pre></td></tr></table></figure><p>​        }这段代码中，ConfigureServices就是.net core的一个内部容器，里面通过servers.AddTransient()方法实现注入，注入的类型是tansientService类型，我们可以看到里面添加了addrazorpages（），adcontrollers（）方法，与注册的三种情况不符合，这是因为进行了封装，底层仍然使用的是transient，scoped，singleton这三种方式</p><p>管道：浏览器发起请求到服务器，中间有很多环节需要处理，称为管道，其中Configure（）方法就是一个管道，里面封装了各种中间件。</p><h1 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h1><p>异步用于解决程序过程中比较耗时的操作，例如下载网页，加载UI界面，访问数据等。</p><p>计算机中有些处理比较耗时。调用这种处理代码时，调用方如果站在那里苦苦等待，会严重影响程序性能。例如，某个程序启动后如果需要打开文件读出其中的数据，再根据这些数据进行一系列初始化处理，程序主窗口将迟迟不能显示，让用户感到这个程序怎么等半天也不出来，太差劲了。借助异步调用可以把问题轻松化解：把整个初始化处理放进一个单独线程，主线程启动此线程后接着往下走，让主窗口瞬间显示出来。等用户盯着窗口犯呆时，初始化处理就在背后悄悄完成了。程序开始稳定运行以后，还可以继续使用这种技巧改善人机交互的瞬时反应。用户点击鼠标时，所激发的操作如果较费时，再点击鼠标将不会立即反应，整个程序显得很沉重。借助异步调用处理费时的操作，让主线程随时恭候下一条消息，用户点击鼠标时感到轻松快捷，肯定会对软件产生好感。</p><p>具体使用方法</p><p>1.异步方法是用async关键字修饰的方法，返回值一般为Task&lt;类型&gt;，习惯是创建异步方法时结尾是以Async结尾</p><p>2.若没有返回值（相当于同步中的void），在异步中返回值类型声明为非泛型的Task</p><p>3.调用泛型方法时，一般在方法前加上await关键字，这样拿到的返回值就是泛型指定的T类型，若不加await，则返回值类型必须为Task&lt;类型&gt;（比较麻烦），同时若不加await，当数据量过大时，若上个操作没有执行就执行下一步操作，容易出现异常，await就是等待上一步操作完成之后在执行当前方法。</p><p>4.一个方法中若使用了await调用了其他方法，则该方法必须修饰为async</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public async Task Main()&#123;</span><br><span class="line"></span><br><span class="line">​string str1= await File.WriteAllTextasync(&quot;c:/&quot;,&quot;aaa&quot;);//方法1</span><br><span class="line"></span><br><span class="line">​    Task&lt;返回类型string&gt; str2= await File.WriteAllTextasync(&quot;c:/&quot;,&quot;aaa&quot;);//方法1</span><br><span class="line"></span><br><span class="line">​&#125;</span><br></pre></td></tr></table></figure><p>5.对于某些无法在方法前面加async关键字进行异步，若还是想要调用其他的异步方法，则在被调用的异步方法后面加上.wait();或者加上.Rusult;，但是尽量不要这么做，有死锁的风险。比如说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void read()&#123;</span><br><span class="line">string str1 = File.WriteAllTextasync(&quot;c:/&quot;,&quot;aaa&quot;).Result;//方法1</span><br><span class="line">string str2 =File.WriteAllTextasync(&quot;c:/&quot;,&quot;aaa&quot;).wait();//方法2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.为什么有的异步方法返回值前面不加async:直接将被调用的异步方法作为该方法的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line">async Task&lt;string&gt; ReadFileAsync(int num)</span><br><span class="line">&#123;</span><br><span class="line">return await File.ReadAllTextAsync(&quot;d:/1.txt&quot;);//返回值是string类型</span><br><span class="line">&#125;</span><br><span class="line">Task&lt;string&gt; ReadFileAsync(int num)</span><br><span class="line">&#123;</span><br><span class="line">return File.ReadAllTextAsync(&quot;d:/1.txt&quot;);//返回值是Task&lt;string&gt;类型</span><br><span class="line">&#125;</span><br><span class="line">当main方法调用readFileAsync方法时，返回值直接就是File.ReadAllTextAsync的返回值，所以不必加async。因此一个异步方法只是对别的异步方法的简单的调用，可以去掉async 和await</span><br></pre></td></tr></table></figure><p>7.如果想要在异步方法中暂停一段时间不要使用Thread.sleep()，因为他会阻塞当前线程，而是使用</p><p> await Task.Delay(),他阻塞的不是主线程</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>使用依赖注入的原因：避免耦合性</p><p>在asp.net中需要自己创建ServiceCollection ,以及IserviceProvider但是在asp.netcore 中不需要自己去创建</p><p>首先使用nuget安装 两个Ioc包：install-package microsoft.extensions.dependencyinjection   </p><p>​install-package microsoft.extensions.dependencyinjection.Abstractions   </p><p>然后导入using Microsoft.Extensions.DependencyInjection;</p><p>依赖注入(DI)是实现控制反转(IOC)的一种方式</p><p>依赖注入：depend injection,DI:几个概念</p><p>1.服务（Service）：就是对象</p><p>2.注册服务，就是指定往容器中装入的类的类型，在tansient，scoped，singleton三个对象生命周期的泛型中填入类的类型，例如：singleton(接口，实现类),使用这样的方式进行注册的原因是，接口可以对应多个实现类，这样如果想要业务扩展的话，只需要将新类实现该接口即可。如果是接口泛型，那么再注册的时候使用typeof这样就不用注册泛型了参考第二个项目。</p><p>3.服务容器：负责管理注册的服务，内置容器是ConfigureService，如果想要使用第三方容器，已经有内置容器为什么还要使用第三方容器，以为可以进行实现批量注册服务，如果注册100个服务，那么使用内置容器就需要注册100个，使用autofac就避免了这个问题例如，Autofac容器代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public IServiceProvider ConfigureServices(IServiceColletion services)&#123;//将返回值改为IServiceProvider是告诉程序我不是使用内置容器，使用第三方容器</span><br><span class="line">services.AddMvc().serCompatibilityVersion()。。。;//会自己修改</span><br><span class="line">var bulder = new ContainerBuilder();//容器构建器，构建容器的工具</span><br><span class="line">builer.RegisterType&lt;UserRepostory&gt;().As&lt;IUserRepository&gt;();//将实现类注册到接口上面去，这个普通情况。如果该接口有多个实现类，那么就直接将顶层的注册即可，所以使用该类的都会自动注入，不用每个都写</span><br><span class="line">builder.populate(serives);//将内置容器里面的已有的所有服务放到第三方容器中</span><br><span class="line">var container = builder.build();//构建容器</span><br><span class="line">return new autofaserviceprovider(container);//返回服务程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.查询服务：创建对象及关联对象</p><p>5.对象生命周期：transient（瞬态）（每次使用对象时，重新创建的新的对象，消耗系统资源），scoped（范围，在一次请求内（再webapi情况下就是在一个action内））（常用），singleton（单例）（在一个项目内）</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>依赖注入类似线程池的原理：当将某个类注册到服务集合中后，当项目启动之后，会自动创建该类对象保存下来，当我们需要引用该类对象时，直接调用即可，不必手动去new 对象，，而且该类是全局引用的，整个项目都可以直接使用。使用依赖注入创建的好处是可以实现扩展，若需要扩展，直接让某个实现类继承某个接口即可，同时降低耦合性，若某个类需要其他的类对象，直接从池子里面取，而不用通过传递类对象的方式进行创建对象，降低了类与类之间的关系。</p><p><strong>注入一般有两种方式，</strong></p><p>​1.一种是使用服务定位器的方式（一般用于无法实现构造注入的情况，比如main方法中无法构造注入）</p><p>​2.另一种方式就是构造注入</p><p>​3.参数&#x2F;属性注入：对于某个action被调用的频率不高，那么每次其他action被调用的时候，必须注入这个频率低的action中的服务，比较消耗资源。解决办法就是使用参数注入，对于某个action使用频率比较低中的服务使用参数注入。即【fromservices】，而且这种注入方式只能用在控制器中</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以看到对于MyService类使用频率不高，所以推荐使用参数/属性注入</span><br><span class="line">public string Test([FromServices]MyService myservice,string name)&#123;</span><br><span class="line">var names = myService.GetName();</span><br><span class="line">return string.Join(&quot;,&quot;,names)+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务：就是接口</p><p>实现：就是接口的实现类。一个服务对应一个实现</p><p>1.例如将Logger类注册到Startup文件的ConfigureServices集合中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">servies.AddTransient&lt;Ilogger,logger&gt;();</span><br><span class="line">如果只有一个实现类，没有接口那么就使用</span><br><span class="line">servies.AddTransient&lt;logger,logger&gt;();进行注册</span><br><span class="line">servies.AddTransient&lt;logger&gt;();//或者干脆使用一个实现类进行注册。</span><br><span class="line">//使用这种方式实现一个接口有多个实现类的情况下的注册</span><br><span class="line">servies.AddTransient&lt;IEnumerable&lt;接口类型&gt;&gt;();</span><br></pre></td></tr></table></figure><p>2.如果同一个项目中其他文件中的Reg类想要使用logger对象，不需要new，不需要引进命名空间，只需要通过Reg类的构造方法引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Reg&#123;</span><br><span class="line">public readonly Ilogger log;//用来接受log对象</span><br><span class="line">public Reg(Ilogger log);</span><br><span class="line">this.log = log;//可以看到这里不是new出来的，而是直接引用构造方法中的log，构造中log是引用池子里的类对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;传统创建对象的代码，TestServiceImpl t &#x3D; new TestServiceImpl();</p><p>&#x2F;&#x2F;使用依赖服务创建对象的代码：将需要创建的对象放在ServiceCollection集合中，使用ServiceProvider服务定位器去创建TestServiceImpl类型的对象，如果使用构造注入获得对象就不需要serviceprovider</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">示例一：通过服务定位器的作用获取类对象，因为无法通过main方法去实现参数注入，这种情况是在没有mvc，webapi等框架的情况下，自己去创建容器</span><br><span class="line">install-package microsoft.extensions.dependencyinjection 引入这个包</span><br><span class="line"> 调用类： class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceCollection service = new ServiceCollection();//容器</span><br><span class="line">            service.AddTransient&lt;ITestService,TestServcieImpl&gt;();//注册</span><br><span class="line">            using (ServiceProvider sp = service.BuildServiceProvider()) &#123;//获取服务定位器为了构建对象</span><br><span class="line">                ITestServcieImpl ts = sp.GetService&lt;ITestServcieImpl&gt;();//通过服务定位器获取(接口)对象,</span><br><span class="line">                若是同一个接口对应多个实现类，则是sp.GetServices&lt;ITestServcieImpl&gt;//返回枚举类型，遍历</span><br><span class="line">                ts.name = &quot;张三&quot;;</span><br><span class="line">                ts.sayHi();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 接口：public interface ITestService</span><br><span class="line">    &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public void sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  接口对应的实现类： public class TestServcieImpl :ITestService &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            Console.WriteLine(name+&quot;你好&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    运行结果为：张三你好</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">示例二：构造获取类对象</span><br><span class="line">using System;</span><br><span class="line">using Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line">namespace ConsoleApp3</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceCollection service = new ServiceCollection();//容器</span><br><span class="line">            service.AddTransient&lt;ITestService,TestServcieImpl&gt;();//注册：注意：因为登录接口使用了服务接口中的对象，所以这里只需要注册登录接口也是可以的</span><br><span class="line">            service.AddTransient&lt;ITestLogin, TestLoginImpl&gt;();//注册</span><br><span class="line">            using (ServiceProvider sp = service.BuildServiceProvider())//同示例一</span><br><span class="line">            &#123;</span><br><span class="line">                ITestLogin ts = sp.GetService&lt;ITestLogin&gt;();</span><br><span class="line">                ts.impl(); ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //ITestLogin类想要使用TestServiceImpl中的内容</span><br><span class="line">    登录接口：public interface ITestLogin &#123;</span><br><span class="line">        public void impl();   </span><br><span class="line">    &#125;</span><br><span class="line">    登录接口对应的实现类：public class TestLoginImpl :ITestLogin</span><br><span class="line">    &#123;</span><br><span class="line">        public  readonly ITestService ts;//用来接受对象的接口</span><br><span class="line">        //构造注入,构造方法中直接引用其他接口（面向接口编程），而不是实现类，不需要手动传递对象</span><br><span class="line">        public TestLoginImpl(ITestService ts)</span><br><span class="line">        &#123;</span><br><span class="line">            this.ts = ts;</span><br><span class="line">        &#125;</span><br><span class="line">        public void impl() &#123;</span><br><span class="line">            ts.name = &quot;李四&quot;;</span><br><span class="line">            ts.sayHi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   服务接口： public interface ITestService</span><br><span class="line">    &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public void sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">   服务接口对应的实现类 public class TestServcieImpl :ITestService &#123;</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line">        public void sayHi() &#123;</span><br><span class="line">            Console.WriteLine(name+&quot;你好&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果是李四你好</span><br></pre></td></tr></table></figure><p>在StrartUp类中发现有services.AddRazorPages();&#x2F;&#x2F;这实际上是注册服务的扩展方法，在这里手写一个新的扩展方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void AddMessage(this IServiceColletion services)&#123;</span><br><span class="line">servics.AddSingleton&lt;Imessage,message&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">然后再startup类中直接使用services.AddMessage();即可进行注册。而不必使用AddSingleton注册</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作方法注入,属性注入不推荐,推荐上面的注入方式;,这种注入用于使用频率不高的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ViewResult Index([FromService]ProductToTallizer tatal)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置系统（杨中科）"><a href="#配置系统（杨中科）" class="headerlink" title="配置系统（杨中科）"></a>配置系统（杨中科）</h1><p>项目研发时，会遇到一些经常改变的参数，比如要连接的数据库的连接地址，数据库名称，数据库用户名，数据库密码，第三方url（比如友情连接）等考虑的程序的通用性，这些参数往往不能写死在程序里，而是借助配置文件来修改要变换的信息，我们只要读取配置文件就可以，而不是每次都去修改程序。</p><p>传统使用web.config文件或者ConfigurationManager类去配置系统，但是已经过时了，最新是使用.json文件去配置系统。有很多种配置方式，这里只使用了最简单的一种（注入的方式）</p><p>1.在项目的第一层目录下手动添加一个json文件，将json文件右键属性，复制到输出目录改为“如果较新则复制”</p><p>2.nuget安装install-package Microsoft.Extensions.Configuration 和install-package Microsoft.Extensions.Configuration.Options 和intall-package  Microsoft.Extensions.Configuration.binder及install-package Microsoft.Extensions.Configuration.json四个安装包</p><p>3.读取配置时，DI要声明IOptions&lt;泛型&gt;（不动态更新），IOptionsMonitor&lt;泛型&gt;（立即更新），IOptionsSnapshot&lt;泛型&gt;（一定区域范围内，推荐用），</p><p>4.注意虽然创建文件是在项目跟目录下，但是程序运行之后，会将文件自动拷贝到bin\Debug\net5.0下，所以如果修改配置文件是修改该目录下的配置文件，与跟目录下无关。</p><p>配置文件如下，json格式是作为对象保存的，该对象有name属性值为张三，age属性，值25，proxy为另一个类，该类属性address值为aa，port属性值为80</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">   &#123;</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           ServiceCollection services = new ServiceCollection();//服务集合</span><br><span class="line">           services.AddScoped&lt;TestController&gt;();//注册服务,因为TestController类里面引用了Config类，而config类里面引用了Proxy类所以只需要注册TestController即可，这是依赖性</span><br><span class="line"></span><br><span class="line">           ConfigurationBuilder configBuilder = new ConfigurationBuilder();//创建构建器</span><br><span class="line">           ////加载目录下的json文件，以对象形式保存在configbuilder中，第二个参数表示文件是可选的，建议为true，第三个参数表示配置文件修改之后是否立即更新，建议为true</span><br><span class="line">           configBuilder.AddJsonFile(&quot;config.json&quot;, optional: true, reloadOnChange: true);</span><br><span class="line">           //创建跟节点</span><br><span class="line">           IConfigurationRoot configRoot = configBuilder.Build();</span><br><span class="line">           //注册只有周期那三种方式，其余的注册都是属于扩展方法例如addOptions</span><br><span class="line">           //将Config对象绑定到configroot根节点上（因为Config类里面还有个Proxy类属于子节点）；</span><br><span class="line">           services.AddOptions().Configure&lt;Config&gt;(e =&gt; configRoot .Bind(e));</span><br><span class="line">           //另一种绑定方法（不推荐）configuration.Bind(类名)；//即将配置文件中的信息绑定在写好的实体类上，这样就直接绑定好</span><br><span class="line"></span><br><span class="line">           using (var sp = services.BuildServiceProvider()) &#123;//服务定位器</span><br><span class="line">               using (var scope = sp.CreateScope())//因为IOptionsSnapshot是在一定范围内使用，所以这里创建一个scope</span><br><span class="line">               &#123;</span><br><span class="line">                   var c = scope.ServiceProvider.GetRequiredService&lt;TestController&gt;();</span><br><span class="line">                   c.Test();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //这里创建类用来接受返回的对象，或者作为泛型使用</span><br><span class="line">   class Config&#123;</span><br><span class="line">       public string name &#123; get; set; &#125;</span><br><span class="line">       public int age &#123; get; set; &#125;</span><br><span class="line">       public Proxy Proxy &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   class Proxy &#123; </span><br><span class="line">       public string address &#123; get; set; &#125;</span><br><span class="line">       public int port &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class TestController</span><br><span class="line">    &#123;</span><br><span class="line">        public IOptionsSnapshot&lt;Config&gt; optConfig;</span><br><span class="line">        //若想要获取Config中的信息，直接用Config是不可取的，因为配置文件中的信息是随时变化的，如果直接注入Config则相当于直接将值写死了，无法随着动态变化而变化，而Ioptionsnapshot&lt;Config&gt;是将Config封装成Ioptoinsnapshot的内容，这个接口就是为了解决动态变化的问题</span><br><span class="line">        public TestController(IOptionsSnapshot&lt;Config&gt; optConfig) &#123;</span><br><span class="line"></span><br><span class="line">            this.optConfig = optConfig;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Test() &#123;</span><br><span class="line">            Config config = optConfig.Value;//或者Config对象</span><br><span class="line">            Console.WriteLine(config.age);</span><br><span class="line">            //Console.WriteLine(optConfig.Value.age) ;//与上面写法等价</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="机密信息"><a href="#机密信息" class="headerlink" title="机密信息"></a>机密信息</h3><p>对于一些机密信息比如用户名密码等放在配置文件里面容易泄露，可以对项目右键，管理机密信息，会自动安装一个包，创建机密的json文件，这个文件保密性比较高，具体使用参考杨中科配置系统4-34</p><p>读取方式：var  str &#x3D; app.Configuration.GetSection(“键”).value</p><h1 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h1><p>日志提供者LoggingProvider</p><p>日志等级：trace&lt;debug&lt;information&lt;warning&lt;error&lt;critical</p><p>1.安装两个nuget包：Microsoft.Extensions.Logging      和Microsoft.Extensions.Logging.Console</p><p>2.DI注入：services.addLogging(logbuilder&#x3D;&gt;{logbuilder.addConsole()});</p><p>3.将需要注入的代码注入ILogging&lt;泛型&gt;即可，可以将出现问题的类输出到日志方便定位错误，然后调用LogInformation(),LogError()输出日志等级</p><p>4.日志可以输出到控制台，event log（只能windows系统），但更好的放在文本文件里面并且按照日期区分，限制日期总个数或总大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">   &#123;</span><br><span class="line">       static void Main(string[] args)</span><br><span class="line">       &#123;服务器定位器注入方式</span><br><span class="line">           ServiceCollection services = new ServiceCollection();</span><br><span class="line">           //同理，services.addLoggin();是一个扩展方法</span><br><span class="line">           services.AddLogging(logBuilder =&gt; &#123; </span><br><span class="line">           logBuilder.AddConsole();//将日志输出到控制台</span><br><span class="line">               logBuilder.AddNLog();//将日志输出到文件</span><br><span class="line">           &#125;);</span><br><span class="line">           services.AddScoped&lt;Test&gt;();//注册</span><br><span class="line">           using (var sp = services.BuildServiceProvider()) &#123; //构造服务定位器用来获取对象</span><br><span class="line">               var test1 =sp.GetRequiredService&lt;Test&gt;();</span><br><span class="line">               test1.print();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">被注入的类</span><br><span class="line">    class Test</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly ILogger&lt;Test&gt; logger;</span><br><span class="line">        //构造方法注入方式</span><br><span class="line">        public Test(ILogger&lt;Test&gt; logger) &#123;</span><br><span class="line">            this.logger = logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //调用方法输出日志</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            logger.LogDebug(&quot;开始数据库调试&quot;);</span><br><span class="line">            logger.LogDebug(&quot;连接数据库成功&quot;);</span><br><span class="line">            logger.LogWarning(&quot;查住数据失败&quot;);</span><br><span class="line">            logger.LogError(&quot;查找数据最终失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/net5/assets/image-20220126230050166.png" alt="image-20220126230050166"></p><h3 id="将日志写入文件"><a href="#将日志写入文件" class="headerlink" title="将日志写入文件"></a>将日志写入文件</h3><p>1.nuget安装 NLog.Extensions.Logging </p><p>2.项目根目录下建nlog.config，右键属性改为：”如果较新的复制“</p><p>3.增加logbuilder.addNlog();</p><p>4.进入nuget网站搜索nlog，找到右侧的source reposity 进入github，找到下侧的.net core，直接复制里面的代码粘贴到自己创建的nlog.config文件中，只需要将里面的路径改为输入文件的路径即可其他不用动</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      autoReload=&quot;true&quot;</span><br><span class="line">      internalLogLevel=&quot;Info&quot;</span><br><span class="line">      internalLogFile=&quot;c:\temp\internal-nlog-AspNetCore.txt&quot;&gt;//这里需要修改</span><br><span class="line"></span><br><span class="line">  &lt;!-- enable asp.net core layout renderers --&gt;</span><br><span class="line">  &lt;extensions&gt;</span><br><span class="line">    &lt;add assembly=&quot;NLog.Web.AspNetCore&quot;/&gt;</span><br><span class="line">  &lt;/extensions&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- the targets to write to --&gt;</span><br><span class="line">  &lt;targets&gt;</span><br><span class="line">    &lt;!-- File Target for all log messages with basic details --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;allfile&quot; fileName=&quot;c:\temp\nlog-AspNetCore-all-$&#123;shortdate&#125;.log&quot;  //这里需要修改</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId_Id:whenEmpty=0&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- File Target for own log messages with extra web details using some ASP.NET core renderers --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;File&quot; name=&quot;ownFile-web&quot; fileName=&quot;c:\temp\nlog-AspNetCore-own-$&#123;shortdate&#125;.log&quot;   //这里需要修改</span><br><span class="line">            layout=&quot;$&#123;longdate&#125;|$&#123;event-properties:item=EventId_Id:whenEmpty=0&#125;|$&#123;uppercase:$&#123;level&#125;&#125;|$&#123;logger&#125;|$&#123;message&#125; $&#123;exception:format=tostring&#125;|url: $&#123;aspnet-request-url&#125;|action: $&#123;aspnet-mvc-action&#125;|$&#123;callsite&#125;| body: $&#123;aspnet-request-posted-body&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--Console Target for hosting lifetime messages to improve Docker / Visual Studio startup detection --&gt;</span><br><span class="line">    &lt;target xsi:type=&quot;Console&quot; name=&quot;lifetimeConsole&quot; layout=&quot;$&#123;MicrosoftConsoleLayout&#125;&quot; /&gt;</span><br><span class="line">  &lt;/targets&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- rules to map from logger name to target --&gt;</span><br><span class="line">  &lt;rules&gt;</span><br><span class="line">    &lt;!--All logs, including from Microsoft--&gt;</span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;allfile&quot; /&gt;</span><br><span class="line">    &lt;!--Output hosting lifetime messages to console target for faster startup detection --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.Hosting.Lifetime&quot; minlevel=&quot;Info&quot; writeTo=&quot;lifetimeConsole, ownFile-web&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --&gt;</span><br><span class="line">    &lt;logger name=&quot;Microsoft.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;logger name=&quot;System.Net.Http.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;    </span><br><span class="line">    &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;ownFile-web&quot; /&gt;</span><br><span class="line">  &lt;/rules&gt;</span><br><span class="line">&lt;/nlog&gt;</span><br></pre></td></tr></table></figure><p>5.using NLog.Extensions.Logging;,在服务注册的时候将代码改为（在上面的注册代码中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services.AddLogging(logBuilder =&gt; &#123; logBuilder.AddConsole();</span><br><span class="line">                logBuilder.AddNLog();//这里就是将日志输出到文件</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>6.上面的config文件解读：日志分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- rules to map from logger name to target --&gt;</span><br><span class="line"> &lt;rules&gt;</span><br><span class="line">   &lt;!--All logs, including from Microsoft--&gt;</span><br><span class="line">   &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;allfile&quot; /&gt;//表示等级最低为tarce以上的输出到alfile文件里面</span><br><span class="line">   &lt;!--Output hosting lifetime messages to console target for faster startup detection --&gt;</span><br><span class="line">   &lt;logger name=&quot;Microsoft.Hosting.Lifetime&quot; minlevel=&quot;Info&quot; writeTo=&quot;lifetimeConsole, ownFile-web&quot; final=&quot;true&quot; /&gt;//类名为Microsoft.Hosting.Lifetime且最低等级为info的输出到控制台</span><br><span class="line">   &lt;!--Skip non-critical Microsoft logs and so log only own logs (BlackHole) --&gt;</span><br><span class="line">   &lt;logger name=&quot;Microsoft.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;//类名为Microsoft.*，最大等级为info</span><br><span class="line">   &lt;logger name=&quot;System.Net.Http.*&quot; maxlevel=&quot;Info&quot; final=&quot;true&quot; /&gt;    类名为System.Net.Http.*，最大等级为info的</span><br><span class="line">   &lt;logger name=&quot;*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;ownFile-web&quot; /&gt;其他所有的输出到wonfile-web里面</span><br><span class="line"> &lt;/rules&gt;</span><br></pre></td></tr></table></figure><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><p>{“id”:”8”,</p><p>“name”:”杨中科”,</p><p>“children”:[“aaa”,”bbb”,”ccc”]</p><p>}</p><p>其中{}表示对象，【】表示数组，id属性，name属性childern属性</p><p>json只允许传送的内容包含6个：1.字符串2.数值3.布尔值4.null5.对象6.数组</p><p>在js中将json转换为js对象是使用如下代码进行转换，将js对象转换为json字符串如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//json转js对象</span><br><span class="line">var json = &#x27;&#123;&quot;name&quot;:&quot;孙悟空“,&quot;age&quot;:&quot;18&quot;,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;；</span><br><span class="line"></span><br><span class="line">var obj = Json.parse(json);这个代码来转换</span><br><span class="line"></span><br><span class="line">//js转json</span><br><span class="line">var str = JSON.stringify(obj);</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="webapi"><a href="#webapi" class="headerlink" title="webapi"></a>webapi</h1><p>如果swagger页面报错，说明action没有写【HttpGet】或者【httpPost】</p><p><img src="/2026/01/29/net5/assets/image-20220127165726467.png"></p><p>在webapi中，get（）就是控制器里面的action，当有get请求时就会执行这里面的内容，其中里面的weatherforecast是系统自带的实体类，主要是为了测试使用</p><p>返回的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;date&quot;:&quot;2022-01-28T16:59:42.1593514+08:00&quot;,&quot;temperatureC&quot;:-20,&quot;temperatureF&quot;:-3,&quot;summary&quot;:&quot;Warm&quot;&#125;,&#123;&quot;date&quot;:&quot;2022-01-29T16:59:42.1606711+08:00&quot;,&quot;temperatureC&quot;:-13,&quot;temperatureF&quot;:9,&quot;summary&quot;:&quot;Bracing&quot;&#125;,&#123;&quot;date&quot;:&quot;2022-01-30T16:59:42.1606763+08:00&quot;,&quot;temperatureC&quot;:31,&quot;temperatureF&quot;:87,&quot;summary&quot;:&quot;Mild&quot;&#125;,&#123;&quot;date&quot;:&quot;2022-01-31T16:59:42.1606768+08:00&quot;,&quot;temperatureC&quot;:41,&quot;temperatureF&quot;:105,&quot;summary&quot;:&quot;Freezing&quot;&#125;,&#123;&quot;date&quot;:&quot;2022-02-01T16:59:42.1606771+08:00&quot;,&quot;temperatureC&quot;:-7,&quot;temperatureF&quot;:20,&quot;summary&quot;:&quot;Balmy&quot;&#125;]</span><br></pre></td></tr></table></figure><h2 id="controller分析如下-RPC"><a href="#controller分析如下-RPC" class="headerlink" title="controller分析如下:RPC"></a>controller分析如下:RPC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[ApiController]//表示这是webapicontorller而不是mvc控制器</span><br><span class="line">   [Route(&quot;[controller]/[action]&quot;)]//，不推荐系统提供的[Route(&quot;[controller]&quot;]，因为不标准,若是只有一个action则使用它会默认访问该action，若是还有其他action，控制器就不知道该访问哪个了</span><br><span class="line">   【controller】相当于一个占位符，是下面的控制器名字，表示访问时候直接输入WeatherForecast即可访问，若是[Route(&quot;api/[controller]&quot;)]则表示访问的时候使用api/WeatherForecast进行访问，但如果想问read方法则无法访问，所以强烈推荐[Route(&quot;[controller]&quot;/[action])]即控制器/方法名的方式进行访问</span><br><span class="line">   public class WeatherForecastController : ControllerBase//这是一个 WeatherForecast控制器</span><br><span class="line">   &#123;</span><br><span class="line">       [HttpGet]//表示当发出get请求的时候由该方法进行处理</span><br><span class="line">       public IEnumerable&lt;WeatherForecast&gt; Get()</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       [HttpGet]</span><br><span class="line">       public string read()&#123;</span><br><span class="line">       return &quot;hello&quot;；//会默认转换为json格式</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Rest-Restful"><a href="#Rest-Restful" class="headerlink" title="Rest&#x2F;Restful"></a>Rest&#x2F;Restful</h2><p>就是一种约定：使用场景不一样的时候进行区分：httpget：查询，Post：创建，put：整体更新，delete：删除，一般是每个post请求对应一个viewmodel</p><p>常见错误情况： post,get,put,delete 是标准, 大家都遵循这样的规则. 这样的api对于它人来说一目了然, get就是获取数据, post就是提交数据, put就是更新数据, delete就做删除操作.所有 http 请求，一律用 POST，在业务功能的实现是没有问题的。 如果一律使用post对一个项目组的内部人员来说是没有问题的, 但是对于对外公开的接口就让调用者摸不着头脑了.  所以使用get也可以实现增删改，但就是为了满足restful风格使用get方法进行查询实现一种约定。况且get方法是无法提交对象类型的，只能提交普通类型，只有post才能提交对象类型。另一种原因是为了安全，防止用户使用get方式提交违法数据到post数据中。get请求应用于所有只读信息的检索，post请求应用于任何更改应用程序的操作，get请求是为了安全交互，post请求用于不安全的交互.</p><p>传统rpc请求（推荐）：面向过程 例如&#x2F;persons&#x2F;getById?id&#x3D;888    即控制器&#x2F;操作方法  要求是控制器&#x2F;方法名例子参考上面的代码，在控制器上添加[Route(“[controller]&#x2F;[action]”)]，而不是[Route(“[controller]”]</p><p>推荐每个action上面都加上[httpget]或者[httppost].如果没加[httpget]则在swagger中会报错</p><p>面向restful：&#x2F;persons&#x2F;888    与上面的访问结果一样，所以是一种http语义（对开发人员来说比较难，不要使用，后续可能遇到各种问题 ）：例如获取某个公司的员工所有restful就是api&#x2F;companies&#x2F;{companyId}&#x2F;employees&#x2F;{employeeId};</p><p>设置restful：在方法的请求方式上设置对应的参数：</p><p>【Httpget】:无请求参数 public void getPersons();发送get请求</p><p>【httpget(“{id}”)】:public person getPerson(long id){};url为api&#x2F;person&#x2F;8发送get请求</p><p>【httpput(“{id}”)】:public void updatePerson(long id,Person person){} url为api&#x2F;person&#x2F;8发送put请求</p><p>【httpPost】:public void SavaPerson(Person person){};url为api&#x2F;person发送post请求</p><p>【httpdelete(“id”)】：public  void DeletePerson(long id){};url为api&#x2F;person&#x2F;8发送delete请求</p><h2 id="webapi返回类型"><a href="#webapi返回类型" class="headerlink" title="webapi返回类型"></a>webapi返回类型</h2><p>1.在mvc项目中，action默认返回的是各种Iactionresult，webapi在mvc返回类型的基础上删除了ViewResult类型（视图类型 ）但是在webapi中action返回的值会默认变成json格式比如int,string ,引用类型,等，所有的返回类型都是继承与IactionResult,（注意也可以返回string等普通类型，但不是将数据返回给视图，而是直接返回普通的字符串）。在webapi中，所有的返回类型都是ActionResult<T>类型，例如ActionResult<string>,ActionResult<Person>等，但是swagger可以根据返回类型自动推断出里面的泛型，所以我们可以直接return new Person;,return “你好”;等，系统会自动进行隐式转换成ActionResult类型</Person></string></T></p><p>2.如果根据判断返回的值类型不一样,则自动转换成ActionResult类型。</p><p>3.如果想要返回一个对象，里面包含多个信息，那么直接将属性信息封装到一个类里面，然后直接返回一个自定义对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult&lt;int&gt; add(int i1) &#123;</span><br><span class="line">            if (i1 &gt; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;//因为1是int类型，而notfound是IActionResult类型,所以actionresult&lt;int&gt;底层会自动转换为ActionResult类型</span><br><span class="line">            &#125;</span><br><span class="line">            else if(i1==1)&#123;</span><br><span class="line">                return NotFound(&quot;404&quot;);    //notFound底层会自动转为泛型的ActionResult类型</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            return BadRequest(new ErrorInfo(1,&quot;id必须是参数&quot;));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return new StudentInfo(&quot;张三&quot;,23,oneclass,...)；这样就直接将对象封装成一个json</span><br><span class="line">        </span><br><span class="line">    return Json(&quot;&quot;);会返回一个JsonResult类型，但是最好都是直接用IActionResult来接收</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/net5/assets/%E6%97%A0%E6%A0%87%E9%A2%98-16557329698491.png" alt="无标题"></p><p><img src="/2026/01/29/net5/assets/image-20220620214809722.png" alt="无标题"></p><p><img src="/2026/01/29/net5/assets/%E6%97%A0%E6%A0%87%E9%A2%98-16557330285702.png" alt="无标题"></p><p><img src="/2026/01/29/net5/assets/image-20220620215045094.png" alt="image-20220620215045094"></p><h3 id="WebApi参数传递（模型绑定）"><a href="#WebApi参数传递（模型绑定）" class="headerlink" title="WebApi参数传递（模型绑定）"></a>WebApi参数传递（模型绑定）</h3><p>前端提交的数据自动与后端控制器中的参数进行绑定，绑定原理是通过参数名称进行匹配，前端参数与后端参数相同则成功映射，否则报异常，true和false这些参数也都能自动识别为bool类型，不区分大小写，解决办法使用给参数添加【fromroute】如果控制器中需要传入的是个数组，则使用List《》进行绑定。如果前后端参数名称没有统一，则手动绑定。控制器中参数写[【bind(prefix&#x3D;”email”)】 List《string》 Name，表示前端的email映射到后端的Name上。</p><p>例如后端参数名为classNum,而前端参数为calssNo：则方法中写GetAll(【string schoolName,【fromroute(Name&#x3D;”classNo”)】string classNum})</p><p>1.直接通过参数来获取前端数据【stringquery(Name&#x3D;”gender”)】string genderdisplay;前端名字为gender，后端名字为genderdisplay，这样一一对应。</p><p><a href="http://api/test?id=3&name=%27%E5%BC%A0%E4%B8%89">http://api/test?id=3&amp;name=&#39;张三</a>‘</p><p>2.从路由中获取Route(“{id}”,【fromroute】<a href="http://api/test/3/%E5%BC%A0%E4%B8%89,%E5%A6%82%E6%9E%9C%E5%89%8D%E5%90%8E%E7%AB%AF%E5%8F%82%E6%95%B0%E4%B8%80%E6%A0%B7%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99fromroute%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%B7%AF%E7%94%B1%E6%8C%87%E7%9A%84%E6%98%AF%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B7%AF%E7%94%B1%E8%B7%AF%E5%BE%84%EF%BC%8C">http://api/test/3/张三,如果前后端参数一样可以不写fromroute，注意路由指的是指定的路由路径，</a></p><p>**fromroute和fromquery的区别：**例如route（{api&#x2F;api2&#x2F;…}“）这个才是路由，而querystring是”pageNum&#x3D;8&amp;pSize&#x3D;10“整个字符串，然后querystring方式是从里面提取对应的参数名，如果是querystring则必须在参数前面加上【fromquery】，而fromroute若前后端一致则可以省略。而且fromquery和fromroute都是通过设置url的方式显示获取数据。</p><p>3.【frombody】(它是用来解决使用json方式获取的)：必须通过post方式提交，参数是一个对象,比如说如果传递多个参数，一部分需要从地址栏传送，就指定为querystring，如果另一部分需要从请求体中传递过来，就指定为frombody，不加的话就默认从querystring传递过来,但是如果参数是一个实体类型，则不必写frombody，webapi会自动识别为frombody。<a href="https://www.bbsmax.com/A/obzbNRw1zE/">https://www.bbsmax.com/A/obzbNRw1zE/</a></p><p>​1.如果客户端Content-Type是application&#x2F;json, api接口如果是用单个对象做参数的时候，加或者不加[FromBody]都可以正常解析参数，但是如果用对象列表做参数时候,则必须加[FromBody],否则必须加[FromBody],要不然就读不到参数了。</p><p>​2、如果客户端Content-Type不是application&#x2F;json，api接口必须加[FromForm]，否则客户端调用接口会报400错误。</p><p>​3、如果加上[FromBody]，客户端Content-Type不是application&#x2F;json，接口会报400错误。</p><p>4.【fromForm】：上传文件</p><p>5.【FromService】：作为aciton参数</p><p>6.【FromHeader】:请求头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[httpget]//显示为http://url?i1=5&amp;i2=8</span><br><span class="line"></span><br><span class="line">public int add(int i1,int i2)&#123;</span><br><span class="line"></span><br><span class="line">return i1+i2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[httpget(&quot;&#123;i1&#125;/&#123;i2&#125;&quot;)]//这里&#123;i1&#125;/&#123;i2&#125;相当于一个占位符，最终url显示为http://url/5/8,更加符合rest方式，理解即可</span><br><span class="line"></span><br><span class="line">public int add(int i1,int i2)&#123;</span><br><span class="line"></span><br><span class="line">return i1+i2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求端是个类,则在访问使用会出现json格式的Person类，这时我们只需要为json里面的参数赋值即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int add(Person p1)&#123;</span><br><span class="line">return p1.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/net5/assets/image-20220127232208936.png" alt="image-20220127232208936"></p><p>默认的模型绑定从三个方面提供数据，顺序为1.表单数据2.路由变量3.查询串</p><p>例如&#x2F;home&#x2F;index&#x2F;3?id&#x3D;1因为3为路由变量中的值，而id&#x3D;1为查询串中的值，所以index方法将收到3，而id&#x3D;1将被忽略</p><p>因为模型绑定系统中，对于参数为int类型，如果url中没有传入数值，则会将int类型默认赋值为0，但是需要需要区分未赋值但系统默认为0和手动传入参数为0的两种情况，此时需要使用可空类型</p><p>public IActionResult Index(int? id){</p><p>}</p><p>绑定数组：直接在参数中写string[] names即可</p><p>绑定集合：List《string》names </p><p>绑定源：1.使用查询串：【FromQuery】2.使用请求头：【FromHeader】   3.请求体：【FromBody】(只能用于只有一个参数的action，否则报错)</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>使用缓存可以对性能提升很大,对于某些常用的数据，每次调用服务器都会耗费时间，干脆直接放在内存里面，通过缓存调用。</p><p>三种缓存：1.客户端缓存2.服务器缓存（不建议）3.代理缓存（不用学）4.内存缓存（使用）</p><p>客户端缓存：响应头如果返回cache-control:max-age-60则表示服务器缓存这个内容60s，c#中使用【ResponseCache(Duration&#x3D;60)】这个特性来自动添加该响应头。（得需要观察客户端是否支持缓存）</p><p>服务端缓存：标注【ResponseCache】启用中间件response caching middleware</p><p>​添加中间件：app.UseResponseCaching();&#x2F;&#x2F;放在app.mapcontrollers()之前，放在app.useCors之后，服务器缓存</p><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>通过键值对保存在内存里面，通过键值对保存</p><p>1.builder.Services.AddMemoryCache()</p><p>2.注入IMemoryCache接口</p><p>3.调用里面的TryGetValue，Remove，Set，GetOrCreate（使用该方法代替get方法可以避免缓存穿透），GetOrCreateAsync等方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Book b = await memoryCache.GetOrCreateAsync(source1,source2);第一个参数从内存中获取数据，若获取不到从第二个参数即数据库中获取数据</span><br><span class="line">例如</span><br><span class="line">Book b = await memoryCache.GetOrCreateAsync(&quot;Book&quot;+id,async()=&gt;&#123;return await MyDbContext.GetByIdAsync(id)&#125;)</span><br><span class="line">设置具有过期时间的缓存</span><br><span class="line">Book b = await memoryCache.GetOrCreateAsync(&quot;Book&quot;+id,async(e)=&gt;&#123;</span><br><span class="line">console.writeLine(&quot;缓存中没有，从数据库中获取数据&quot;);</span><br><span class="line">e.AbsoluteExpirationRelativeToNow=TimeSpan.FromSeconds(10);//设置绝对过期时间10s</span><br><span class="line">//e.SlidingExpiration = TimeSpan.FromSeconds(Random.Shared.Next(10,15));//设置滑动过期时间为随机可以避免缓存雪崩，滑动过期时间即如果缓存没过期的情况下请求一次，子缓存会自动虚名一段时间</span><br><span class="line">return await MyDbContext.GetByIdAsync(id)&#125;);&#x27;&#x27;</span><br></pre></td></tr></table></figure><p>常用分布式缓存服务器：Redis等</p><p>1.引用redis：安装Microsoft.extentsions.Caching.StackExchangeRedis</p><p>2.buider.Services.AddStackExchangeRedisCache(options&#x3D;&gt;{options.Configuration&#x3D;”localhost”; options.InstanceName&#x3D;”yzk”})</p><p>缓存穿透：参考杨中科书</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>1.在控制器上[Route(“api&#x2F;companies”)]，然后在action上添加[httpGet(“{companyId}”)]最后url就会拼成api&#x2F;companies&#x2F;2，其中使用{paramter}大括号表示的是将要传递的参数，而使用[Controller]&#x2F;[action]表示对应的controller和action，</p><p>2.直接在action上添加api&#x2F;companies&#x2F;companyId结果与1同样</p><p>3.使用[Route(“api&#x2F;[controller]&#x2F;[action]”)]其中controller相当于一个占位符，会去掉控制器名称后面的controller只留取前面的名字（不推荐）。action使用方法与1一样。</p><p>webapi方式只能使用Route特性设置路由，不能在startup类中通过模板设置路由</p><p>解决一个webapi有多个httpget的请求导致报错的问题：在上面添加一个路由<a href="https://www.cnblogs.com/huangkenicole/p/14456916.html">https://www.cnblogs.com/huangkenicole/p/14456916.html</a></p><h1 id="中间件（MiddleWare）"><a href="#中间件（MiddleWare）" class="headerlink" title="中间件（MiddleWare）"></a>中间件（MiddleWare）</h1><p>就是在管道中运行中的请求和服务器之间的数据处理dd，中间件构成了管道，若一个管道里什么都没有，则是畅通无阻，但是如果想要过滤掉一些东西，就需要中间件，所以中间件的作用，就是过滤掉请求或者响应中的一些不符合要求的信息。例如starpup中的app.UseRouting();&#x2F;&#x2F;该中间件的作用就是路由中间件，是请求地址和控制器之间的映射。中间件的作用就是指定数据提交给服务器和服务器返回的顺序，否则一次所有内容全部提交会导致系统冲突，而且在这过程中进行报文的处理。</p><p>筛选器是net core  mvc中的功能，而中间件是netcore中提供的功能中间件可以处理所有请求，而filter只能处理控制器的请求，优先使用中间件，如果这个组件只针对mvc或者需要使用mvc的功能的时候则使用filter</p><p>每一个中间件都有权做出决定是否将请求传递给下一个中间件，中间件是有顺序的，就是请求就是按照使用的顺序，如下，请求执行1begin，next（）方法跳到2begin请求，next（）方法跳到hellorun，然后返回响应2end，接着响应1end</p><p><img src="/2026/01/29/net5/assets/image-20220128233337920.png" alt="image-20220128233337920"></p><p>Map:用来定义一个管道可以处理哪些请求，是中间件的入口</p><p>Use和Run：用来定义管道，每个Use引入一个中间件（后面还可执行别的中间件，后面有next（）方法），而Run用来执行最后一个中间件，没有next（）方法）执行run时及时后面还有中间件也不执行了，run方法作为最后一个中间件，是没有next（）方法的。</p><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.MapGet(&quot;/&quot;,()=&quot;HelloWorld&quot;);//表示若url以/开头，则打印helloworld</span><br><span class="line">app.MapGet(&quot;/test&quot;,()=&quot;HelloWorld2&quot;);//表示若url以/test开头，则打印helloworld2</span><br></pre></td></tr></table></figure><p>自定义中间件：约定1.该中间件必须具有类型为RequestDelgate的参数的公共构造函数</p><p>2.必须含有名为Invoke或者InvokeAsync()的方法</p><p>3.2中的方法必须有HttpContext参数，方法返回类型必须是Task</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TextMiddleWare</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly RequestDelegate _next;</span><br><span class="line">        public TextMiddleWare(RequestDelegate next)</span><br><span class="line">        &#123;</span><br><span class="line">            _next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task InvokeAsync(HttpContext httpContext) &#123;</span><br><span class="line">            //再这里写业务代码，对http请求进行处理</span><br><span class="line">            await _next(httpContext);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">然后再startup中使用中间件app.UseMiddleware&lt;TextMiddleWare&gt;();即可将中间件放入管道内 （推荐），还有其他方法，比如使用use，run等方法，同上面图片，若使用这种方法则代码都写再startup类太杂。</span><br><span class="line">同依赖注入一样，也可以使用扩展方法，例如app.UseRouting();本质上就是使用的扩展方法</span><br></pre></td></tr></table></figure><p>常用中间件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1.app.UseStaticFiles();//默认仅提供访问wwwroot文件夹的权限</span><br><span class="line"></span><br><span class="line">2.app.UseDefaultFiles();//支持默认文件中间件按照顺序查找Index.htm.Index.html,default.htm,default.html</span><br><span class="line"></span><br><span class="line">3.app.UseDirectoryBrower();//支持目录浏览（一般不用，为了安全不让用户浏览目录）</span><br><span class="line"></span><br><span class="line">4.app.UseDeveloperExceptionPage();//一般在mvc中使用，webapi中提供json，开发异常中间件（开发环境中使用，生产环境不用）</span><br><span class="line"></span><br><span class="line">​if(env.isDevelopment())&#123;</span><br><span class="line"></span><br><span class="line">​app.useDeveloperExceptionPage();//开发环境中使用，因为会暴露具体的异常信息，mvc中使用，webpapi中不使用</span><br><span class="line"></span><br><span class="line">​app.useStatusCodePages();//将描述性消息添加到不包含内容的响应中去。例如404，即如果前端无内容，则返回对应的状态码</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">​app.useExceptionHandler(&quot;/Home/Error&quot;);出现异常就访问error方法，生产环境中使用该方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5.app.Routing()（一般不用 ）;//路由中间件，需要访问静态文件中间件后面</span><br><span class="line"></span><br><span class="line">6.app.UseEndpoints();//路由节点中间件，代替routing中间件，因为配置更见丰富</span><br><span class="line"></span><br><span class="line">7.app.UseStatusCodePages();;//返回一个简单的文本Status：404；NotFound</span><br><span class="line"></span><br><span class="line">8.app.UseStatusCodePagesWithRedirects(“Error”);指定出现异常后访问某个控制器</span><br><span class="line"></span><br><span class="line">9.app.UseStatusCodePagesWithReExecute(“error”)（推荐）;与8结果一样，差别是9显示的url不改变，而8会跳转</span><br><span class="line"></span><br><span class="line">10.app.UseMvcWithDefaultRoute();//使用默认路由不推荐，推荐使用usemvc手动设置，它等价于如下</span><br><span class="line">app.useMvc(routes=&gt;&#123;</span><br><span class="line"></span><br><span class="line">​routes.Maproute(</span><br><span class="line"></span><br><span class="line">​name:&quot;default&quot;,</span><br><span class="line"></span><br><span class="line">​template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">11.app.useMvc(routes=&gt;&#123;//注意，以下仅对mvc模式使用，webapi只能使用route特性的方式设置路由</span><br><span class="line"></span><br><span class="line">​routes.Maproute(</span><br><span class="line"></span><br><span class="line">​name:&quot;default&quot;,</span><br><span class="line"></span><br><span class="line">​template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;;//id？表示id这个参数可传可不传，若不穿则id=null</span><br><span class="line">//template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;&quot;;</span><br><span class="line">如果无请求参数则默认为home/index如果有一个请求参数则为controller值/index,若两个请求参数，则为controller值/action值，该方法可以匹配0个参数，1个参数，2个参数的请求；</span><br><span class="line">//templage:&quot;public/&#123;controller=Home&#125;/&#123;action=Index&#125;&quot;;请求三个参数，第一个必为public</span><br><span class="line"></span><br><span class="line">//defaults:new &#123;controller=&quot;Home&quot;/action=&quot;Index&quot;&#125;;如果template参数中的controller和action后面没加值，则无法匹配0个参数和1个参数的情况，此时加上defaults参数可以解决以上情况，而如果后面加上了值则不必加defaults参数，所以上面的template写法实际上是这种的简化写法。</span><br><span class="line">//template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;/&#123;*catchall&#125;&quot;;最后面的*catchall表示后面可以添加任意长度的路由，就不手动指定长度了比如customer/list/all/delete/perm实际上catchall=/delete/perm</span><br><span class="line">//template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id:int?&#125;&quot;;约束id可为null或者必须为int型</span><br><span class="line">//template:&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id:range(10.20)&#125;同上，其他约束参考coremvc p314，表15-8</span><br><span class="line">​)</span><br><span class="line"></span><br><span class="line">&#125;)推荐使用，如果不设置，则会使用默认的选项。 </span><br></pre></td></tr></table></figure><p>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</p><h1 id="Authentication和Authorization"><a href="#Authentication和Authorization" class="headerlink" title="Authentication和Authorization"></a>Authentication和Authorization</h1><p>Authentication是用来判定用户是否登录成功，即身份验证</p><p>Authorization用户是否对资源有访问权限：即授权验证</p><h1 id="身份验证与授权"><a href="#身份验证与授权" class="headerlink" title="身份验证与授权"></a>身份验证与授权</h1><p>预备工作：身份验证实现并不难，但是是重复性工作，所以core封装了一个系统直接使用，注意：尽量不要使用中文存储在数据库，否则会报错</p><p>IdentityDbContext类继承自DbCOntext类，管理用户时则继承IdentityDbContext类即可，若仅实现操作数据库，则仍然使用DbContext类，只不过前者比后者功能更多。</p><p>UserManager:它可以执行身份验证的所有工作，增删改查，密码管理，外部登录，角色管理等</p><p>IdentityUser类：提供的内置模型类，里面有很多字段，例如id，username，email，password等，如果需要扩展则创建新类继承IdentityUser然后添加新的字段即可。</p><p>IdentityRole：内置角色类，里面包含增删改查等角色信息。</p><p>Identity是一种标识框架，与ef core配对使用</p><p>身份验证：用来说明“你是谁”</p><p>signoutasync：退出&#x3D;撤销身份验证cookie</p><p>使用方法：</p><p>​1.引用identity.efcore，引入ef core sqlserver连接数据库，引入efcore.tools使用命令创建数据库</p><p>​2.让下文类继承IdentityDbContext类,IdentityDbContext继承了Dbcontext，所以他的功能比Dbcontext类功能更多</p><p>​3.注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddIdentity&lt;IdentityUser, IdentityRole&gt;().AddEntityFrameworkStores&lt;AppDbContext&gt;().AddDefaultTokenProviders();//IdentityUser可以是所有继承IdentityUser的拓展类</span><br></pre></td></tr></table></figure><p>​4.添加中间件：app.UseAuthentication();&#x2F;&#x2F;加载routing中间件之前</p><p>5.执行命令add-migration addingIdentity。    update-database</p><h3 id="Claim：声明"><a href="#Claim：声明" class="headerlink" title="Claim：声明"></a>Claim：声明</h3><p>代替角色授权的一种方案：Claims，使用角色认证的缺点在于它是静态的，一旦用户被分为某个角色，用户就之一保持该角色状态，直到角色被移除。使用方式 ：【Authorzie(Policy&#x3D;”DcUsers”)】认证方案&#x2F;策略：就是认证的逻辑，</p><p>内置的策略有services.AddAuthentication(authenticationScheme).AddJwtBearer(JwtBearDefaults.AuthenticatScheme,options&#x3D;&gt;Configration.Bind(“JwtSettings”,options))。。。。。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Service.AddAuthenzation(opts=&gt;</span><br><span class="line">&#123;opts.AddPolicy(&quot;DcUsers&quot;,policy=&gt;//策略名称定为DcUsers</span><br><span class="line">&#123;policy.RequriddRole(&quot;users&quot;)&#125;;要求用户必须为Users角色的成员</span><br><span class="line">     policy.RequireClaim(ClaimTypes.StateOrProvince,&quot;DC&quot;);</span><br><span class="line">。。。其他策略)&#125;);</span><br><span class="line">使用时，使用[Authorzie(Policy=&quot;DcUsers&quot;)]进行使用</span><br></pre></td></tr></table></figure><p>自定义策略：</p><p>1.继承AuthenticationHandler《T options》</p><p>2.若成功则返回sucess，若失败则返回NoResult，若发生异常则返回Fail。</p><p>授权：用来说明：你可以“”访问哪些Controller”;</p><p>授权中间件先注入，1.servies.AddAuthentication();    2.app.useAuthorization();</p><p>简单授权：【Authorize】认证成功的用户可访问，一般用于控制器上</p><p>匿名授权：【AllowAnonymous】：全部允许访问，一般用于action上</p><p>角色授权：【Authoize(Roles&#x3D;”管理员”)】根据角色进行授权</p><p>策略的授权：太复杂</p><p><strong>设置密码复杂度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddIdentity&lt;IdentityUser, IdentityRole&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    //设置密码复杂度</span><br><span class="line">    options.Password.RequiredUniqueChars = 3;//特殊字符数为3</span><br><span class="line">    options.Password.RequireNonAlphanumeric = false;//至少包含一个非字符或数字的字符</span><br><span class="line">    options.Password.RequireLowercase = false;//至少包含一个小写字母</span><br><span class="line">    options.Password.RequireUppercase = false;//、、、大写字母</span><br><span class="line">&#125;).AddEntityFrameworkStores&lt;AppDbContext&gt;();//以上是内置密码验证策略</span><br><span class="line">若想要自定义密码策略，使用IPasswordValidator接口</span><br></pre></td></tr></table></figure><p><strong>登录，退出，注销</strong></p><p>注销使用post请求</p><p>在登录中应添加参数，邮箱，用户名，密码，及是否需要持久性cookie，cookie每次发起请求的时候都会随着请求一起发送到服务器，会话cookie随着浏览器的关闭而关闭，持久性cookie需要设置过期时间</p><p>创建用户：IdentityResult result &#x3D; await userManager.CreateAsync(user,model.Password);</p><p>查询：UserManager.users</p><p>查询Usermanager.FindByIdAsync(id);</p><p>​UserManager.FindByEmailAsync(email);通过邮件查询比较流行。</p><p>删除用户：UserManager.DeleteAsync(user);</p><p>修改：UserManager.UpdateAsync(user);</p><p>退出：await signInManager.SIgnOutAsync();</p><h2 id="根据角色进行验证"><a href="#根据角色进行验证" class="headerlink" title="根据角色进行验证"></a>根据角色进行验证</h2><p>Authorize是最基本的验证方式，即只要通过验证的就可访问action，但是现在不同的角色针对不同的action具有不同的访问权限</p><p>基类：IdentityRole类</p><p>创建角色：IdentityResult result&#x3D; await roleManager.CreateAsync(new IdentityRole(name));</p><p>查询角色：IdentityResult role &#x3D; await roleManager.FindByIdAsync(id);</p><p>IdentityResult role &#x3D; await roleManager.FindByNameAsync(name);</p><p>删除角色：identityResult result &#x3D; await roleManager.DeleteAsync(role);</p><p>查询所有；roleManager.Roles;</p><p>修改：await roleManager.UpdateAsync(role)</p><p>判断某角色是否存在；RoleExistsAsync（name）</p><p>判断某个用户是否属于某个角色：userManager.IsInRoleAsync(user,role.Name);</p><p>为角色中添加用户：UserManager.AddToRoleAsync(user,RoleName);</p><p>从角色中删除用户：UserManager.RemoveFromRoleAsync(user,RoleName);</p><p>获取某个用户的角色：UserManager.getRoleAsync(user);</p><p>关于角色的操作方法都是使用角色名称来执行，而不是使用角色的id</p><p>应用角色：【Authorzie(Roles&#x3D;”Users”)】&#x2F;&#x2F;这是比较简单的一种验证方法。 </p><h2 id="客户端验证"><a href="#客户端验证" class="headerlink" title="客户端验证"></a>客户端验证</h2><p>1.使用js手写逻辑，不推荐</p><p>2.使用netcore自带验证</p><p>直接引入库即可，然后会在input标签中使用asp-for的时候自动加入一个data-val&#x3D;”true”这个属性，表示使用了前端进行验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;~/lib/jquery//dist/jquery.js&quot;&gt;&lt;/script&gt;//一定要按照顺序引用下面三个库</span><br><span class="line">&lt;script src=&quot;~/lib/jquery-validation/dist/jquery.validate.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;~/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="远程验证"><a href="#远程验证" class="headerlink" title="远程验证"></a>远程验证</h2><p>即使用ajax发送数据隐式进行验证。</p><p>首先引入客户端验证的那三个库，然后 在字段上面使用remote特性即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Remote(action:&quot;IsEmailInUse&quot;,controller:&quot;Account&quot;)]</span><br><span class="line">public string Email&#123;get;set;&#125;</span><br></pre></td></tr></table></figure><p>双因子验证：在identity验证的同时，可以使用验证码进行验证，即双重保障。</p><h1 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h1><p>jwt是用户登录后解决用户信息如何保存的问题。</p><p>jwt（json web token）把登录信息保存在客户端，而session是保存在服务器端，jwt为了安全做了签名处理，签名的密钥保存在服务器中,使用JWT代替session的原因是JWT是在内存中加载，而session在分布式集群中性能低。</p><p>token就是对sessionid进行了加密处理称为token</p><p>当用户登录了网站之后，需要系统给一个token，如果访问一个控制器之后想要访问另一个控制器，那么就直接使用token即可，这时需要对控制器进行授权。如果不是在登录过程中进行的访问，那么就不让其访问。如果没有对控制器进行授权，那么任何人都可以直接通过网址链接而不需要进行登录就直接访问了。只要访问任意一个控制器就会产生一个token。（用于解决确认是在登录过程中进行的访问，而不是直接通过链接进行的访问）</p><p>下列场景中使用JSON Web Token是很有用的：</p><ul><li><p>Authorization (授权) : 这是使用JWT的最常见场景。<font color="red">一旦用户登录，后续每个请求都将包含JWT</font>&gt;允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的JWT的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p></li><li><p>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式。因为JWT可以被签名，例如，用公钥&#x2F;私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p><p>token保护方法有三种：1.自约定（例如md5）  2.session+cookie（需要依赖浏览器，无法用于前后端分离或者移动端）3.jwt（完美解决前面的问题）</p></li></ul><p>一个jwt包含三个部分1.头部：header    2.负载Payload     3.Signature（将header+payload+算法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">头部：header = &#x27;&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125;&#x27; 其中alg表示算法的名称为hs256，typ表示token的类型为jwt</span><br><span class="line">payload:payload = &#x27;&#123;&quot;loggedInAs&quot;:&quot;admin&quot;,&quot;iat&quot;:1422779638&#125;&#x27;//iat表示令牌生成的时间</span><br><span class="line">签名：Signature=header+.+payload+hs256算法</span><br></pre></td></tr></table></figure><h3 id="老张的哲学对jwt的使用"><a href="#老张的哲学对jwt的使用" class="headerlink" title="老张的哲学对jwt的使用"></a>老张的哲学对jwt的使用</h3><p>1.注入httpcontextAccessor</p><p>2.创建声明payload，将用户的数据作为payload，主要是保证数据的唯一性，引入token.jwt包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var claim = new claim[]&#123;</span><br><span class="line">new claim(ClaimTypes.Name,&quot;张三&quot;),</span><br><span class="line">new claim(JWtReGistedClaimNames.Email,&quot;123@qq.com&quot;),</span><br><span class="line">new claim(&quot;age&quot;,&quot;24&quot;)//如果没有可用的键名，自己创建一个age键名即可</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.创建token对象及添加算法和数字签名等配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(&quot;ghf.303515.096.aaa&quot;));//定义密钥，只有输入密钥之后才能访问，密码太短会报异常</span><br><span class="line">var token = new JwtSeurityToken()</span><br><span class="line">issuer:&quot;http://locolhost:5000&quot;,//发布者,根据配置文件修改</span><br><span class="line">audience:&quot;http://localhost:6000&quot;,//订阅者</span><br><span class="line">claims:claim,//将2中的payload添加到taken中</span><br><span class="line">expires:DateTime.Now.AddHours(1),//添加过期时间</span><br><span class="line">signingCredentials: new SigningCredentials(key, SecurityAlgorithms.HmacSha256));//添加密钥及算法</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.生成taken</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jwtToken = new JwtSecurityTokenHandler().WriteToken(token);//按照3中的对象生成token</span><br></pre></td></tr></table></figure><p>5.持票人进行bearer认证，并开启中间件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">安装Microsoft.AspNetCore.Authentication.JwtBearer</span><br><span class="line">app.UseAuthentication();</span><br><span class="line">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">            .AddJwtBearer(options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">              options.TokenValidationParameters = new TokenValidationParameters</span><br><span class="line">              &#123;</span><br><span class="line">                ValidateIssuerSigningKey = true,</span><br><span class="line">                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(&quot;SDMC-CJAS1-SAD-DFSFA-SADHJVF-VF&quot;)),</span><br><span class="line">                ValidateIssuer = true,</span><br><span class="line">                ValidIssuer = &quot;http://localhost:6060&quot;,</span><br><span class="line">                ValidateAudience = true,</span><br><span class="line">                ValidAudience = &quot;http://localhost:5000&quot;,</span><br><span class="line">                ValidateLifetime = true,</span><br><span class="line">                ClockSkew = TimeSpan.FromMinutes(60)</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>6.配置swaager开启验证功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在swaggergen中配置</span><br><span class="line">options.AddSecurityDefinition(&quot;Bearer&quot;, new OpenApiSecurityScheme</span><br><span class="line">        &#123;</span><br><span class="line">          In=ParameterLocation.Header,</span><br><span class="line">          Type=SecuritySchemeType.ApiKey,</span><br><span class="line">          Description= &quot;直接在下框中输入Bearer &#123;token&#125;（注意两者之间是一个空格）&quot;,</span><br><span class="line">          Name=&quot;Authorization&quot;,</span><br><span class="line">          BearerFormat=&quot;JWT&quot;,</span><br><span class="line">          Scheme=&quot;Bearer&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">        c.AddSecurityRequirement(new OpenApiSecurityRequirement</span><br><span class="line">        &#123;</span><br><span class="line">          &#123;</span><br><span class="line">            new OpenApiSecurityScheme</span><br><span class="line">            &#123;</span><br><span class="line">              Reference=new OpenApiReference</span><br><span class="line">              &#123;</span><br><span class="line">                Type=ReferenceType.SecurityScheme,</span><br><span class="line">                Id=&quot;Bearer&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            new string[] &#123;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>杨中科步骤1.</p><p>nuget：install-package microsoft.aspnetcore.authentication.jwtbearer</p><h3 id="2-创建一个JWTSetting配置类，创建secKey和ExpireSeconds两个配置项；用来设置加密的密钥和设置保存时间"><a href="#2-创建一个JWTSetting配置类，创建secKey和ExpireSeconds两个配置项；用来设置加密的密钥和设置保存时间" class="headerlink" title="2.创建一个JWTSetting配置类，创建secKey和ExpireSeconds两个配置项；用来设置加密的密钥和设置保存时间"></a>2.创建一个JWTSetting配置类，创建secKey和ExpireSeconds两个配置项；用来设置加密的密钥和设置保存时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class JWTSetting</span><br><span class="line">    &#123;</span><br><span class="line">        public string Seckey &#123; get; set; &#125;//密钥</span><br><span class="line">        public int ExpireSeconds &#123; get; set; &#125;//保存时间</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-配置文件中为"><a href="#3-配置文件中为" class="headerlink" title="3.配置文件中为"></a>3.配置文件中为</h3><p>“JWT”: {<br>    “SecKey”: “lksdjflksjdfslkfjs”,随便写的密钥<br>    “ExpireSeconds”: 3600&#x2F;&#x2F;表示保存一个小时</p><p>  }</p><h3 id="4-注册服务"><a href="#4-注册服务" class="headerlink" title="4.注册服务"></a>4.注册服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  services.Configure&lt;JWTSetting&gt;(Configuration.GetSection(&quot;JWT&quot;));//获取配置文件中的JWT对象赋值给JWTSetting类，getsection返回类型是一个对象</span><br><span class="line">            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">.AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var jwtOpt = Configuration.GetSection(&quot;JWT&quot;).Get&lt;JWTSetting&gt;();//将配置文件以对象形式写入JWTSetting类</span><br><span class="line">    byte[] keyBytes = Encoding.UTF8.GetBytes(jwtOpt.SecKey);//实体类中seckey的数据写成字节数组</span><br><span class="line">    var secKey = new SymmetricSecurityKey(keyBytes);//以下省略就是安全性的问题</span><br><span class="line">    x.TokenValidationParameters = new()</span><br><span class="line">    &#123;</span><br><span class="line">        ValidateIssuer = false,</span><br><span class="line">        ValidateAudience = false,</span><br><span class="line">        ValidateLifetime = true,</span><br><span class="line">        ValidateIssuerSigningKey = true,</span><br><span class="line">        IssuerSigningKey = secKey</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/net5/assets/image-20220129101807057.png" alt="image-20220129101807057"></p><h3 id="5-添加中间件："><a href="#5-添加中间件：" class="headerlink" title="5.添加中间件："></a>5.添加中间件：</h3><p>app.UseAuthentication()；</p><h3 id="6-在控制器中添加payload："><a href="#6-在控制器中添加payload：" class="headerlink" title="6.在控制器中添加payload："></a>6.在控制器中添加payload：</h3><p>每一个claim都是要是payload信息，只需要添加必要的信息，不要什么都填</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private readonly IOptionsSnapshot&lt;JWTSetting&gt; jwtSetting;</span><br><span class="line"></span><br><span class="line">        public Login2Controller(IOptionsSnapshot&lt;JWTSetting&gt; jwtSetting)</span><br><span class="line">        &#123;</span><br><span class="line">            this.jwtSetting = jwtSetting;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpPost]</span><br><span class="line">        public  ActionResult&lt;string&gt; Login(string name, string password)</span><br><span class="line">        &#123;</span><br><span class="line">            if (name == &quot;yzk&quot; &amp;&amp; password == &quot;123456&quot;)</span><br><span class="line">            &#123;</span><br><span class="line">                List&lt;Claim&gt; claims = new List&lt;Claim&gt;();</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.NameIdentifier, &quot;1&quot;));</span><br><span class="line">                claims.Add(new Claim(ClaimTypes.Name, name));</span><br><span class="line"></span><br><span class="line">                string key = jwtSetting.Value.SecKey;//通过配置文件读取,从这里直接到return之间直接抄，最终就是经过加密获得jwt</span><br><span class="line">                DateTime expires = DateTime.Now.AddSeconds(jwtSetting.Value.ExpireSeconds);//当前时间加上一小时</span><br><span class="line">                byte[] secBytes = Encoding.UTF8.GetBytes(key);</span><br><span class="line">                var secKey = new SymmetricSecurityKey(secBytes);</span><br><span class="line">                var credentials = new SigningCredentials(secKey, SecurityAlgorithms.HmacSha256Signature);</span><br><span class="line">                var tokenDescriptor = new JwtSecurityToken(claims: claims,</span><br><span class="line">                    expires: expires, signingCredentials: credentials);</span><br><span class="line">                string jwt = new JwtSecurityTokenHandler().WriteToken(tokenDescriptor);//</span><br><span class="line">                return jwt;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return BadRequest();</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>访问之后可以看到获取的jwt为下图</p><p><img src="/2026/01/29/net5/assets/image-20220203232659420.png" alt="image-20220203232659420"></p><p><img src="/2026/01/29/net5/assets/image-20220129101856167.png" alt="image-20220129101856167"></p><h3 id="7-如上图，"><a href="#7-如上图，" class="headerlink" title="7.如上图，"></a>7.如上图，</h3><p>在需要登录的控制器上或者action上添加[authorize],当在一个新的控制器上使用Authorize时会报错，因为只有登录的用户才能访问，怎样才能访问呢？1.使用Postman，在报文头自定义Authorization的值为“Bearer +空格+JWTToken”，即假设获取到了JWT。2.设置swagger，添加服务如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">简单配置swagger：</span><br><span class="line">app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, &quot;MyToDo.Api v1&quot;));</span><br><span class="line">复杂配置</span><br><span class="line">builder.Services.AddSwaggerGen(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var scheme = new OpenApiSecurityScheme()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = &quot;Authorization header. \r\nExample: &#x27;Bearer 12345abcdef&#x27;&quot;,</span><br><span class="line">        Reference = new OpenApiReference&#123;Type = ReferenceType.SecurityScheme,</span><br><span class="line">            Id = &quot;Authorization&quot;&#125;,</span><br><span class="line">        Scheme = &quot;oauth2&quot;,Name = &quot;Authorization&quot;,</span><br><span class="line">        In = ParameterLocation.Header,Type = SecuritySchemeType.ApiKey,</span><br><span class="line">    &#125;;</span><br><span class="line">    c.AddSecurityDefinition(&quot;Authorization&quot;, scheme);</span><br><span class="line">    var requirement = new OpenApiSecurityRequirement();</span><br><span class="line">    requirement[scheme] = new List&lt;string&gt;();</span><br><span class="line">    c.AddSecurityRequirement(requirement);&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/net5/assets/image-20220203233409231.png" alt="image-20220203233409231"></p><p><img src="/2026/01/29/net5/assets/image-20220203233347808.png" alt="image-20220203233347808"></p><p>当对swagger添加服务后，通过Logger控制器获取JWT，然后在swagger中进行认证之后就可以可以访问Demo2控制器了。</p><p><img src="/2026/01/29/net5/assets/image-20220204000446888.png" alt="image-20220204000446888"></p><h3 id="8-注意事项"><a href="#8-注意事项" class="headerlink" title="8.注意事项"></a>8.注意事项</h3><p>除了下面这些设置，还可以通过角色进行访问【Authorize(Roles&#x3D;”admin”)】;只有管理员权限才可进行访问</p><p><img src="/2026/01/29/net5/assets/image-20220129102219450.png" alt="image-20220129102219450"></p><h3 id="9-保存JWT"><a href="#9-保存JWT" class="headerlink" title="9.保存JWT"></a>9.保存JWT</h3><p>当登录之后，服务器返回给客户端的JWT需要保存在Web端，App，小程序等，可以保存在配置文件，只要请求时带着即可。退出登陆时，在服务器端将JWT扔掉即可</p><h3 id="10-JWT提前撤回"><a href="#10-JWT提前撤回" class="headerlink" title="10.JWT提前撤回"></a>10.JWT提前撤回</h3><p>如果客户端通过手机和电脑同时访问服务器，那么两个都可以登录，如果想要实现只能一台设备登录，那么就需要让JWT提前撤回。第二种情况，如果一个员工离职了，虽然账号密码删除了，但是JWT仍然存在，所以需要让JWT提前失效。但是JWT是保存客户端的，无法撤回，所以需要将JWT的状态保存在服务端，以判断JWT是否失效。</p><p>具体措施思路：在用户表中增加一个整数类型的列JWTVersion，代表最后一次发放出去的令牌的版本号；每次登录、发放令牌的时候，都让JWTVersion的值自增，同时将JWTVersion的值也放到JWT令牌的负载中；当执行禁用用户、撤回用户的令牌等操作的时候，把这个用户对应的JWTVersion列的值自增；当服务器端收到客户端提交的JWT令牌后，先把JWT令牌中的JWTVersion值和数据库中JWTVersion的值做一下比较，如果JWT令牌中JWTVersion的值小于数据库中JWTVersion的值，就说明这个JWT令牌过期了。</p><p>实现：1、为用户实体User类增加一个long类型的属性JWTVersion，并迁移到数据库<br>2、修改登录并发放令牌的代码，登录成功后把用户的JWTVersion属性的值自增，数据库中的JWTVersion也自增，并且把JWTVersion的值写入JWT令牌。<br>3、编写一个操作筛选器，统一实现对所有的控制器的操作方法中JWT令牌的检查操作。把JWTValidationFilter注册到Program.cs中MVC的全局筛选器中。（看视频）</p><h1 id="automapper，DTO"><a href="#automapper，DTO" class="headerlink" title="automapper，DTO"></a>automapper，DTO</h1><p>例如一个student模型，对应数据库中的student，但是如果前端只需要id和name值，那么获取的student对象里面的属性值过多，所以我们建一个studentdto类，其中studentdto只包含student类中的id和name属性，即前端只需要这两个属性，当从数据库查询结果后，将获取的student对象中的id和name赋给studentdto的id和name，这样只需要操作dto就可以了。进一步解耦,这是使用dto的原因。类似于select id,name from student ;一种方式是使用dto（参考前面），另一种方式就是使用automapper，映射成功的条件是属性名必须相同，如果映射名不相同如下代码</p><p>首先创建companyDto对应Company类中需要映射的属性</p><p>1.安装automapper.extensions,microsoft.dependencyinjection包和Automapper包</p><p>2.添加服务services.addautomapper(AppDomin.CurrentDomin.GetAssemblies());</p><p>3.创建一个CompanyProfile类继承于Profile类，在构造方法中创建映射,CreateMap&lt;Company,CompanyDto&gt;（）;&#x2F;&#x2F;说明Company映射到CompanyDto</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CompanyProfile:Profile</span><br><span class="line">public CompanyProfile()</span><br><span class="line">&#123;</span><br><span class="line">CreateMap&lt;Company,CompanyDto&gt;（）;//这是映射名相同的情况</span><br><span class="line">CreateMap&lt;Company,CompanyDto&gt;（）.ForMember（destinationMember:dest=&gt;dest.CompanyName,memberOptions:opt=&gt;opt.MapFrom(mapExpression:src=&gt;src.Name)）;//这是映射名不相同的情况下即CpmpanyName映射到Name</span><br><span class="line">//如果想要在映射之前对数据进行处理，例如默认赋值，忽略匹配等操作。参考老张的哲学Dto与多模型</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.控制器如果想要使用CompanyDto,首先注入Imapper mapper，使用mapper即可例如mapper.Map&lt;IEnumerable《CompanyDto》&gt;(companies);即可获取返回的CompanyDto对象集合</p><p>mapper.Map《CompanyDto》(companies);即将查询的结果companies映射到CompanyDto中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">var employee = await reposity.getUsers();</span><br><span class="line">var aaa = mapper.Map&lt;EmployeeDto&gt;(employee);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="过滤器、筛选器（filter）"><a href="#过滤器、筛选器（filter）" class="headerlink" title="过滤器、筛选器（filter）"></a>过滤器、筛选器（filter）</h1><p>过滤器属于mvc中的功能,而中间件属于netcore中的功能,它的作用是在访问action方法之前制定一些规则,过滤掉不符合规则的请求,例如要求只能使用https访问.过滤器是对所有的方法都奏效,而不是某个操作方法,如果将过滤规则写在控制器中的操作方法也可以,但是每个方法中都写一边非常麻烦,所以使用过滤器,而且处理安全策略默认就是使用过滤器.</p><p>实现过滤器:</p><p>1.授权过滤器（会使用jwt进行授权策略编写，不使用该过滤器）</p><p>它在其他类型的过滤器之前和执行操作方法之前执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class HttpsOnlyAttibute:Attibute,IAuthorizationFilter&#123;</span><br><span class="line">public void OnAuthoraizationAsync(AuthoriazationFilterContext context)&#123;</span><br><span class="line">if(!context.HttpContex.Request.IsHttps)&#123;</span><br><span class="line">context.Result=new StatusCodeResult(StatuCodes.Status403Forbidden)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">使用的时候直接在控制器上使用[HttpsOnly]特性即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.操作过滤器（会用到）</p><p>在调用操作方法前调用OnActionExecuting方法,之后调用OnActionExecuted方法,可在调用方法前中间请求进程,也可在执行操作后更改结果.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ProfileAttribute:ActionFilterAttribute&#123;</span><br><span class="line">private Stopwatch timer;</span><br><span class="line">public override void OnActionExecuting(ActionExecutingContext context)&#123;</span><br><span class="line">timer.StartNew();</span><br><span class="line">&#125;</span><br><span class="line">public override void OnActionExecuted(ActionExecutedContext context)&#123;</span><br><span class="line">timer.stop();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.结果过滤器（不使用）</p><p>在mvc处理操作方法返回的操作结果的前后应用，能够更改或替换操作结果或完全取消请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ViewResultDetailAttribute:ResultFilterAttribute&#123;</span><br><span class="line">public override void OnResultExecuting(ResultExecutingContext context)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//使用方式，在controller上使用[ViewResultDetail]特性</span><br></pre></td></tr></table></figure><p>4.异常过滤器（会用到）</p><p>允许响应异常，不需在每个操作方法中写try。。。catch代码块，可以手动处理异常，而不是使用netcore自己的处理方式，比如出现异常的时候返回日志，这都是需要自己进行设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RangeExceptionAttribute：ExceptionFilterAttribute&#123;</span><br><span class="line">public override void OnException(ExceptionContext context)&#123;</span><br><span class="line">if(context.Exception is ArgumentOutRangeException)&#123;</span><br><span class="line">context.result=new ViewResult()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//使用方式[RangeException]</span><br></pre></td></tr></table></figure><p>过滤器的执行顺序：授权过滤器&#x3D;》操作过滤器&#x3D;》结果过滤器（注意可以更改顺序，但是必须实现接口，省略 ）</p><p>第二步：依赖注入</p><h1 id="托管服务"><a href="#托管服务" class="headerlink" title="托管服务"></a>托管服务</h1><p>代码运行在后台，比如服务器启动的时候在 后台预先加载数据到缓存，每天凌晨三点把数据导出到备份数据库，每隔五秒钟在两张表之间同步一次数据</p><p>注意：托管服务是单例的声明周期注册到容器中的，而不能用范围或者瞬态注入。</p><p>使用方法：托管服务最终需要实现IHostedService接口，但是我们一般编写继承BackGroundService的类，该类实现了IHostedService接口，然后注册注册服务：services.addHostedService&lt;类名&gt;();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HostService1 : BackgroundService</span><br><span class="line">   &#123;</span><br><span class="line">       protected override async Task ExecuteAsync(CancellationToken stoppingToken)</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;HOstedService启动服务&quot;);</span><br><span class="line">           await Task.Delay(3000);</span><br><span class="line">           Console.WriteLine(&quot;等待服务&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   然后注册服务</span><br><span class="line">   services.AddHostedService&lt;IHostedService&gt;();</span><br></pre></td></tr></table></figure><h1 id="FluentValidation"><a href="#FluentValidation" class="headerlink" title="FluentValidation"></a>FluentValidation</h1><p>FluentValidation是一种校验规则，类似于特性（atrribute），但是对于大项目更适用，降低耦合性</p><p>1.nuget:FluentValidation.aspNetcore </p><p>2.注册服务：             services.AddFluentValidation(opt &#x3D;&gt; { opt.RegisterValidatorsFromAssembly(Assembly.GetEntryAssembly());});</p><p>3.创建模型验证类实现AbstractValidator&lt;实体类&gt;接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">比如对应的模型类</span><br><span class="line"> public class addNewUser</span><br><span class="line">    &#123;</span><br><span class="line">        public string email &#123; get; set; &#125;</span><br><span class="line">        public string  name &#123; get; set; &#125;</span><br><span class="line">        public string  passWord &#123; get; set; &#125;</span><br><span class="line">        public string passWord2 &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    对应的模型验证类为</span><br><span class="line">public class addNewUserValidation:AbstractValidator&lt;addNewUser&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        public addNewUserValidation()</span><br><span class="line">        &#123;</span><br><span class="line">            RuleFor(x =&gt; x.email).NotNull().EmailAddress()</span><br><span class="line">            .Must(x =&gt; x.EndsWith(&quot;@163.com&quot;) || x.EndsWith(&quot;@qq.com&quot;));</span><br><span class="line">            RuleFor(x=&gt;x.name).NotNull().Length(3,10);</span><br><span class="line">            RuleFor(x=&gt;x.passWord).Equal(x=&gt;x.passWord2);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="SignalR（看视频）"><a href="#SignalR（看视频）" class="headerlink" title="SignalR（看视频）"></a>SignalR（看视频）</h1><p>websocket用来解决服务器主动向客户端发起请求，例如web聊天室，直播，即时通讯技术，因为传统中是客户端向服务器发请求，然后服务器进行响应，这个技术解决服务器主动发起请求。客户端向服务器发起请求后，服务器接收后又向另一个客户端发送传递过来的消息，后一段过程就需要使用signalr。又比如网页浏览时，出现的新闻推送也属于服务端向客户端主动发起请求。websocket是基于tcp。（网页端实现实时通讯）</p><p>signal是对websocket进行了封装，这样更加方便使用。Hub集线器是SingalR中的一个组件，通过Hub来进行通讯</p><p>在hub中所有的方法是被客户端调用的方法。而方法中的client.xxx.xxx是服务器主动调用客户端的方法。</p><p>1.在startup类中进行注册</p><p>2.在前端页面中引入signal</p><p>3.注册服务器连接</p><p>4.给客户端注册方法</p><p>5.启动链接并处理事件</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>aspect Oriented Programming</p><p>它是一种思想，在.net core中aop的使用：autofac的使用</p><h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>梁桐铭深入浅出asp.net core 单层web应用和多层web应用的区别+asp.net core的仓储模式</p><p>三层架构中的BLL，DAL，UI在加上model层对应</p><ul><li><p><strong>表示层</strong>(User Interface layer)&#x3D;web&#x3D;UI&#x3D;Controller&#x3D;控制器：主要对用户的请求接受，以及数据的返回，为客户端提供应用程序的访问。</p></li><li><p><strong>业务逻辑层</strong>(Business Logic Layer)&#x3D;BLL&#x3D;service：业务逻辑层 BLL 的功能是对具体问题进行逻辑判断与执行操作，接收到表现层 UI 的用户指令后，会连接数据访问层 DAL。业务逻辑层用于做一些有效性验证的工作，以更好的保证程序运行的健壮性。如完成数据添加、修改和查询业务等；不允许指定的文本框中输入空字符串，数据格式是否正确以及数据类型验证；用户权限的合法性判断等；通过以上的诸多判断以决定是否将操作继续向后传递，尽量保证程序的正常运行。之前所有的判断都是放在了Controller中，实际上这都是错误的，而是应该放在BLL层，Controller只是起到UI的作用。</p></li><li><p><strong>数据访问层&#x2F;仓储层</strong>(Data access layer)&#x3D;dao&#x3D;Mapper&#x3D;Repository：数据访问层 DAL 是对数据库主要操控，实现数据的增加、删除、修改、查询等操作，并将操作结果反馈到业务逻辑层 BLL。</p></li><li><p><strong>实体类库</strong>（model&#x2F;entity）：就是数据表中对应的实体类</p></li><li><p><strong>控制器</strong> 他是属于mvc中的东西，属于UI层</p></li><li><p>控制器的作用就是做一些其他的工作，比如说</p><p>​             1.ef引用并设置链接字符串<br>​            2.JWT引用<br>​            3.Attribute过滤，校验登录的合法性<br>​            4.每个控制器进行跨域<br>​            5.为Action编写viewModel验证提交的数据的合法性<br>​            6.为返回的结果编写一个ResponseData处理统一返回的数据</p><p>​            7.在适当的地方调用BLL层中的方法</p></li></ul><p>MVC与三层架构的关系，MVC中的V和C就是三层架构中的UI层，而三层架构中的BLL和DAL和Model层就是MVC中的Model层,在webapi中没有了V所以C就是UI层</p><p>而调用流程是Repository引用Models层，Service层引用Repository层，Net（UI）引用Service层</p><p>.netcore中的Services(BLL),Repository（Dal）,webAPI(UI)如下图可以看到，包含controller的那层就是UI层，repository和service层与该项目是同级别的，</p><p><img src="/2026/01/29/net5/assets/image-20220202215116862.png" alt="image-20220202215116862"></p><p>repository的作用：实际上他是等价于Dao层的，只不过dao层中进行增删改查，因为数据库中有很多表，所以dao层中，每个表的增删改查都需要重写一边，那么就重复性工作，所以单独创建一个Repository层，该层创建一个Repository的实体类和泛型接口，该接口封装了对所有的表的操作的常用方法，这样，我们在调用的时候只需要传入对应的实体类即可完成增删改查操作，这样，如果某个类需要连接多个数据库，那么直接实现该接口即可，不必每个数据库都手写增删改查。对于一些更细致的方法，让Repository中的自己dao仓储层自己去实现。而repository是公共使用的，他不具体对应哪个类，所有类都可以使用。对于大型项目，最好每一个仓储类对应一个仓储接口，这样如果需要连接不同数据库直接找对应的接口即可，对于小型项目，即一个数据库，直接所有的仓储类都实现同一个接口即可。</p><p>注意；无法注册的原因是因为类没有public</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>下面的返回类型均是IActionResult类型,webapi的返回类型可以是特定类型（string，对象等），当有多个ActionResult返回类型是，推荐使用IActionResult；若返回两种类型的数据例如string和actionresult，则使用ActionResult《string》作为返回类型。</p><p>200：OK()，返回类型为AcceptedResult</p><p>404:NotFound();，第二种方式：Response.statusCode&#x3D;404;,第三种方式badRequest(400),</p><p>400：BadRequestResult</p><p>201:CreateResult</p><p>204:NoContentResult</p><p>415:</p><h1 id="托管模型"><a href="#托管模型" class="headerlink" title="托管模型"></a>托管模型</h1><p>进程内(默认)：只有一个服务器：IIS或者Kestrel。配置文件中写《aspnetcore hostingmode》Inprocess《&#x2F;asp net core hostingmode》</p><p>进程外：有两个服务器：内部服务器（kestrel）和外部服务器（IIs,nginx）。配置文件中写《aspnetcore hostingmode》outprocess《&#x2F;asp net core hostingmode》</p><p><img src="/2026/01/29/net5/assets/image-20220210214041148.png" alt="image-20220210214041148"></p><p>托管的影响：在lauchsetting设置中我们可以看到如果启动方式选择IIsExpress，在配置文件中就会调用IIsExpress配置文件，当使用Kestrel时就会调用webaplication的配置文件，其中launchbrower表示是否使用浏览器进行调试</p><p><img src="/2026/01/29/net5/assets/image-20220210214420598.png" alt="image-20220210214420598"></p><p>其中commandName只能设置三个参数：IIsExpress&#x2F;IIs&#x2F;Project</p><p>luanchBorwer:是否启动浏览器进行调试</p><h1 id="处理全局异常（针对webapi）"><a href="#处理全局异常（针对webapi）" class="headerlink" title="处理全局异常（针对webapi）"></a>处理全局异常（针对webapi）</h1><p>用于出现错误时，返回结果的具体细节不返回给客户端，而是返回自定义的异常信息。解决方法1.在项目的属性配置中，将开发环境改为生产环境。（即异常的时候返回空白）方法二：参考软件工艺师asp.netcore处理服务器端故障。</p><p>步骤：1.不要使用 app.useDeveloperExceptionPage();,他是用在mvc中的</p><p>2.app.useExceptionHandler(builder&#x3D;&gt;builder.run(async context&#x3D;&gt;context.Response().StatusCode&#x3D;StatusCode500InterServerError,</p><p>context.Response.ContentType&#x3D;”applacation&#x2F;json”),</p><p>…)</p><h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p><img src="/2026/01/29/net5/assets/image-20220212122741573.png" alt="image-20220212122741573"></p><p>会单独创建一个类，用来进行保存分页中的参数</p><p>1.pageNumber：当前在第几页</p><p>2.pageSize：每页的条数</p><p>3.总页数</p><p>其中需要将2与3进行比较：使用geter ，setter进行过滤</p><p>4.前一页，后一页链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int PageNumber&#123;get;set;&#125;=1;//默认为第一页</span><br><span class="line">public int MaxPageSize=20;//最大页数</span><br><span class="line">public int PageSize=5;//默认为5</span><br><span class="line">public int PageSize</span><br><span class="line">&#123;</span><br><span class="line">get=&gt;PageSize;</span><br><span class="line">set=&gt;PageSize=(value&gt;MaxPageSize)? MaxPagesize:value;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="强制使用https"><a href="#强制使用https" class="headerlink" title="强制使用https"></a>强制使用https</h2><p>1.【RequireHttps】2.配置端口</p><h1 id="跨域CORS"><a href="#跨域CORS" class="headerlink" title="跨域CORS"></a>跨域CORS</h1><p>同域：两个url有相同的协议+主机+端口例如https：&#x2F;&#x2F;baidu.com:5001 若三项中有一项不一样就是跨域，浏览器为了安全不允许访问，需要使用cors，例如某个网页中的第三方链接。跨域的原因实际上是因为使用前端实际上是使用内置的服务器，也就对应内置的域名，而后端也有自己的内置服务器和域名，cors的作用就是将两者的域名进行对接起来，可以相互访问。</p><p>这是浏览器的安全机制：用于解决一个页面访问另外一个服务器页面的请求。</p><p>如果协议+主机+端口号相同则不跨域</p><p>解决方法1.nuget install micresof.aspnetcore.webapi.cors</p><p>2.注册services.AddCors(options&#x3D;&gt;{</p><p>​options.AddDefaultPolicy(builder&#x3D;&gt;builder.WithOrigin(“http:&#x2F;….&#x2F;tengxun.com”).AllowAnyMethod().AllowAnyHeader().AllowCredentials())</p><p>})</p><p>3.使用特性进行配置，在controller或者action上使用[EnableCors(“AnotherPolicy”)]&#x2F;&#x2F;使用该策略决定是否可以跨域访问</p><p>4.使用中间件(放在app.useHttpsRedirection之前)：app.useCors();</p><h1 id="windows和linux部署"><a href="#windows和linux部署" class="headerlink" title="windows和linux部署"></a>windows和linux部署</h1><p>参考老张的哲学asp.net core学习视频教程</p><h1 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h1><p>用于微服务，即将多个功能分配在不同的服务器上调用（一般用不上），使用grpc可以在客户端应用中像调用本地对象一样直接调用另一台机器上的服务端应用的方法。它需要有自己的规范协议。protocol buffers</p><h2 id="ErrorInfo类"><a href="#ErrorInfo类" class="headerlink" title="ErrorInfo类"></a>ErrorInfo类</h2><p>项目中，处理失败的情况，手写一个错误码,并将错误码和错误信息根据情况返回回去。NotFound是展现在后台的错误码，而ErrorInfo是展现在前台的错误码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public record ErrorInnfo(int Code,string? Message);</span><br><span class="line">使用时遇见失败情况</span><br><span class="line">return BadRequest(new ErrorInfo(1,&quot;id必须是参数&quot;));</span><br><span class="line">return NotFound(new ErrorInfo(2,&quot;人员不存在&quot;));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MVC</title>
      <link href="/2026/01/29/MVC/"/>
      <url>/2026/01/29/MVC/</url>
      
        <content type="html"><![CDATA[<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>MVC5：新建项目的时候选择web项目-》mvc</p><p>更换访问端口：右击项目-》属性-》web</p><p>MVC是一种web开发框架。</p><p>​Models：实体模型，就是用来操作数据库的</p><p>​View：视图，用户可以看到的前端界面</p><p>​Controllor：决定用户调用哪个视图，调用哪个逻辑计算</p><span id="more"></span><p>浏览原理：视图-》浏览器端提交请求-》模型-》控制器-》处理-》模型-》视图</p><p>vs2013在iis上发布一个网站：</p><p>​1.首先点击项目于右键-》发布-》自定义-》输入一个发布名-》发布方法选择文件系统-》目标位置选择当前项目所在的路径名-》点击发布完成。发布就是将网站源码打包成一个文件夹，将源码封装起来。不让用户看见源码，例如写完的exe文件就是已经打包好的。</p><p>​2.在iis上添加一个网站-》设置网站名称-》网站路径选择 发布的项目。部署完成。部署就是将文件夹发布到iis上。</p><p>获取前端提交数据的两种方式</p><p>一：使用内置对象request方式获取</p><p>二（推荐）：在控制器的index的方法添加参数例如public ActionResult Index(string name){其他代码}，其中的参数就是前端页面提交的数据</p><p>如果想要post访问mvc页面，该页面提供了post提交方式，那么第一种方式是使用postman，第二种方式是先使用get方式获取到页面，然后访问该页面使用使用post方式进行提交数据到action方法中访问，所以需要同名的两个action，一个是httpget先获取到页面，然后通过页面访问httppost的同名action，否则无法直接访问httppost中的action</p><h1 id="访问原理："><a href="#访问原理：" class="headerlink" title="访问原理："></a>访问原理：</h1><p>客户端通过访问view中某个cs文件下的某个方法进行访问默认是index，会自动返回view中的html界面。例如192.168.0.1：2021&#x2F;Home&#x2F;index</p><h1 id="MVC的目录结构："><a href="#MVC的目录结构：" class="headerlink" title="MVC的目录结构："></a>MVC的目录结构：</h1><p><img src="/2026/01/29/MVC/assets/%E6%8D%95%E8%8E%B73.PNG" alt="捕获3"></p><p>如图，所有的默认情况都是再routeconfig文件中配好的，这样会默认访问指定Home ，index，。。。</p><p>访问方式：由地址栏访问控制器controllor，通过model进行校验访问数据库，然后返回一个view</p><p>​AppStart：配置文件</p><p>​Bundle：打包器：作用1.压缩文件2.随着js文件的更新而更新。例如在layout.cshtml文件中就引入了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;~/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script src=&quot;~/Scripts/bootstrap.min.js&quot;&gt;&lt;/script&gt;这两个打包器一般是script中的js文件</span><br></pre></td></tr></table></figure><p>打包器的另一个作用是在webconfig文件中有一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.5&quot;/&gt;当debug为true时，在页面出现错误时会提示哪一行出现错误，用于调试时使用，若改为false则出现错误时不会提示错误，而且前端代码堆叠在一起，没有换行空格等，这就是打包器的作用。</span><br></pre></td></tr></table></figure><p>​Filter：过滤器</p><p>​Route:路由配置，如果</p><p>​Content：css样式</p><p>​Controller：控制器，默认控制器下的所有启动称为action。默认有一个控制器，该控制器名字HomeContrller。默认的action（默认页面）名字是控制器中的index方法，index（）的返回类型是ActionResult类。controller中的方法返回的是个view对象，根据源码view类有多个重写方法。1.不含参2.一个参数3.两个参数4.三个参数。其中第一个参数viewname指的的视图名，如果不写表示当前方法对应的view中的cshtml，如果更改就显示另一个cshtml页面。第二个参数mastername表示母版页，如果不写默认使用viewstart中指定的母版页，（修改母版页的方式1.通过view传参，方式2.在cshtml文件中指定_Layout）第三个参数是一个object对象，默认为null（使用方法参考controller传动view中的方式四，model传送）。<strong>（1添加控制器的方式是点击控制器，右键添加控制器。</strong></p><p>​Font：里面放的是图标和字体</p><p>​Model：实际上就是操作数据库的数据处理模型,操作数据库</p><p>​Script：js文件</p><p>​View：视图：注意controller里面的文件（例如homeController.cs）在view中有对应的文件名的文件夹（对应为Home）。**（2.控制器创建完成之后，点击index方法，右键创建视图，会在view生成对应文件夹中自动创建一个index.cshtml。**同时controller的类文件里面的方法（比如说index方法）,在view下的对应文件夹下有对应的html文件(对应为index.cshtml)；手动创建view视图页，在文件夹右键添加，新建项，web，razor ，内容页</p><p>​Shared：里面的layout文件是个完整的前端页面（相当于一个母版）叫做布局，约定以下划线开头，所有的index页面会默认使用该layout页面，即这个页面的内容会自动插入到创建的index页面中。在其里面有个@renderbody()这句代码，这句代码相当于一个占位符，当用户指定Home文件下的index.cshtml时就会将index里面的代码替换掉renderbody。如果home文件下的某个html页面不想用layout中的模板，那么就在inedex.cshtml页面中ViewBag.Title &#x3D; “页面名”;的下一行添加layout &#x3D; null;这句代码。如下图</p><p><img src="/2026/01/29/MVC/assets/%E6%8D%95%E8%8E%B74.PNG" alt="捕获4"></p><p>​Viewstart文件：里面的一句代码Layout &#x3D; “~&#x2F;Views&#x2F;Shared&#x2F;_Layout.cshtml”;指定了mvc默认指定的模板页就是layout.cshtml页面。所以<font color="red">viewstart是起指定访问页面的文件。</font></p><h1 id="Mvc中的传递方式，将数据从view传递给控制器"><a href="#Mvc中的传递方式，将数据从view传递给控制器" class="headerlink" title="Mvc中的传递方式，将数据从view传递给控制器"></a>Mvc中的传递方式，将数据从view传递给控制器</h1><h3 id="方式一（推荐）："><a href="#方式一（推荐）：" class="headerlink" title="方式一（推荐）："></a>方式一（推荐）：</h3><p>直接使用控制器index方法中的参数例如 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult Index(string name,string pwd)</span><br><span class="line">        &#123;</span><br><span class="line">            return Content(name);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>客户端的数据在mvc中都是通过键值对进行获取的保存的。</p><h3 id="方法二：Request"><a href="#方法二：Request" class="headerlink" title="方法二：Request"></a>方法二：Request</h3><p>a) 使用get方式进行了提交（例？name&#x3D;123）那么获取方式就是Request.QueryString[“name”];获取字符串</p><p>b) 使用post方式进行提交，获取字符串数据方式：Request.Form[“name”];</p><p>若在index中写入[HttpGet]则会要求只能get请求</p><p>获取用户上传的文件：</p><p>Request.Files[“file”].SaveAs(Request.MapPath(“~&#x2F;upload&#x2F;“+Request.Files[“file”].FileName))</p><p>Request.Files[“file”];&#x2F;&#x2F;file文件是用户通过前端进行上传的文件。但是注意上传成功后必须点击点击当前项目，找到解决方案资源管理器中右上角的显示所有文件的图标，否则上传成功后在文件夹下找不到。</p><p>SaveAs()；将上传的文件保存在当前项目的文件夹下（必须使用绝对路径）</p><p>Request.MapPath(“~&#x2F;upload&#x2F;“+Request.Files[“file”].FileName)；会自动将相对路径转换为绝对路径。即保存在当前项目下upload文件夹下以原文件名命名的文件。代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult Index(string name)</span><br><span class="line">       &#123;</span><br><span class="line">           ViewBag.content = &quot;这是controller中的数据&quot;;</span><br><span class="line">           ViewData[&quot;Name&quot;] = &quot;张三&quot;;</span><br><span class="line">           TempData[&quot;age&quot;] = &quot;24&quot;;//特点，只能访问一次，第二次访问就会消失</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">       Student stu = new Student();</span><br><span class="line">​        stu.id = 12;</span><br><span class="line">​        stu.name = &quot;张三&quot;;</span><br><span class="line">​        stu.age = 24;</span><br><span class="line">​        string name2 = Request.QueryString[&quot;name&quot;].ToString();</span><br><span class="line">​       // Request.Form[&quot;name&quot;];</span><br><span class="line">​        return Content(name2);//Content方法即直接向页面输出对应的字符串，类似于响应</span><br><span class="line">​        //获取get提交方式的数据</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line">​    public ActionResult login2() &#123;</span><br><span class="line">​        return View();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public ActionResult login(LoginUser user) &#123;</span><br><span class="line">​        if (ModelState.IsValid)//这里是在验证实体类中添加的特性是否通过验证，否则添加的特性没有用</span><br><span class="line">​        &#123;</span><br><span class="line">​            if (user.name == &quot;张三&quot; &amp;&amp; user.password == &quot;123&quot;)</span><br><span class="line">​            &#123;</span><br><span class="line">​                return Content(&quot;登录成功&quot;);</span><br><span class="line">​            &#125;</span><br><span class="line">​            else</span><br><span class="line">​            &#123;</span><br><span class="line">​                return Content(&quot;登录失败&quot;);</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;</span><br><span class="line">​        else &#123;</span><br><span class="line">​            return Content(&quot;您的数据有误&quot;);</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response.write(“helloworld”);&#x2F;&#x2F;向客户端输出内容</p><p>Response.redirect(url);&#x2F;&#x2F;重定向</p><p>Response.StatusCode()&#x2F;&#x2F;返回的状态码，404</p><h3 id="Session-保存在服务器中，用来存储少量重要数据。比如账号"><a href="#Session-保存在服务器中，用来存储少量重要数据。比如账号" class="headerlink" title="Session:保存在服务器中，用来存储少量重要数据。比如账号"></a>Session:保存在服务器中，用来存储少量重要数据。比如账号</h3><p>Session[“user”]&#x3D;request.form[“user”];&#x2F;&#x2F;是通过键值对的方式进行保存的。</p><p>Session默认存货时间20分钟</p><p>Session.abanon&#x2F;session.clear()&#x2F;&#x2F;清除session</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>向客户端保存cookie：response.cookies.add(new HttpCookie(“token”){</p><p>​Value &#x3D; “acb456453156”；&#x2F;&#x2F;token的值</p><p>​Expires &#x3D; DateTime.Now.AddDays(1);&#x2F;&#x2F;保存时间为1天</p><p>});</p><p>从客户端获取cookie：Request.Cookies[“token”].Value</p><p>删除cookie：response.cookies.add(new HttpCookie(“token”){</p><p>​Expires &#x3D; DateTime.Now.AddDays(-1);&#x2F;&#x2F;时间改为负值进行删除cookie</p><p>});</p><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>保存在服务器中与session的区别，session是每个人只能访问自己的session，而application是可以互相访问的</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>封装了了服务器常用属性。比如服务器名称等。</p><p>Server.transfer();&#x2F;&#x2F;转发。重新打开一个页面但是该页面与之前的页面必须在同一个文件下。即转发不能转发外站的内容。而重定向可以定位到一个外站的内容。</p><h1 id="通过控制器将数据传递到view的方式："><a href="#通过控制器将数据传递到view的方式：" class="headerlink" title="通过控制器将数据传递到view的方式："></a>通过控制器将数据传递到view的方式：</h1><p>可以通过三种方式将信息返回到前端1.使用终止中间件2.使用控制器的Content方法直接返回3.使用视图即View，或者razor</p><h2 id="view访问controller中的数据"><a href="#view访问controller中的数据" class="headerlink" title="view访问controller中的数据"></a>view访问controller中的数据</h2><p>在一个控制器中手写一个方法，右键该方法-》视图-》添加视图即可看见在view中添加了对应的html。当控制器中的方法执行时，该方法的返回值return view();会自动定位到view中的cshtml。</p><p>访问方式：客户端通过访问controller中某个cs文件下的某个方法进行访问默认是index，会自动返回view中的html界面。</p><p>控制器中的方法称为action。</p><p>返回类型IactionResult子类有viewresult（返回相应的razor视图），contentresult（返回字符串），redirect（重定向到指定的url），redirecttoaction（重定向某一个方法和控制器上）,redirectToRoute(new{controller&#x3D;”Example”,action&#x3D;”Index”,Id&#x3D;MId});重定向到指定的路由.</p><p>其他类型的返回结果:</p><p>JsonResult&#x3D;&gt;Json();返回json数据</p><p>ContentResult&#x3D;&gt;Content();返回指定对象</p><p>ObjectResult&#x3D;&gt; …</p><p>OkObjectResult&#x3D;&gt;Ok();返回内容</p><p>NotFoundObjectResult&#x3D;&gt;NotFound();返回404</p><p>FileContentResult&#x3D;&gt;File();将指定的MiME类型发送字节数组</p><p>FileStreamResult&#x3D;&gt;File();发送流文件</p><p>VirtualFileResult&#x3D;&gt;File();虚拟路径读取流</p><p>VIew方法:1.View();调用默认视图,不传递数据</p><p>2.View(“MyView”);返回对应的视图</p><p>3.View(model);将模型数据返回给默认的视图</p><p>4.View(“myview”,model);将模型数据返回给对应的视图</p><p>控制器中的数据显示到cshtml的代码：</p><p>​方式一：控制器的index方法中使用viewBag.变量名 &#x3D; “显示内容”，然后在index.cshtml中写入@viewBag.变量名，当view执行到此处时，就会执行controller中的代码，就会最终将controller的内容显示到view界面。</p><p>​方式二：使用ViewData[“变量名”]&#x3D;”显示内容”，在cshtml中写入@viewData[“变量名”]即可。</p><p>​方式三：使用tempdata[“变量名”]&#x3D;“显示内容”，cshtml中写入@tempdatea[“变量名”]即可显示特点：只能够访问一次，之后立即消失</p><pre><code>ViewBag.content = &quot;这是controller中的数据&quot;;//方式一        ViewData[&quot;Name&quot;] = &quot;张三&quot;;//方式二        TempData[&quot;age&quot;] = &quot;24&quot;;//方式三       （以上是写在controller中的index方法中）        （以下是写在index.cshtml文件中）        @ViewBag.content@ViewData[&quot;name&quot;]@TempData[&quot;age&quot;]</code></pre><p>方式四：通过传递model（对象）的形式（这种方式用来传递主要数据比如新闻，类，上面三种用来传递零碎数据，比如广告），然后在对应的index.cshtml文件中通过@Model.属性来获取信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult Index(string name)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student stu = new Student();//这是model中的对象</span><br><span class="line"></span><br><span class="line">​      stu.id = 12;</span><br><span class="line"></span><br><span class="line">​      stu.name = &quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">​      stu.age = 24;</span><br><span class="line"></span><br><span class="line">​      return view(student);//注意view的重载方法有8个</span><br><span class="line">    //return View(&quot;showdata3&quot;,student());//第一个参数相当于转发作用，将所有student数据传送到showdata3.cshtml文件中</span><br><span class="line">    return view(&quot;showdata3&quot;,&quot;_Layout2&quot;,student());//指定使用的母版页为_Layout2</span><br><span class="line">    </span><br><span class="line">​    &#125;</span><br><span class="line">以上代码在index()中</span><br><span class="line">以下代码在index.cshtml文件中</span><br><span class="line">@model 项目名.Models.Student//只有加了这行代码，下面调用id，name，age时才会出现提示，否则不会出现提示，这样指定了从controller中传过来的类型，相当于c#代码中的using作用。</span><br><span class="line">@&#123;</span><br><span class="line">    ViewBag.Title = &quot;Index&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;h2&gt;Index&lt;/h2&gt;</span><br><span class="line">@Model.id @Model.name @Mode.age</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="view访问model中的数据"><a href="#view访问model中的数据" class="headerlink" title="view访问model中的数据"></a>view访问model中的数据</h2><p>注意：虽然在一个项目中，但是如果在controller中创建model中的对象，仍需要引用命名空间。</p><p>view不能够直接访问model中的数据，需要通过controller作为中介。在contoller中创建model的对象，将这个对象通过controller中返回的view()的第三个参数进行传递。然后在view中使用@Model.id<br>@Model.age@Model..name的形式获取model中的数据。</p><p>注意（在view中如果直接使用@Model.age那么后面的age是不会提示的，因为控制器返回的是一个object类型，所以需要在view中的首行进行拆箱，写入@model MVC.Models.Student，这样它才会提示对象的各种属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model中：</span><br><span class="line"></span><br><span class="line">public class Student</span><br><span class="line">    &#123;</span><br><span class="line">        public int id;</span><br><span class="line">        public string name;</span><br><span class="line">        public int age; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">controller中：</span><br><span class="line"></span><br><span class="line"> Student stu = new Student();</span><br><span class="line">            stu.id = 12;</span><br><span class="line">            stu.name = &quot;张三&quot;;</span><br><span class="line">            stu.age = 24;</span><br><span class="line">​return View(stu);</span><br><span class="line"></span><br><span class="line">view中：</span><br><span class="line">@model MVC.Models.Student//小写model，进行强类型转换</span><br><span class="line">@Model.id//大写Model</span><br><span class="line">@Model.age</span><br><span class="line">@Model..name</span><br></pre></td></tr></table></figure><p>将view中的数据传递到controller的方式：</p><p>方式一：Request.QueryString[“提交的键”];(适用于get提交方式)</p><p>Request.Form[“提交的键”];&#x2F;&#x2F;适用于post提交方式</p><p>方式二：直接通过action的形参获取即可：缺点如果提交的参数过多，那么index方法中的形参也就越多，所以微软推荐方式三</p><p>public ActionResult Index(string name,string password)</p><p>{</p><p>&#x2F;&#x2F;在前端传递了一个name参数，那么index中的name形参就会接收到</p><p>Return Content(name+password)</p><p>}</p><p>方式三（这种方式更加）：在model中创建一个专门用来存取数据的类，里面的属性就是前端传递的数据参数，前端传递了name和password，在控制器的index中用类对象作为形参，方法中直接对象.变量名使用即可。但是注意：model中的属性必须添加get，set即使用prop自动生成，否则访问不了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult login(LoginUser user) &#123;</span><br><span class="line"></span><br><span class="line">​      if (ModelState.IsValid)//只有防伪标记认证成功后才会进入否则进入false，方位戳在cshtml页面中</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        if (user.name == &quot;张三&quot; &amp;&amp; user.password == &quot;123&quot;)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          return Content(&quot;登录成功&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          return Content(&quot;登录失败&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        return Content(&quot;您的数据有误&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据控制器自动生成前端页面。使用前端进行账号密码验证"><a href="#根据控制器自动生成前端页面。使用前端进行账号密码验证" class="headerlink" title="根据控制器自动生成前端页面。使用前端进行账号密码验证"></a>根据控制器自动生成前端页面。使用前端进行账号密码验证</h3><p>1.Controller的action写完后，添加视图模板中选择create，</p><p>2.模型类选择需要需要使用的类，类似上面方法三中传递的LoginUser类，</p><p>3.勾选添加脚本,使用脚本之后，我们就不需要自己手动写代码去验证，而是通过修改一些数据即可。</p><p><img src="/2026/01/29/MVC/assets/image-20220117092647085.png" alt="image-20220117092647085"></p><p><img src="/2026/01/29/MVC/assets/wps4C5A.tmp.jpg" alt="img"></p><p>这就是代码上面自己创建的脚本代码(理解以下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@using (Html.BeginForm()) </span><br><span class="line">&#123;</span><br><span class="line">    @Html.AntiForgeryToken()              //这是防伪标记（防伪戳），以防止这是别人修改页面生成的</span><br><span class="line">    </span><br><span class="line">    &lt;div class=&quot;form-horizontal&quot;&gt;</span><br><span class="line">        &lt;h4&gt;LginViewModel&lt;/h4&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        @Html.ValidationSummary(true, &quot;&quot;, new &#123; @class = &quot;text-danger&quot; &#125;)   //数据验证不通过时显示的错误信息</span><br><span class="line">        &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">            @Html.LabelFor(model =&gt; model.name, htmlAttributes: new &#123; @class = &quot;control-label col-md-2&quot; &#125;)//显示的是[display（name）]的值</span><br><span class="line">            &lt;div class=&quot;col-md-10&quot;&gt;</span><br><span class="line">                @Html.EditorFor(model =&gt; model.name, new &#123; htmlAttributes = new &#123; @class = &quot;form-control&quot; &#125; &#125;)           //文本框的数据</span><br><span class="line">                @Html.ValidationMessageFor(model =&gt; model.name, &quot;&quot;, new &#123; @class = &quot;text-danger&quot; &#125;)                     //文本框验证不通过的错误消息</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">            @Html.LabelFor(model =&gt; model.pwd, htmlAttributes: new &#123; @class = &quot;control-label col-md-2&quot; &#125;)</span><br><span class="line">            &lt;div class=&quot;col-md-10&quot;&gt;</span><br><span class="line">                @Html.EditorFor(model =&gt; model.pwd, new &#123; htmlAttributes = new &#123; @class = &quot;form-control&quot; &#125; &#125;)</span><br><span class="line">                @Html.ValidationMessageFor(model =&gt; model.pwd, &quot;&quot;, new &#123; @class = &quot;text-danger&quot; &#125;)</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;submit&quot; value=&quot;Create&quot; class=&quot;btn btn-default&quot; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    @Html.ActionLink(&quot;Back to List&quot;, &quot;Index&quot;)</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;~/Scripts/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;~/Scripts/jquery.validate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;~/Scripts/jquery.validate.unobtrusive.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>要是想要修改自动生成的脚本数据比如限制长度，修改名称等，不应该在cshtml中修改，而是在实体类中修改，前提是引入using System.ComponentModel.DataAnnotations;包</p><p>【reqiured】：必写</p><p>【Range】数据范围</p><p>【MinLength】：字符串最小长度</p><p>【MaxLength】：字符串最大长度</p><p>【Compare】：比较是否相等</p><p>【RegularExpression】：正则表达式</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class LginViewModel</span><br><span class="line">   &#123;</span><br><span class="line">       //对name属性进行数据验证，这种方式是c#独有的</span><br><span class="line">     [Display(Name = &quot;账户&quot;)]</span><br><span class="line">       [EmailAddress(ErrorMessage = &quot;邮件名有误&quot;)]</span><br><span class="line">       [Required(ErrorMessage = &quot;请填写邮箱&quot;) ] //要求必填</span><br><span class="line">       [StringLength(maximumLength:10,MinimumLength =2,ErrorMessage =&quot;字符个数不正确&quot;)]</span><br><span class="line">        public string name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">       //同上</span><br><span class="line">       [Display(Name =&quot;密码&quot;)]</span><br><span class="line">       [Required,MinLength(length:6)]</span><br><span class="line">       [DataType(DataType.Password)]</span><br><span class="line">       public string pwd &#123; get; set; &#125;</span><br><span class="line">       </span><br><span class="line">       //比较，将确认密码与初始密码比较</span><br><span class="line">       [Compare(nameof(pwd))]</span><br><span class="line">       public string confirmpwd&#123;get;set;&#125;</span><br><span class="line">       </span><br><span class="line">       //范围</span><br><span class="line">       [Range(10,20,ErrorMessage=&quot;年龄在10-20之间&quot;)]</span><br><span class="line">       public int age;</span><br><span class="line">       //电话号码</span><br><span class="line">       [Phone]</span><br><span class="line">       public string phone;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/MVC/assets/image-20220117103518475.png" alt="image-20220117103518475"></p><h2 id="分析控制器中的ActionResult子类"><a href="#分析控制器中的ActionResult子类" class="headerlink" title="分析控制器中的ActionResult子类"></a>分析控制器中的ActionResult子类</h2><p>1.VIewResult:return ：返回视图例如view()中view的类型就是</p><p>2.ContentResult:返回字符串：例如return Content(“字符”);</p><p>3.RedirectAction:返回重定向：例如retun </p><p>4.RedirectToRouteResult:跳转到另一个action中</p><p>5.FileResult:向客户端输出文件</p><p>6.Json：返回一个json </p><p>7.返回状态码</p><p>8.PartialVIewResult,返回部分页面。特点是不会自动使用母版页相当于vue中的组件，使用背景：重复使用相当于一种可以嵌入的页面  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class HomeController : Controller</span><br><span class="line">   &#123;</span><br><span class="line">       // GET: Home</span><br><span class="line">       public ActionResult Index()</span><br><span class="line">       &#123;</span><br><span class="line">           return View();</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index2() &#123;</span><br><span class="line">           return Content(&quot;字符串&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index3() &#123;</span><br><span class="line">           return Redirect(&quot;www.baidu.com&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index4() &#123;</span><br><span class="line">           return RedirectToAction(&quot;index1&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index5() &#123;</span><br><span class="line">           return File(@&quot;F:\图片\IMG_20170731_121939.jpg&quot;, &quot;image/jpg&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index6() &#123;</span><br><span class="line">           return Json();</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index7() &#123;</span><br><span class="line">           return new HttpStatusCodeResult(System.Net.HttpStatusCode.InternalServerError);</span><br><span class="line">       &#125;</span><br><span class="line">       public ActionResult index8() &#123;</span><br><span class="line"></span><br><span class="line">           return PartialView();    </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="cshtml中html语言和c-可以写在一起，通过-符号进行区分"><a href="#cshtml中html语言和c-可以写在一起，通过-符号进行区分" class="headerlink" title="cshtml中html语言和c#可以写在一起，通过@符号进行区分"></a>cshtml中html语言和c#可以写在一起，通过@符号进行区分</h3><p>1.@{}中括号内的代码为c#代码，同时里面如果写了html标签则会自动识别为html标签例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@&#123;</span><br><span class="line">var culture = model.Name;</span><br><span class="line">&lt;h1&gt;culture &lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.@a+1输出12+1</p><p>3.@（a+1）输出13</p><p>4.邮箱中的@默认为邮箱中的@，不需要转义</p><p>5.将C#中的字符串里面的html代码输出使用@HTML.Row();</p><p>6.输出@符号使用@@</p><p>7.@**@为注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  public ActionResult List() &#123;</span><br><span class="line"></span><br><span class="line">            return View(new List&lt;Student&gt;() &#123;</span><br><span class="line">                new Student()&#123;</span><br><span class="line">                    id = 1,</span><br><span class="line">                    name = &quot;张三  &quot;,</span><br><span class="line">                    age = 23</span><br><span class="line">                &#125;,</span><br><span class="line">                 new Student()&#123;</span><br><span class="line">                    id = 2,</span><br><span class="line">                    name = &quot;里斯&quot;,</span><br><span class="line">                    age = 23</span><br><span class="line">                &#125;,</span><br><span class="line">                  new Student()&#123;</span><br><span class="line">                    id = 3,</span><br><span class="line">                    name = &quot; 王五 &quot;,</span><br><span class="line">                    age = 23</span><br><span class="line">                &#125;,</span><br><span class="line">                  new Student()&#123;</span><br><span class="line">                    id = 4,</span><br><span class="line">                    name = &quot; 赵六 &quot;,</span><br><span class="line">                    age = 23</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); ; ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">cshtml文件中如下</span><br><span class="line">@model List&lt;MVCtest2.Models.Student&gt;</span><br><span class="line">@&#123;</span><br><span class="line">    ViewBag.Title = &quot;List&quot;;</span><br><span class="line">    int a = 12;</span><br><span class="line">    string name = &quot;list&quot;;</span><br><span class="line">    string html = @&quot;&lt;span style = &#x27;color:red&#x27;&gt;hello&lt;/span&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"></span><br><span class="line">    @foreach (var stu in Model)</span><br><span class="line">    &#123;</span><br><span class="line">        &lt;li&gt;@stu.name&lt;/li&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @(a + 1)  @name</span><br><span class="line">    &lt;span&gt;email:2222222@qq.com&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;@@&lt;/span&gt;</span><br><span class="line">    @Html.Raw(html);</span><br><span class="line"></span><br><span class="line">    @&#123;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            a + 11;</span><br><span class="line">            a + 12;</span><br><span class="line">            name;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">            &#125;</span><br><span class="line">    @*</span><br><span class="line">        这里是注释区域</span><br><span class="line">    </span><br><span class="line">        *@</span><br><span class="line"></span><br><span class="line">    &lt;/ul&gt;</span><br></pre></td></tr></table></figure><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><p>区域的作用，每个区域代表不同的功能，例如管理，计费，等，因为所有的控制器不可能在一组文件夹里面，区域通过路由进行支持</p><p>特点：与创建的项目的MVC5的目录结构完全一样，相当于项目中的子mvc5,保存在Areas文件夹下，每个区域有自己的controllers，views，models文件夹</p><p>点击项目，右键，添加，新搭建机架的项目，MVC5区域即可创建</p><p><img src="/2026/01/29/MVC/assets/image-20220117155134447.png" alt="image-20220117155134447"></p><p>若是项目中的mvc与区域中的mvc里面的控制器相同，那么当访问默认页面时，会发现路由无法区分访问哪个控制器而报错，此时需要在路由配置中加入namespace字段配置访问的包名即可</p><p><img src="/2026/01/29/MVC/assets/image-20220117160546827.png" alt="image-20220117160546827"></p><p>在使用Areas中的控制器的时候，要指定使用哪个域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Area(&quot;Admin&quot;)]</span><br><span class="line">public class HomeController:Controller&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">若使用特性路由则为</span><br><span class="line">[Route(&quot;[area]/app/[controller]/action&quot;)]</span><br></pre></td></tr></table></figure><h3 id="TagHelper"><a href="#TagHelper" class="headerlink" title="TagHelper"></a>TagHelper</h3><p>标签助手的一个功能是使用asp-for将属性与模型中的属性关联起来</p><p>为什么使用taghelper，因为它可以动态生成连接，即如果更改更改路由模板，会自动修改url</p><p>@addTagHelper *,……….导入taghelper</p><p>1.表单路由&#x2F;超链接元素</p><p>asp-controller ,指定该链接访问某个控制器</p><p>asp-action，指定该链接访问某个action</p><p>asp-route-{value}指定下一层路由参数</p><p>asp-route;直接指定url地址，类似于href</p><p>asp-protocol&#x3D;”https”:指定协议</p><p>asp-host&#x3D;”mudomain.com”;指定服务器名称</p><p>asp-fragment;指定url片段 </p><p>asp-route-area;指定域为那个</p><p>没有method属性，需手动添加，如果忽略，则默认为get方式</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a asp-controller=&quot;home&quot; asp-action=&quot;details&quot; asp-route-id=&quot;info&quot;&gt;link&lt;/a&gt;</span><br><span class="line">&lt;form asp-controller=&quot;home&quot; asp-action=&quot;details&quot; asp-route-id=&quot;info&quot;&gt;link2&lt;/form&gt;</span><br><span class="line">最终生成的连接就是&lt;a href=&quot;/home/details/info&quot;&gt;link&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>2.图片,使用taghelper会增加清除缓存的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;~/images/num.png&quot; asp-append-version=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><p>3.Input，asp-for会生成name，id，type和value特性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input asp-for=&quot;Name&quot;/&gt;</span><br><span class="line">等价于</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;Name&quot; name=&quot;Name&quot; value=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure><p>4.label，也是通过asp-for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;label asp-for=&quot;Name&quot;&gt;&lt;/label&gt;</span><br><span class="line">等价于</span><br><span class="line">&lt;label for=&quot;Name&quot;&gt;Name&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>5.select</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>6.如果控制器中没有使用ModelState.IsValid验证，它是对模型类的所有属性都进行一遍验证。想要在前端对后端属性进行验证,modelstate.isvalid验证是否成功，是后端逻辑处理，将其与asp-validation-summary进行搭配使用用来将错误显示在前端，ModelState的作用是来记录验证错误，为asp-validation-summary属性提供ModelOnly值，将属性上特性中的错误信息备注(例如【required】出现错误)如何显示在前端，就是通过ModelState进行汇总，然后传递给asp-validation-summary属性，然后才会显示在前端。</p><p>《div asp-validation-summary&#x3D;“All”》《&#x2F;div》一般用来将错误信息汇总起来显示在最上面，同时在对应的属性级别出现错误时再显示一遍错误消息。（不好看）</p><p>《div asp-validation-summary&#x3D;“ModelOnly”》《&#x2F;div》；仅将错误消息显示汇总在最上面，而每个出现错误对应的输入框上面不会显示错误消息（不好看）</p><p>《div》《span asp-validation-for&#x3D;“Name”》《&#x2F;span》《&#x2F;div》:验证Name属性，仅在对应的输入框上面显示错误消息。(好看)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;span asp-validation-for=&quot;Email&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;div asp-validation-for=&quot;Email&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>asp-validation-summary&#x3D;“All”：列举所有错误，modelonly：只列举模型错误</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WPF&amp;Maui</title>
      <link href="/2026/01/29/Maui/"/>
      <url>/2026/01/29/Maui/</url>
      
        <content type="html"><![CDATA[<h1 id="wpf"><a href="#wpf" class="headerlink" title="wpf"></a>wpf</h1><p>**wpf的所有控件的属性，**及其方法<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls?view=windowsdesktop-6.0&viewFallbackFrom=netcore-3.1">https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls?view=windowsdesktop-6.0&amp;viewFallbackFrom=netcore-3.1</a></p><p>wpf官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/wpf-samples?view=netframeworkdesktop-4.8">https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/wpf-samples?view=netframeworkdesktop-4.8</a></p><p>为什么一些控件是使用Content显示内容，一些使用Text属性显示内容？因为他们继承的父类不一样，使用Content显示的内容可以显示各种东西，而使用Text显示的内容只可以显示字符串。</p><p>引入阿里巴巴图库字体的使用方式：<a href="https://www.cnblogs.com/msjqd/p/14790480.html%EF%BC%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%97%E4%BD%93%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8/#%E5%BD%A2%E5%BC%8F">https://www.cnblogs.com/msjqd/p/14790480.html，嵌入式字体需要使用/#形式</a></p><p>cursor属性：例如《Button cursor&#x3D;“No” toolTip&#x3D;”This is mine”&#x2F;》表示当button控件获取到鼠标焦点时，光标会变成对应的样式，toolTip属性：工具提示</p><p>ListBox：是一种数据集合：可选择。博客：<a href="https://www.cnblogs.com/yang-fei/p/4720596.html,%E4%B8%8B%E4%B8%80%E7%BA%A7%E6%98%AFItemTemplate">https://www.cnblogs.com/yang-fei/p/4720596.html,下一级是ItemTemplate</a></p><span id="more"></span><p><img src="/2026/01/29/Maui/assets/image-20230206165427406.png" alt="image-20230206165427406"></p><p>**itemsControl：**也是一种集合，不可选择，仅展示作用,是一种容器，她下面包含三种模板，1.控件模板 （整个容器）2.项目面板模板（每个小容器如何布局，uniformed，wrappanel）3.数据模板：用来展示数据。(注，只有先将数据源绑定之后，才会显示面板和数据),如果数据过多，默认不会添加滚动条，可以在外层添加也给scrollerView来手动添加。</p><p>itemscontrol与listbox的区别</p><pre><code> 1. ListBox是ItemsControl的一个子类，它提供了一些额外的功能，如选择项、多选、滚动条等。而ItemsControl只是一个简单的控件，只提供了显示数据的功能。 2.  ListBox默认使用StackPanel作为ItemsPanel，而ItemsControl默认使用ItemsPanelTemplate来定义ItemsPanel。这意味着你可以更容易地自定义ItemsPanelTemplate来改变ItemsControl的布局方式。 3.   ListBox提供了一些附加属性，如SelectionMode、SelectedIndex、SelectedValue等，用于控制选择项的行为。而ItemsControl没有这些属性。  4.  ListBox提供了一些事件，如SelectionChanged、Selected、Unselected等，用于处理选择项的变化。而ItemsControl没有这些事件。 总之，如果你需要一个简单的列表控件来显示数据，可以使用ItemsControl。如果你需要更多的功能，如选择项、多选、滚动条等，可以使用ListBox。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建ItemsControl，让其条目的数值为绑定的数据源的值--&gt;</span><br><span class="line">        &lt;ItemsControl Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Margin=&quot;10&quot; ItemsSource=&quot;&#123;Binding Source=&#123;StaticResource myTodoList&#125;&#125;&quot;&gt;</span><br><span class="line">            &lt;ItemsControl.Template&gt;    &lt;!--ItemsControl作为一个容器，设置其整体的外观--&gt;</span><br><span class="line">                &lt;ControlTemplate TargetType=&quot;ItemsControl&quot;&gt;</span><br><span class="line">                    &lt;Border BorderBrush=&quot;Red&quot; BorderThickness=&quot;6&quot; CornerRadius=&quot;30&quot;&gt;</span><br><span class="line">                        &lt;ItemsPresenter/&gt;</span><br><span class="line">                    &lt;/Border&gt;</span><br><span class="line">                &lt;/ControlTemplate&gt;</span><br><span class="line">            &lt;/ItemsControl.Template&gt;</span><br><span class="line">            &lt;ItemsControl.ItemsPanel&gt;  &lt;!--设置该容器中子控件的布局类型为 WrapPanel--&gt;</span><br><span class="line">                &lt;ItemsPanelTemplate&gt;</span><br><span class="line">                    &lt;WrapPanel/&gt;</span><br><span class="line">                &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">            &lt;/ItemsControl.ItemsPanel&gt;</span><br><span class="line">            &lt;ItemsControl.ItemTemplate&gt; &lt;!--设置容器中每个条目的模板--&gt;</span><br><span class="line">                &lt;DataTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate.Resources&gt;</span><br><span class="line">                        &lt;Style TargetType=&quot;TextBlock&quot;&gt;</span><br><span class="line">                            &lt;Setter Property=&quot;FontSize&quot; Value=&quot;14&quot;/&gt;</span><br><span class="line">                            &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Center&quot;/&gt;</span><br><span class="line">                        &lt;/Style&gt;</span><br><span class="line">                    &lt;/DataTemplate.Resources&gt;</span><br><span class="line">                    &lt;Grid&gt;</span><br><span class="line">                        &lt;Ellipse Fill=&quot;Silver&quot;/&gt;</span><br><span class="line">                        &lt;StackPanel&gt;</span><br><span class="line">                            &lt;TextBlock Margin=&quot;3,3,3,0&quot; Text=&quot;&#123;Binding Path=TaskPriority&#125;&quot;/&gt;</span><br><span class="line">                            &lt;TextBlock Margin=&quot;3,0,3,7&quot; Text=&quot;&#123;Binding Path=TaskName&#125;&quot;/&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Grid&gt;</span><br><span class="line">                &lt;/DataTemplate&gt;</span><br><span class="line">            &lt;/ItemsControl.ItemTemplate&gt;</span><br><span class="line">            &lt;ItemsControl.ItemContainerStyle&gt; &lt;!--设置容器中每个子控件的样式，如尺寸及Triggers等--&gt;</span><br><span class="line">                &lt;Style&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;Control.Width&quot; Value=&quot;100&quot;/&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;Control.Margin&quot; Value=&quot;5&quot;/&gt;</span><br><span class="line">                    &lt;Style.Triggers&gt;</span><br><span class="line">                        &lt;Trigger Property=&quot;Control.IsMouseOver&quot; Value=&quot;True&quot;&gt;</span><br><span class="line">                            &lt;Setter Property=&quot;Control.ToolTip&quot; </span><br><span class="line">                                    Value=&quot;&#123;Binding RelativeSource=&#123;x:Static RelativeSource.Self&#125;,Path=Content.TaskDescription&#125;&quot;/&gt;</span><br><span class="line">                        &lt;/Trigger&gt;</span><br><span class="line">                    &lt;/Style.Triggers&gt;</span><br><span class="line">                &lt;/Style&gt;</span><br><span class="line">            &lt;/ItemsControl.ItemContainerStyle&gt;</span><br><span class="line">        &lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/Maui/assets/image-20230428184653543.png" alt="image-20230428184653543"></p><p>**ToggleButton:**开关按钮，第一次单机保持按下状态，再一次单机表示释放。checkBox和radioButton继承于ToggleButton</p><p>**ReaptButton:**只要按钮保持按下状态，该类就不断触发click事件。例如滚动条上的箭头。对于普通按钮，用户只触发一次。</p><p><img src="/2026/01/29/Maui/assets/image-20230206165439708.png" alt="image-20230206165439708"></p><p><strong>textblock与textbox于label的区别：</strong></p><p>前者类似于label，只显示，无功能，无边框，而textbox类似于html中的input输入框，label功能比textblock强大，label使用Content设置文本，还可添加其他东西，而textblock通过text设置文本，只能设置文本</p><p><strong>allowstransparents</strong>   如果设置为false，在窗口上面仍然会有一个窄白色边框，所以通常设置为true<img src="/2026/01/29/Maui/assets/image-20230425214208404.png" alt="image-20230425214208404"></p><h4 id="wpf所有布局控件："><a href="#wpf所有布局控件：" class="headerlink" title="wpf所有布局控件："></a><strong>wpf所有布局控件</strong>：</h4><p>grid,stackpanel,dockpanel,wrappanel,canvas</p><p>区别：grid网格布局，注意grid和stack panel如何选择：如果是针对两个或者两个以上的控件进行具体的布局（即stackpanel的最底层是控件），则使用stack panel，反之如果还有一些更复杂的结构，则使用grid。即stackpanel针对的控件，而grid针对的是空间。再比如，如果两个控件分布在一行的两端，则使用grid而不是stackpanel，因为stackpanel是相互贴近排列的。</p><p>StackPanel:一般常用于局部布局：属性orientation可设置水平或垂直布局（如果是整体布局中的整行则使用grid，如果是局部布局中的整行则使用stackpanel）</p><p>WrapPanel:类似于bootstrap，是一种自适应布局,默认横向排列，如果满则自动换行。</p><p>DockPanel:可以设置停靠的布局，它只停靠在容器的边缘dockpanel里面的元素会被附上DockPanel.Dock&#x3D;”left&#x2F;top,right”属性（默认从left开始），DockPanel自身具有LastChildFill&#x3D;true属性，默认为true，容器中最后一个元素会填充面板中的所有内容，所以如果应用了dockpanel首先做的是就是将LastChildFill&#x3D;false，否则如果设置最后一个控件的位置不起作用。<font color="red">一般用在只有两个元素，其中最后一个元素占有剩余所有空间的情况。</font>&gt;</p><p>UniformGrid:将grid表格均分，通过设置rows和columns来设置行和列的数量</p><p>GridSpitter:分割窗口，例如windows管理器，左侧是文件夹，右侧是文件，可拖动分割条调整窗口大小。vertialAlignment&#x3D;center为竖直分割，HorizontalAlignment&#x3D;center为水平分割。grddSpitter必须放在Grid里面，最好放在具体的行或者列里面，宽度或者高度设置为auto</p><p>Progressbar进度条如何根据比例显示？先设置最大值，然后设计进度值即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ProgressBar Height=&quot;10&quot; Value=&quot;19.88&quot; Maximum=&quot;40&quot; Foreground=&quot;Black&quot; &gt;&lt;/ProgressBar&gt;</span><br></pre></td></tr></table></figure><p><strong>标签格式</strong></p><p>单标签格式。 。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;markName /&gt;</span><br></pre></td></tr></table></figure><p>双标签格式。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;markName&gt; 【可嵌⼊其他的标签】 &lt;/markName&gt;</span><br></pre></td></tr></table></figure><h4 id="App-xmal代码解释"><a href="#App-xmal代码解释" class="headerlink" title="App.xmal代码解释"></a>App.xmal代码解释</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window x:Class=&quot;WpfHelloworld.MainWindow&quot;</span><br><span class="line">//此 URI 只是由 Microsoft.Maui NuGet 包中的程序集定义的一个或多个命名空间的别名，</span><br><span class="line">        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        xmlns:local=&quot;clr-namespace:WpfHelloworld&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot;</span><br><span class="line">        Title=&quot;MainWindow&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt;</span><br><span class="line">    &lt;Grid&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;/Grid&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>解释上述代码</p><p>1.window表示windows对象，来源于默认的命名空间，grid同理，xaml语言每看见一个标签就创建一个对象。</p><p> 2.xmlns&#x3D;”<a href="http://schemas.microsoft.com/winfx/2006/xaml/presentation%22%E8%A1%A8%E7%A4%BA%E5%BC%95%E5%85%A5%E4%B8%80%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%B5%B7%E5%90%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%AE%80%E5%8C%96%E5%86%99%E6%B3%95%EF%BC%8C%E5%9B%A0%E4%B8%BAwindow%EF%BC%8Cgrid%E7%AD%89%E8%BF%99%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%9D%87%E6%9D%A5%E6%BA%90%E4%BA%8E%E5%AE%83%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B5%B7%E5%90%8D%E5%AD%97%EF%BC%8C%E5%88%99%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%89%8D%E9%9D%A2%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E2%80%9Cy:%E2%80%9D%E7%9A%84%E5%BD%A2%E5%BC%8F%EF%BC%8C%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6%E3%80%82%E4%BD%86%E6%98%AF%E4%B8%80%E4%B8%AAxaml%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BB%85%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%90%8D%E7%A7%B0%E7%9A%84%E5%86%99%E6%B3%95">http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;表示引入一个命名空间，没有起名的原因是可以简化写法，因为window，grid等这些对象均来源于它，如果起名字，则每个对象前面需要使用“y:”的形式，比较麻烦。但是一个xaml文件中仅能有一个默认名称的写法</a></p><p>3.xmlns:x&#x3D;”<a href="http://schemas.microsoft.com/winfx/2006/xaml">http://schemas.microsoft.com/winfx/2006/xaml</a>“ 引入xaml命名控件，并命名为x</p><p><strong>4.x:Class</strong>&#x3D;”WpfHelloworld.MainWindow表示xaml生成的代码要与后台的c#代码进行合并。</p><p>xmal语言写的代码代码会生成一个类，后台c#代码也会有一个类，两者代码会进行合并，所以后台的c#使用partial修饰，表示两者生成之后会自动合并到一个类里边，就是mainwindow类，若前后台名称不一样，则会生成两个类，两者之间没有关系。</p><p><strong>x:classModifier</strong>;访问级别，前台的访问级别必须与后台的访问级别相同。</p><p><strong>x:name</strong>;为控件起一个名字。如果是wpf中的自有的控件，则使用x:name和使用name是完全一样的，如果是是后台的实体类被引入xaml中，则其没有Name属性，但一定有必x:name的形式。所以为了方便，所有控件都直接使用x:Name访问。Name是只针对某个控件的，x:name是针对于整个xmal文件的。</p><p>**x:Key：**用在xaml Resources，ResourceDictionary需要key来访问</p><p><strong>背景色border</strong>：对于控件中的背景色直接使用background属性即可，但是对于区域中的背景色(因为他不是控件)，需单独使用border控件来添加，实际上它是一个添加边框的控件，默认是填充所有区域（可以设置边框宽度），如果区域里面有其他控件，就填充除空间外的其他区域</p><p><strong>5.MVVM</strong>：就是将mvc中的C变成了VM，他与View是一一对应的关系。<font color="red">这个一般用于大型企业项目中。对于比较小的程序可以不使用MVVM。</font></p><p><strong>不使用mvvm</strong>，则如下格式：事件直接写在控件里面。<font color="red">优点是简单，缺点就是如果前端改变，则后端代码需要改变，维护比较麻烦。</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前端</span><br><span class="line">&lt;Button x:Name=&quot;bt1&quot; Grid.Row=&quot;3&quot;  Content=&quot;addclick&quot; Width=&quot;200&quot; Height=&quot;100&quot; Click=&quot;bt1_Click&quot;&gt;&lt;/Button&gt;</span><br><span class="line">后台</span><br><span class="line"> private void bt1_Click(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            double d1 = Double.Parse(tb0.Text);//引用了前台的变量名，所以前台和后台的代码耦合性比较严重</span><br><span class="line">            double d2 = Double.Parse(tb1.Text);</span><br><span class="line">            double result = d1 + d2;</span><br><span class="line">            tb2.Text = result.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="行为："><a href="#行为：" class="headerlink" title="行为："></a>行为：</h4><p>也类似于第三方包，针对于前端一些用户操作的代码，例如，允许拖动，缩放，停靠等界面特性，它的代码逻辑非常麻烦，而且都是重复性工作，但是这都是一些<font color="red">通用</font>功能 ,如果每个用到的地方去使用后台代码实现则会非常麻烦，此时行为大展拳脚，我们只需要在后台代码写好一次，然后在前端需要的地方直接拿来用即可。甚至已经提供了一些写好的方法，例如拖动，缩放，甚至不用写后台代码，它是依赖属性。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;i:interaction.triggers&gt;</span><br><span class="line">&lt;i:MouseDragElementBehavior/&gt;//这是自带的功能，就是因为行为具有通用性，所以可以对任何控件使用</span><br><span class="line">&lt;/i:interaction.triggers&gt;</span><br></pre></td></tr></table></figure><p>如果自定义一些行为，参考如下。</p><p><a href="https://blog.csdn.net/weixin_30537451/article/details/97989655">https://blog.csdn.net/weixin_30537451/article/details/97989655</a></p><h4 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h4><p>可以将源数据和目标数据之间进行特定的转化，例如在viewmodel中使用0代表男，1代表女，那么前端在绑定到该属性的时候，仍然是0和1，此时需要使用转换器将0转换为男，实际上就是定义了一种规则，实现毫无关联的数据之间一一对应，当然也可以在View model中通过方法实现，但是前端的标签不一定能够通过事件触发去调用命令，此时就体现了转换器的作用，即在用户不进行操作的情况下完成数据之间转换。使用方法参考<a href="https://www.cnblogs.com/zh7791/p/9311332.html">https://www.cnblogs.com/zh7791/p/9311332.html</a></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h4 id="底层逻辑"><a href="#底层逻辑" class="headerlink" title="底层逻辑"></a>底层逻辑</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每个xaml文件对应一个viewmodel，然后变化的地方写成属性，将执行的逻辑写成方法。</span><br><span class="line">1.（控制属性）在viewmodel文件夹中写一个基类NotificationObject继承INotifiaction，用来连接前端和后端的桥梁，一旦后端属性值改变，则绑定到前端的值也会发生改变。使用委托的好处是与前端进行交互的时候可以通过委托的参数传递任何方法。在属性的set方法中将该属性作为参数传递给NotificationObject中的委托。</span><br><span class="line">2.（控制方法）创建DelegateCommand接口并实现Icommand中对应的方法，也相当于一个基类，用来决定控件是否可执行，以及执行哪个方法。所有的方法的合集称为command，就相当于webapi中所有方法称为action。在viewmodel的构造函数中将该方法传递给DelegateCommand中的委托。</span><br><span class="line">3.在mainwindow里面将viewmodel与datacontext进行关联。</span><br><span class="line">4.在xaml文件中使用Text=&quot;binding Input &quot;进行属性绑定,使用Command = &quot;binding AddCommand&quot;进行方法绑定</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不使用底层逻辑，使用mvvm框架，微软官方mvvm：Toolkit.Mvvm，导包CommunityToolkit.Mvvm，</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><img src="/2026/01/29/Maui/assets/image-20221112182415112.png" alt="image-20221112182415112"></p><h4 id="mvvm框架使用"><a href="#mvvm框架使用" class="headerlink" title="mvvm框架使用"></a>mvvm框架使用</h4><p>toolkitmvvm，prism（该框架应用大大型企业级项目，比较中，但是功能最全）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">1.写viewmodel</span><br><span class="line">public class MainPageViewModel :ObservableObject//这是toolkit中的类,prism中是binadable</span><br><span class="line">    &#123;</span><br><span class="line">private string _result;</span><br><span class="line"></span><br><span class="line">public string Result属性</span><br><span class="line">&#123;</span><br><span class="line">get &#123; return _result; &#125;</span><br><span class="line">set &#123; SetProperty(ref _result, value, nameof(Result)); &#125;//相当于mvvmlight中的set()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private RelayCommand _helloCommmand;</span><br><span class="line"> public RelayCommand IncrementAgeCommand &#123; get; &#125;</span><br><span class="line"> private void IncrementAge() =&gt; Age++;</span><br><span class="line">        public MainPageViewModel()构造方法进行方法传递，如果需要传递参数，则使用泛型，泛型里面的参数类型代表前端的参数</span><br><span class="line">       &#123;</span><br><span class="line">      IncrementAgeCommand = new RelayCommand(IncrementAge);</span><br><span class="line">      public RelayCommand HelloCommand =&gt; _helloCommmand??new RelayCommand(()=&gt;Result= &quot;helloworld&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.创建locator注册viewmodel，以方便在app.xaml中调用，如果使用微软的IOc，则不必写这里</span><br><span class="line">public class ViewModelLocator</span><br><span class="line">    &#123;</span><br><span class="line">    //构造注入，这里是手动创建，如果使用自带Ioc，则不用写，而是直接addsingleton即可</span><br><span class="line">        public static  IServiceProvider ServiceProvide &#123; get; set; &#125;</span><br><span class="line">        public ViewModelLocator()</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceProvide = GetService();</span><br><span class="line">        &#125;</span><br><span class="line">        private IServiceProvider GetService()</span><br><span class="line">        &#123;</span><br><span class="line">            var service = new ServiceCollection();</span><br><span class="line">            service.AddSingleton&lt;MainPageViewModel&gt;();</span><br><span class="line">            return service.BuildServiceProvider();</span><br><span class="line">        &#125;</span><br><span class="line">        //获取viewmodel实例</span><br><span class="line">        public MainPageViewModel MainPageViewModel</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return ServiceProvide.GetService(TypeOf(MainPageViewModel));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">3.在appxaml中引入 xmlns:vm =&quot;clr-namespace:MVVM.ViewModels;assembly=MVVM&quot;</span><br><span class="line">并在&lt;Application.Resources&gt;</span><br><span class="line">        &lt;vm:ViewModelLocator x:Key=&quot;viewmodellocator&quot;/&gt;x:key用来定义文件资源</span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">4.在对应的xaml文件中绑定viewmodle，BindingContext=&quot;&#123;Binding MainPageViewModel,Source=&#123;StaticResource viewmodellocator&#125;&#125;&quot;;view先去找appxaml中的viewlocator，再找MainPageViewModel</span><br><span class="line">并手动绑定&lt;Label Text=&quot;&#123;Binding Result&#125;&quot;</span><br><span class="line">               FontSize=&quot;48&quot;/&gt;</span><br><span class="line">        &lt;Button Text=&quot;click me&quot;</span><br><span class="line">                Command=&quot;&#123;Binding HelloCommand&#125;&quot;/&gt;</span><br><span class="line">                </span><br><span class="line">整个思路如上图所示：view想要访问viewmodel，但是需要通过app.xaml定位到viewmodellocator，再通过viewmodelloactor找到viewmodel，（注可以不使用viewmodellocator而是直接在mainwindow里面同通过contextdata= new mainpageviewmodel进行绑定，推荐不使用locator，太麻烦）</span><br><span class="line"></span><br><span class="line">toolkit中对含有参数的方法进行mvvm</span><br><span class="line">如下navigate方法，形参为MenuBar类型。</span><br><span class="line">private void Navigate(MenuBar obj)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         public DelegateCommand&lt;MenuBar&gt; NavigateCommand &#123; get; private set; &#125;将该方法的形参作为委托的泛型传递。</span><br><span class="line">在viewmodel的构造方法中通过如下代码绑定</span><br><span class="line">NavigateCommand = new DelegateCommand&lt;MenuBar&gt;(Navigate);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Prism框架："><a href="#Prism框架：" class="headerlink" title="Prism框架："></a>Prism框架：</h2><p>官方文档prism unity(不推荐)：(<a href="https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff921153(v=pandp.40)">https://learn.microsoft.com/en-us/previous-versions/msp-n-p/ff921153(v=pandp.40)</a>)</p><p>推荐(<a href="https://www.cnblogs.com/nickyangmiracle/p/16169069.html)%EF%BC%88dryioc%EF%BC%89%E5%92%8C">https://www.cnblogs.com/nickyangmiracle/p/16169069.html)（dryioc）和</a></p><p><a href="https://dotnet9.com/2023/06/Data-Binding-for-the-Prism-Series-of-the-dotNETCore-3-WPF-MVVM-Framework%EF%BC%88unity%EF%BC%89">https://dotnet9.com/2023/06/Data-Binding-for-the-Prism-Series-of-the-dotNETCore-3-WPF-MVVM-Framework（unity）</a></p><h4 id="prism具体使用"><a href="#prism具体使用" class="headerlink" title="prism具体使用"></a>prism具体使用</h4><p>1.引入prism.dryIoc（推荐）,或者prism.unity,前者轻量级，后者支持生命周期管理和其他高级功能</p><p>2.将app继承的Application修改为PrismApplication</p><p><img src="/2026/01/29/Maui/assets/image-20260203172425084.png" alt="image-20260203172425084"></p><p>3.app.xaml文件中引入xmlns:prism &#x3D;”<a href="http://prismlibrary.com/">http://prismlibrary.com/</a>“</p><p>4.将app.xaml中Applicatio修改为prism:PrismApplication,删除startupUrl路径（否则启动两个windows窗口），结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;prism:PrismApplication x:Class=&quot;WpfPrism.App&quot;</span><br><span class="line">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:local=&quot;clr-namespace:WpfPrism&quot;</span><br><span class="line">             xmlns:prism=&quot;http://prismlibrary.com/&quot;</span><br><span class="line">             &gt;</span><br><span class="line">     //注意，这里不要修改成prismApplication</span><br><span class="line">    &lt;Application.Resources /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/prism:PrismApplication&gt;</span><br></pre></td></tr></table></figure><p>5.实现PrismApplication中的抽象方法（先运行程序报一下错，否则无法重写如下方法）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">App.Xaml.cs</span><br><span class="line">//默认呈现的首页</span><br><span class="line">     protected override Window CreateShell()</span><br><span class="line">     &#123;</span><br><span class="line">     该方法是获取泛型里面的实例，该实例未在App中注册过，可以为接口</span><br><span class="line">         return Container.Resolve&lt;MainWindow&gt;();</span><br><span class="line">     &#125;</span><br><span class="line">     //用来注册各个实体类，类似于program.cs中的IOc</span><br><span class="line">     protected override void RegisterTypes(IContainerRegistry containerRegistry)</span><br><span class="line">     &#123;</span><br><span class="line">         containerRegistry.RegisterSingleton&lt;IMessageService, MessageService&gt;();</span><br><span class="line">     &#125;</span><br><span class="line">     //用来引入各个模块</span><br><span class="line">     protected override void ConfigureModuleCatalog(IModuleCatalog moduleCatalog)</span><br><span class="line">     &#123;</span><br><span class="line">         moduleCatalog.AddModule&lt;ModuleNameModule&gt;();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>6.以上需要手动更改配置代码，点击拓展，管理扩展里面搜索prism template pack安装插件后重新创建prism full 即可自动更改以上配置。在xaml里面配置</p><p>7.在mainView.xaml加上配置　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlns:prism=&quot;http://prismlibrary.com/&quot; </span><br><span class="line">prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;(注意，MainView必须在Views文件夹下，MainViewModel必须在ViewModels文件夹下，否则无法绑定)</span><br></pre></td></tr></table></figure><p>会自动绑定View和ViewModel之间的关系。第二种绑定方法在RegisterTypes方法中使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerRegistry.RegisterForNavigation&lt;ViewA,ViewAViewModel&gt;()的方式去显示注册。</span><br></pre></td></tr></table></figure><p>但是对于Service与Repository等关系仍然需要使用RegisterTypes的方式去注册。</p><p>8.mainwindow.xaml中添加ContentControl区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">    &lt;ContentControl prism:RegionManager.RegionName=&quot;ContentRegion&quot;/&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure><p>9.在WindowsViewModel中进行内容区与对应的View相关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MainWindowViewModel:BindableBase</span><br><span class="line">&#123;</span><br><span class="line">    IRegionManager _regionManager;</span><br><span class="line">    public MainWindowViewModel(IRegionManager regionManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _regionManager=regionManager;</span><br><span class="line">        //向ContentRegion导入ViewA</span><br><span class="line">        _regionManager.RegisterViewWithRegion(&quot;ContentRegion&quot;, typeof(ViewA));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.哪些控件可以放置其他View呢？如下所示，ContentControl，ItemsControl,SelectorRegion,Combobox,ListBox,Ribbon,TabControl;（实现区域适配器的控件）</p><p><img src="/2026/01/29/Maui/assets/image-20260203212928575.png" alt="image-20260203212928575"></p><h4 id="prism基础"><a href="#prism基础" class="headerlink" title="prism基础"></a>prism基础</h4><p>1.Region区域（相当于ViewModel）：模板分为如下三个区域，所有的区域操作都是通过RegionManager进行操作，其中Header区放toolbar，menu区放listbox，content区放ContentControl。定义成区域的原因是点击MenuRegion中的导航栏部分，ContentRegion部分会发生内容改变，通过RegionManager进行管理此区域内容，如果传统方式则，则页面的内容是固定的。<font color="red">可使用RegionManager可以动态添加容器。进行该区域的内容管理</font></p><p><img src="/2026/01/29/Maui/assets/image-20230203210142259.png" alt="image-20230203210142259"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//ContentControl区域起个名字叫ContentRegion，通过RegionManager.RegionName这个类进行管理,相当于定义区域，在mainwindows.xaml中</span><br><span class="line">&lt;ContentControl Grid.row=&quot;1&quot; prism:RegionManager.RegionName=&quot;ContentRegion&quot; /&gt;ContentControl</span><br><span class="line"></span><br><span class="line">在对应的mainwindow.viewmodel中</span><br><span class="line">后台访问：</span><br><span class="line"></span><br><span class="line">RegionManager.Regions[&quot;ContentRegion&quot;]；对区域进行访问</span><br></pre></td></tr></table></figure><p>2.Module模块（就是由多个项目构成，适用于大项目，不推荐使用）</p><p><img src="/2026/01/29/Maui/assets/image-20260203213530543.png" alt="image-20260203213530543"></p><p><img src="/2026/01/29/Maui/assets/image-20260203213810333.png" alt="image-20260203213810333"></p><p>每个模块只为实现一个局部功能，可能对应多个页面，每个模块的功能不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ModuleNameModule : IModule//实现IModule的类就是一个模块</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IRegionManager _regionManager;</span><br><span class="line"></span><br><span class="line">        public ModuleNameModule(IRegionManager regionManager)</span><br><span class="line">        &#123;</span><br><span class="line">        //构造方法注入regionMananger</span><br><span class="line">            _regionManager = regionManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void OnInitialized(IContainerProvider containerProvider)</span><br><span class="line">        &#123;//此方法会将ViewA的内容添加到ContentRegion区域</span><br><span class="line">            _regionManager.RequestNavigate(RegionNames.ContentRegion, &quot;ViewA&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void RegisterTypes(IContainerRegistry containerRegistry)</span><br><span class="line">        &#123;</span><br><span class="line">        //注册导航，为每个视图窗口创建一个自己的名字，以提供给regionmanager进行使用，不加参数默认名字为类名</span><br><span class="line">            containerRegistry.RegisterForNavigation&lt;ViewA&gt;();//每个模块有自己的View，每个都是在该方法中注册</span><br><span class="line">            containerRegistry.RegisterForNavigation&lt;ViewA,ViewAViewModel&gt;();构建viewmodel与view之间的关系如果在mainView里面引入了prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot;则不必显示注册上述View和ViewModel之间的关系(不推荐使用，推荐手动注册)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">那么，总程序如何构建每个模块之间的关系呢？</span><br><span class="line"> 在总项目文件的App.xaml.cs里面有如下方法，该方法就是用来引入所有模块</span><br><span class="line"> protected override void ConfigureModuleCatalog(IModuleCatalog moduleCatalog)</span><br><span class="line">        &#123;</span><br><span class="line">            moduleCatalog.AddModule&lt;ModuleNameModule&gt;();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="Prism导航"><a href="#Prism导航" class="headerlink" title="Prism导航"></a>Prism导航</h4><p>实现点击菜单按钮在内容区导航到对应的View</p><p>（1）建立ViewA和ViewB</p><p>（2）在app.xaml.cs中注册导航视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected override void RegisterTypes(IContainerRegistry containerRegistry)</span><br><span class="line">&#123;</span><br><span class="line">    //注册导航，并可以给ViewA起个别名</span><br><span class="line">    containerRegistry.RegisterForNavigation&lt;ViewA&gt;(&quot;PageA&quot;);</span><br><span class="line">    containerRegistry.RegisterForNavigation&lt;ViewB&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> （3） 在view中绑定后点击按钮实现导航</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">    &lt;Button Command=&quot;&#123;Binding OpenACommand&#125;&quot;&gt;打开A&lt;/Button&gt;</span><br><span class="line">    &lt;ContentControl prism:RegionManager.RegionName=&quot;ContentRegion&quot;/&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在viewmodel中</span><br><span class="line">public void OpenA()</span><br><span class="line">&#123;</span><br><span class="line">    _regionManager.RequestNavigate(&quot;ContentRegion&quot;, &quot;PageA&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）导航中传递参数（ViewModel之间传递参数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">发送端直接添加参数即可即可</span><br><span class="line">public void OpenA()</span><br><span class="line">&#123;</span><br><span class="line">   NavigationParameters param = new NavigationParameters();</span><br><span class="line">   param.Add(&quot;Value&quot;,&quot;Hello&quot;);</span><br><span class="line">   _regionManager.RequestNavigate(&quot;ContentRegion&quot;, &quot;PageA&quot;,param);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//True则重用该View实例，Flase则每一次导航到该页面都会实例化一次</span><br><span class="line"> public bool IsNavigationTarget(NavigationContext navigationContext)</span><br><span class="line"> &#123;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //导航离开当前页时触发</span><br><span class="line"> public void OnNavigatedFrom(NavigationContext navigationContext)</span><br><span class="line"> &#123;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //导航到达当前页时触发</span><br><span class="line"> public void OnNavigatedTo(NavigationContext navigationContext)</span><br><span class="line"> &#123;</span><br><span class="line">     //接收发送端传递过来的参数</span><br><span class="line">     Title = navigationContext.Parameters.GetValue&lt;string&gt;(&quot;Value&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> (5)Prism确认导航信息框</p><p>作用是在页面 导航发生前，弹出确认框让用户决定是否继续导航，并将用户的选择通过回调函数传递出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ViewAViewModel实现IConfirmNavigationRequest接口及其方法</span><br><span class="line">// 参数1：navigationContext - 导航上下文，包含导航的目标、参数等信息</span><br><span class="line">// 参数2：continuationCallback - 回调函数，接收一个bool类型参数，用于返回导航确认结果</span><br><span class="line">//当从当前ViewA即将跳转到ViewB时调用该方法。</span><br><span class="line">public void ConfirmNavigationRequest(NavigationContext navigationContext, Action&lt;bool&gt; continuationCallback)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化导航结果为true（默认允许导航）</span><br><span class="line">    bool result = true;</span><br><span class="line">    </span><br><span class="line">    // 弹出消息框：标题&quot;温馨提示&quot;，内容&quot;确认导航&quot;，按钮为&quot;是/否&quot;</span><br><span class="line">    // 如果用户点击&quot;否&quot;（MessageBoxResult.No），则将结果设为false（禁止导航）</span><br><span class="line">    if (MessageBox.Show(&quot;确认导航&quot;,&quot;温馨提示&quot;,MessageBoxButton.YesNo)==MessageBoxResult.No)</span><br><span class="line">        result = false;</span><br><span class="line"></span><br><span class="line">    // 调用回调函数，将最终的导航确认结果（true/false）传递出去</span><br><span class="line">    continuationCallback(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.Dialog对话</p><p>传统弹出对话框：new ViewA().showDialog();这样耦合比较大，也不美观，为了避免耦合，zi定义对话窗口，并使用Prism实现，相当于开启两个窗口</p><p>8.实现导航期间操作</p><p>比如两个页面跳转的时候需要进行操作，例如保存数据，加载旋转动画等就是使用该操作。</p><p><a href="http://hk.javashuo.com/article/p-sjofzxza-cn.html">http://hk.javashuo.com/article/p-sjofzxza-cn.html</a></p><p><a href="https://blog.csdn.net/weixin_30522183/article/details/98070785">https://blog.csdn.net/weixin_30522183/article/details/98070785</a></p><h4 id="事件聚合器"><a href="#事件聚合器" class="headerlink" title="事件聚合器"></a>事件聚合器</h4><p>在<a href="https://zhida.zhihu.com/search?content_id=241035033&content_type=Article&match_order=1&q=WPF+Prism&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzAzMDUzMzcsInEiOiJXUEYgUHJpc20iLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyNDEwMzUwMzMsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.CfESSla3r5nhb_5i0EG7Fli_YUGeitIsBb1hO9UE-nM&zhida_source=entity">WPF Prism</a>中事件聚合器(Event Aggregator)是一种实现组件间松耦合通信的模式.这种模式允许不同的组件(例如View,Service之间)订阅和发布事件,而不需要知道事件的发布者和订阅者是谁,从而减少组件间的依赖关系.例如一个View发布广播，其他所有订阅了该广播的View收到通知后做出相应反应。</p><p>它与导航之间的区别：</p><p><img src="/2026/01/29/Maui/assets/image-20260204000402356.png" alt="image-20260204000402356"></p><p><strong>导航传递参数举例：<strong>从 A 页面</strong>跳转</strong>到 B 页面，需要给 B 页面传递初始化参数（比如 “编辑用户” 场景，跳转时传递用户 ID）。</p><p><strong>事件聚合器传递参数举例</strong>：</p><p>A 页面操作后（比如点击按钮、数据更新），需要通知 B&#x2F;C&#x2F;D 等多个页面更新状态，<strong>无需跳转</strong>（比如 “刷新列表”“显示提示消息”）（无形之中传递消息）</p><p>事件聚合器本质是一个<strong>中心化的消息中介</strong>：</p><ul><li>发布者（Publisher）：只需向聚合器发布事件 &#x2F; 消息，无需知道谁在接收；</li><li>订阅者（Subscriber）：只需向聚合器订阅感兴趣的事件，无需知道谁在发布；</li><li>核心价值：彻底解耦发布者和订阅者，避免组件间硬引用，降低维护成本。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/688070958">Prism框架核心内容三(事件聚合器) - 知乎</a></p><p><a href="https://cloud.tencent.com/developer/article/2444119">WPF开发者必须掌握的技巧：使用事件聚合器实现跨页面通信（任意页面哦！）-腾讯云开发者社区-腾讯云</a></p><p>（1）首先创建自定义事件类（继承 Prism 的<code>PubSubEvent&lt;T&gt;</code>，T 是传递的消息类型）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1. 无参数事件</span><br><span class="line">public class SimpleMessageEvent : PubSubEvent &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 2. 带参数事件（推荐，可传递自定义数据）</span><br><span class="line">public class UserInfoEvent : PubSubEvent&lt;UserInfo&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 自定义消息实体（示例）</span><br><span class="line">public class UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">（2）. 注入事件聚合器，只需在 ViewModel/View 的构造函数中注入</span><br><span class="line">// 发布者ViewModel</span><br><span class="line">public class PublisherViewModel : BindableBase</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IEventAggregator _eventAggregator;</span><br><span class="line"></span><br><span class="line">    // 构造函数注入IEventAggregator</span><br><span class="line">    public PublisherViewModel(IEventAggregator eventAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        _eventAggregator = eventAggregator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 发布事件的方法（比如绑定到按钮点击命令）</span><br><span class="line">    public void PublishMessage()</span><br><span class="line">    &#123;</span><br><span class="line">        // 发布无参数事件</span><br><span class="line">        _eventAggregator.GetEvent&lt;SimpleMessageEvent&gt;().Publish();</span><br><span class="line"></span><br><span class="line">        // 发布带参数事件</span><br><span class="line">        var userInfo = new UserInfo &#123; Name = &quot;张三&quot;, Age = 25 &#125;;</span><br><span class="line">        _eventAggregator.GetEvent&lt;UserInfoEvent&gt;().Publish(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 订阅者ViewModel</span><br><span class="line">public class SubscriberViewModel : BindableBase</span><br><span class="line">&#123;</span><br><span class="line">    private string _message;</span><br><span class="line">    private UserInfo _currentUser;</span><br><span class="line"></span><br><span class="line">    public string Message</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _message;</span><br><span class="line">        set =&gt; SetProperty(ref _message, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UserInfo CurrentUser</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _currentUser;</span><br><span class="line">        set =&gt; SetProperty(ref _currentUser, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SubscriberViewModel(IEventAggregator eventAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        // 订阅无参数事件</span><br><span class="line">        eventAggregator.GetEvent&lt;SimpleMessageEvent&gt;()</span><br><span class="line">            .Subscribe(OnSimpleMessageReceived); // 订阅回调</span><br><span class="line"></span><br><span class="line">        // 订阅带参数事件（可配置线程、是否保持订阅等）</span><br><span class="line">        eventAggregator.GetEvent&lt;UserInfoEvent&gt;()</span><br><span class="line">            .Subscribe(OnUserInfoReceived, </span><br><span class="line">                       ThreadOption.UIThread, // 指定在UI线程执行回调（WPF必须）</span><br><span class="line">                       keepSubscriberReferenceAlive: true); // 保持订阅（默认false，弱引用）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 无参数事件回调</span><br><span class="line">    private void OnSimpleMessageReceived()</span><br><span class="line">    &#123;</span><br><span class="line">        Message = &quot;收到无参数消息：按钮被点击了！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 带参数事件回调</span><br><span class="line">    private void OnUserInfoReceived(UserInfo userInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        CurrentUser = userInfo;</span><br><span class="line">        Message = $&quot;收到用户信息：&#123;userInfo.Name&#125;，&#123;userInfo.Age&#125;岁&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected override void RegisterTypes(IContainerRegistry containerRegistry)</span><br><span class="line">   &#123;</span><br><span class="line">       // 注册ViewModel（Prism会自动注入IEventAggregator）</span><br><span class="line">       containerRegistry.RegisterViewModelForNavigation&lt;PublisherViewModel&gt;();</span><br><span class="line">       containerRegistry.RegisterViewModelForNavigation&lt;SubscriberViewModel&gt;();</span><br></pre></td></tr></table></figure><h4 id="Prism对话框："><a href="#Prism对话框：" class="headerlink" title="Prism对话框："></a>Prism对话框：</h4><p>可以使用Prism实现一个窗体作为对话框弹出。（Prism版本需更换为低于9版本）</p><p><a href="https://www.cnblogs.com/chonglu/p/15159387.html">Prism之对话服务(DialogService) - 傲慢与偏见luc - 博客园</a></p><p>（1）创建一个类实现IDialogAware接口，并实现对应方法（（Prism版本需更换为低于9版本，否则不弹出消息框）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MsgViewModel : IDialogAware</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CanCloseDialog()函数是决定窗体是否关闭</span><br><span class="line">OnDialogClosed()函数是窗体关闭时触发，触发条件取决于 CanCloseDialog()函数，当确定后会被触发，可以在这里将对话框上的内容通过这里传递回去</span><br><span class="line">OnDialogOpened()函数时窗体打开时触发，比窗体 Loaded 事件早触发</span><br><span class="line">Title 为窗体的标题</span><br><span class="line">RequestClose 为关闭事件，可由此控制窗体的关闭</span><br></pre></td></tr></table></figure><p>（2）建立MsgView，必须在app.xaml.cs中使用下列方式进行关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerRegistry.RegisterDialog&lt;MsgView,MsgViewModel&gt;();</span><br></pre></td></tr></table></figure><p>（3）调用端构造注入IDialogService并打开窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> //打开对话框</span><br><span class="line">public void OpenDialog()</span><br><span class="line">&#123;</span><br><span class="line">      //传递参数</span><br><span class="line">    DialogParameters paris = new DialogParameters();</span><br><span class="line">    paris.Add(&quot;Title&quot;, &quot;This is a dialog&quot;);</span><br><span class="line">    //打开msgview,callback中写如果用户返回确定之后应该如何进行处理</span><br><span class="line">    _dialogService.ShowDialog(nameof(MsgView), paris, callback =&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）msgViewmodel中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void OnDialogOpened(IDialogParameters parameters)</span><br><span class="line"> &#123;</span><br><span class="line"> //接收参数</span><br><span class="line">     Title = parameters.GetValue&lt;string&gt;(&quot;Title&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="导航日志"><a href="#导航日志" class="headerlink" title="导航日志"></a>导航日志</h4><p>可以实现上一步，下一步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">（1） 定义属性IRegionNavigationJournal _journal;</span><br><span class="line">（2）在导航过程中使用回调函数对_journal进行初始化</span><br><span class="line">    public void OpenB()</span><br><span class="line">    &#123;</span><br><span class="line">        _regionManager.RequestNavigate(&quot;ContentRegion&quot;, &quot;ViewB&quot;, arg =&gt; &#123; </span><br><span class="line">         _journal = arg.Context.NavigationService.Journal;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> （3）执行导航日志</span><br><span class="line">   //向前导航</span><br><span class="line">  public void GoForward()</span><br><span class="line">  &#123;</span><br><span class="line">      if (_journal!=null &amp;&amp; _journal.CanGoForward)</span><br><span class="line">      &#123;</span><br><span class="line">          _journal.GoForward();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //向后导航</span><br><span class="line">  public void GoBack()</span><br><span class="line">  &#123;</span><br><span class="line">      if (_journal!=null &amp;&amp; _journal.CanGoBack)</span><br><span class="line">      &#123;</span><br><span class="line">          _journal.GoBack();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>加上Iservice时候进行改造</p><p><img src="/2026/01/29/Maui/assets/image-20221113112544573.png" alt="image-20221113112544573"></p><h2 id="wpf布局容器："><a href="#wpf布局容器：" class="headerlink" title="wpf布局容器："></a>wpf布局容器：</h2><p><a href="https://www.cnblogs.com/zh7791/p/9012880.html">https://www.cnblogs.com/zh7791/p/9012880.html</a></p><p><img src="/2026/01/29/Maui/assets/image-20221118162824500.png" alt="image-20221118162824500"></p><h4 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h4><p><img src="/2026/01/29/Maui/assets/image-20221118170453091.png" alt="image-20221118170453091"></p><p>1.样式可以直接写在控件属性里面，例如button1，2。也可以使用类似css例如button3，这样可以避免 </p><p>2.样式定义在window.Resource里面，style标签中，使用x：key区分样式名称，targettype用来说明该样式应用于什么类型的控件</p><p>3.在setter控件里面使用键值的方式设置具体的样式，样式可以使用baseOn进行继承</p><p>4.button控件中使用Style&#x3D;”{StaticResource 样式名}进行引用</p><p>5.如果在控件里面直接使用属性赋值和引用样式赋值，优先使用前者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">        &lt;Style x:Key=&quot;baseStyle&quot; TargetType=&quot;Button&quot;&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Height&quot; Value=&quot;40&quot;/&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">        &lt;Style x:Key=&quot;buttonStyle&quot; TargetType=&quot;Button&quot; BasedOn=&quot;&#123;StaticResource baseStyle&#125;&quot;&gt;    继承上面的样式</span><br><span class="line">            &lt;Setter Property=&quot;FontSize&quot; Value=&quot;15&quot;/&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Red&quot;/&gt;</span><br><span class="line">            &lt;Setter Property=&quot;Width&quot;  Value=&quot;100&quot;/&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;Button FontSize=&quot;20&quot; Width=&quot;80&quot; Height=&quot;40&quot; Content=&quot;button1&quot;/&gt;</span><br><span class="line">        &lt;Button FontSize=&quot;20&quot; Width=&quot;80&quot; Height=&quot;40&quot; Content=&quot;button1&quot;/&gt;</span><br><span class="line">        &lt;Button Style=&quot;&#123;StaticResource buttonStyle&#125;&quot; Content=&quot;button1&quot;/&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br></pre></td></tr></table></figure><p><strong>属性元素</strong>：</p><p>对于一些属性可以以元素的方式进行展现：以background为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button backGround=&quot;red&quot;/&gt;这是传统方式，他与</span><br><span class="line">&lt;Button&gt;</span><br><span class="line">&lt;Button.Background&gt;</span><br><span class="line">&lt;SolidBrush color=&quot;red&quot;/&gt;</span><br><span class="line">&lt;/Button.Background&gt;</span><br><span class="line">&lt;/Button&gt;是等价的，即将属性可以用作标签的形式展现，好处是后者可以设置一些复杂的情况，例如为Button设置背景为图片就无法使用第一种方式了。注意：所有的属性都可以使用属性元素语法</span><br></pre></td></tr></table></figure><h4 id="样式触发器"><a href="#样式触发器" class="headerlink" title="样式触发器"></a>样式触发器</h4><p>1.triggers 属性触发器，属性满足某个值的时候就会触发</p><p>2.multiTrigger多条件触发器</p><p>3.DataTrigger数据触发器：数据满足某个值时，就会触发</p><p>4.EventTrigger：事件触发，它触发之后是用来对样式进行操作的，如下（参考wpf2012动画部分）</p><p>5.i:interactions.trigger:交互触发器,是一种附加属性，什么时候使用呢？当WPFmvvm模式下某个控件：好比如Button的点击事件，在<a href="https://so.csdn.net/so/search?q=mvvm&spm=1001.2101.3001.7020">mvvm</a>模式下Button的点击事件有时候是不可以直接使用Command进行绑定的(比如Button按钮被放在了ListBox或者ItemsControl的dataTemplate里面,或者想要对grid添加command事件)，这时候这中特殊手段就对mvvm模式非常有用,<a href="https://blog.csdn.net/qq_44558009/article/details/117586373%EF%BC%8C%E4%BA%A4%E4%BA%92%E8%A7%A6%E5%8F%91%E5%99%A8%E4%B8%8E%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%EF%BC%8C%E5%89%8D%E8%80%85%E7%94%A8%E4%BA%8Examl%E4%B8%8Eviewmodel%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%EF%BC%8C%E8%80%8C%E5%90%8E%E8%80%85%E4%BB%85%E7%94%A8%E4%BA%8E%E5%89%8D%E7%AB%AFxaml%E9%83%A8%E5%88%86%E7%9A%84%E4%BA%A4%E4%BA%92%E8%A1%8C%E4%B8%BA%E3%80%82%E4%BA%A4%E4%BA%92%E8%A7%A6%E5%8F%91%E5%99%A8%E4%B8%8E%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8command%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%89%8D%E8%80%85%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%84%E7%A7%8D%E4%BA%8B%E4%BB%B6%EF%BC%8C%E8%80%8C%E5%90%8E%E8%80%85%E5%8F%AA%E8%83%BD%E5%AF%B9click%E4%BA%8B%E4%BB%B6%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A%E3%80%82">https://blog.csdn.net/qq_44558009/article/details/117586373，交互触发器与事件触发器的区别是，前者用于xaml与viewmodel之间的事件绑定，而后者仅用于前端xaml部分的交互行为。交互触发器与直接使用command进行绑定的区别是前者可以绑定各种事件，而后者只能对click事件进行绑定。</a></p><p>当然，针对特定事件进行绑定的方式有两种，一种是使用inputbinding，另一种就是使用行为触发器。</p><p>两者区别：InputBindings只能绑定到控件的输入事件（例如KeyDown、KeyUp、MouseLeftButtonDown等），而Interaction.Triggers可以绑定到任何控件事件（例如Loaded、MouseEnter、MouseLeave等）。 InputBindings只能绑定到控件自身的输入事件，而Interaction.Triggers可以绑定到控件内部的子元素的事件。 总的来说，InputBindings更适合用于控件级别的简单交互，而Interaction.Triggers更适合用于更复杂的交互，例如动画、状态转换等。在MVVM模式下，建议使用Interaction.Triggers，因为它可以将任何事件与命令绑定起来，更加灵活。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在我们大多数拥有Command依赖属性的控件，大多数是由于继承了ICommandSource接口，ICommandSource接口拥有着三个函数成员ICommand接口类型属性Command，object 类型属性CommandParameter,IInputElement 类型属性CommandTarget，而基本继承着ICommandSource接口这两个基础类的就是ButtonBase和MenuItem，因此像Button，Checkbox，RadioButton等继承自ButtonBase拥有着Command依赖属性，而MenuItem也同理。但是我们常用的Textbox那些就没有。</span><br><span class="line"></span><br><span class="line">现在我们有这种需求，我们要在这个界面基础上新增第二个Textbox，当Textbox的文本变化时，需要将按钮的Name和第二个Textbox的文本字符串合并更新到第一个Textbox上，我们第一直觉肯定会想到用Textbox的TextChanged事件，那么如何将TextChanged转为命令？</span><br><span class="line"></span><br><span class="line">首先我们在xaml界面引入：</span><br><span class="line">xmlns:i=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot;</span><br><span class="line">该程序集 System.Windows.Interactivity dll是在 Expression Blend SDK中的,而Prism的包也也将其引入包含在内了，因此我们可以直接引入，然后我们新增第二个Textbox的代码：</span><br><span class="line"></span><br><span class="line">&lt;TextBox Margin=&quot;10&quot; FontSize=&quot;32&quot; Text=&quot;&#123;Binding Foo,UpdateSourceTrigger=PropertyChanged&#125;&quot;&gt;</span><br><span class="line">    &lt;i:Interaction.Triggers&gt;</span><br><span class="line">        &lt;i:EventTrigger EventName=&quot;TextChanged&quot;&gt;</span><br><span class="line">            &lt;i:InvokeCommandAction Command=&quot;&#123;Binding TextChangedCommand&#125;&quot; CommandParameter=&quot;&#123;Binding ElementName=mybtn&#125;&quot;/&gt;</span><br><span class="line">        &lt;/i:EventTrigger&gt;</span><br><span class="line">    &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">&lt;/TextBox&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一种方式</span><br><span class="line">&lt;Button Content=&quot;Click Me&quot; Command=&quot;&#123;Binding MyCommand&#125;&quot;&gt;</span><br><span class="line">    &lt;Button.InputBindings&gt;</span><br><span class="line">        &lt;MouseBinding Gesture=&quot;LeftButtonUp&quot; /&gt;</span><br><span class="line">    &lt;/Button.InputBindings&gt;</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第二种方式</span><br><span class="line">交互触发器（trigger）的方式。</span><br><span class="line">xmlns:i=&quot;http://schemas.microsoft.com/xaml/behaviors  </span><br><span class="line"></span><br><span class="line"> &lt;Button Name=&quot;btn&quot; Content=&quot;Button&quot; Height=&quot;33&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;40,24,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;109&quot;&gt;  </span><br><span class="line">            &lt;i:Interaction.Triggers&gt;  </span><br><span class="line">                &lt;i:EventTrigger EventName=&quot;Click&quot;&gt;  </span><br><span class="line">                    &lt;i:InvokeCommandAction Command=&quot;&#123;Binding Command1&#125;&quot; CommandParameter=&quot;10&quot; /&gt;  </span><br><span class="line">                &lt;/i:EventTrigger&gt;  </span><br><span class="line">                &lt;i:EventTrigger EventName=&quot;MouseMove&quot;&gt;  </span><br><span class="line">                    &lt;i:InvokeCommandAction Command=&quot;&#123;Binding Command2&#125;&quot; CommandParameter=&quot;&#123;Binding ElementName=btn&#125;&quot; /&gt;  </span><br><span class="line">                &lt;/i:EventTrigger&gt;  </span><br><span class="line">            &lt;/i:Interaction.Triggers&gt;  </span><br><span class="line">        &lt;/Button&gt;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">事件触发器只针对xaml中的交互进行处理，无法与viewmodel中的方法进行绑定</span><br><span class="line">&lt;EventTrigger RoutedEvent=&quot;Mouse.MouseEnter&quot;&gt;鼠标按下</span><br><span class="line">                        &lt;BeginStoryboard&gt;执行开始面板，还有暂停面板等</span><br><span class="line">                            &lt;Storyboard&gt;套路，使用它的原因是下面的DoubleAnimation控件会调用storyboard.targetproperty的属性来设置针对某个属性值进行变化</span><br><span class="line">                            doubleanimation的属性有四个：duration动画时间，To：变化终点，By变化幅度，From：变化起点</span><br><span class="line">                                &lt;DoubleAnimation Duration=&quot;0:0:0.2&quot; Storyboard.TargetProperty=&quot;FontSize&quot; To=&quot;24&quot;/&gt;</span><br><span class="line">                            &lt;/Storyboard&gt;</span><br><span class="line">                        &lt;/BeginStoryboard&gt;         </span><br><span class="line">                &lt;/EventTrigger&gt;</span><br><span class="line">                &lt;EventTrigger RoutedEvent=&quot;Mouse.MouseLeave&quot;&gt;鼠标离开</span><br><span class="line">                    &lt;EventTrigger.Actions&gt;</span><br><span class="line">                        &lt;BeginStoryboard&gt;</span><br><span class="line">                            &lt;Storyboard&gt;</span><br><span class="line">                                &lt;DoubleAnimation Duration=&quot;0:0:1&quot; Storyboard.TargetProperty=&quot;FontSize&quot;/&gt;</span><br><span class="line">                            &lt;/Storyboard&gt;</span><br><span class="line">                        &lt;/BeginStoryboard&gt;</span><br><span class="line">                    &lt;/EventTrigger.Actions&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zh7791/p/11372623.html">https://www.cnblogs.com/zh7791/p/11372623.html</a></p><p>​样式触发器相当于前端的js，在前端页面执行if，else操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">触发器：鼠标移动控件上面或离开控件时触发</span><br><span class="line">&lt;Style x:Key=&quot;trigger&quot; TargetType=&quot;Button&quot;&gt;</span><br><span class="line">            &lt;Style.Triggers&gt;</span><br><span class="line">                &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&gt;//这个不是事件，而是属性</span><br><span class="line">                    &lt;Setter Property=&quot;Background&quot; Value=&quot;Green&quot;/&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;FontSize&quot; Value=&quot;50&quot;/&gt;</span><br><span class="line">                &lt;/Trigger&gt;</span><br><span class="line">                &lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;False&quot;&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;Background&quot; Value=&quot;Green&quot;/&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;FontSize&quot; Value=&quot;50&quot;/&gt;</span><br><span class="line">                &lt;/Trigger&gt;        </span><br><span class="line">            &lt;/Style.Triggers&gt;</span><br><span class="line"> &lt;/Style&gt;</span><br><span class="line"> 多条件触发器：同时满足多个条件时触发</span><br><span class="line">  &lt;Style x:Key=&quot;multicon&quot; TargetType=&quot;Button&quot;&gt;</span><br><span class="line">            &lt;Style.Triggers&gt;</span><br><span class="line">                &lt;MultiTrigger&gt;</span><br><span class="line">                    &lt;MultiTrigger.Conditions&gt;</span><br><span class="line">                        &lt;Condition Property=&quot;IsMouseOver&quot; Value=&quot;true&quot;/&gt;</span><br><span class="line">                        &lt;Condition Property=&quot;IsFocus&quot; Value=&quot;true&quot;/&gt;</span><br><span class="line">                    &lt;/MultiTrigger.Conditions&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;Foreground&quot; Value=&quot;Blue&quot;/&gt;</span><br><span class="line">                    &lt;Setter Property=&quot;FontSize&quot; Value=&quot;50&quot;/&gt;</span><br><span class="line">                &lt;/MultiTrigger&gt;</span><br><span class="line">            &lt;/Style.Triggers&gt;</span><br><span class="line">        &lt;/Style&gt;</span><br><span class="line">事件触发器：eventTrigger，触发事件，更改前端的样式，实际上也属于样式触发器的一种</span><br><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;Style x:Key=&quot;SetButtonMouseOver&quot;&gt;</span><br><span class="line">        &lt;!--设置触发器--&gt;</span><br><span class="line">        &lt;Style.Triggers&gt;</span><br><span class="line">            &lt;!--设置触发器的路由事件--&gt;</span><br><span class="line">            &lt;EventTrigger RoutedEvent=&quot;Control.MouseEnter&quot;&gt;</span><br><span class="line">                &lt;!--设置一个动画，改变元素的字体的大小--&gt;</span><br><span class="line">                &lt;EventTrigger.Actions&gt;</span><br><span class="line">                    &lt;BeginStoryboard&gt;                            </span><br><span class="line">                        &lt;Storyboard&gt;</span><br><span class="line">                             &lt;DoubleAnimation Duration=&quot;0:0:0:2&quot; Storyboard.TargetProperty=&quot;FontSize&quot; To=&quot;30&quot;&gt;&lt;/DoubleAnimation&gt;</span><br><span class="line">                        &lt;/Storyboard&gt;</span><br><span class="line">                    &lt;/BeginStoryboard&gt;</span><br><span class="line">                &lt;/EventTrigger.Actions&gt;</span><br><span class="line">            &lt;/EventTrigger&gt;</span><br><span class="line">        &lt;/Style.Triggers&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="控件模板"><a href="#控件模板" class="headerlink" title="控件模板"></a>控件模板</h4><p>ControlTemplate</p><p>控件模板是一种更加激进的方法，允许完全重写控件的内容模型，即可以修改某些控件的外观</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;!--在资源中定义一个名叫button_template的模板--&gt;</span><br><span class="line">    &lt;ControlTemplate x:Key=&quot;button_template&quot; TargetType=&quot;&#123;x:Type Button&#125;&gt;为Button控件添加控件模板，修改Button控件的外观</span><br><span class="line">        &lt;!--添加Border元素,为其设置属性--&gt;其中border相当于定义一个矩形，BorderThickess是矩形的边框厚度，BorderBrush是矩形的边框颜色，backGround是矩形里面除了边框后部分背景</span><br><span class="line">        &lt;Border BorderBrush=&quot;Orange&quot; Background=&quot;LightCyan&quot; TextBlock.Foreground=&quot;Black&quot; BorderThickness=&quot;2&quot; CornerRadius=&quot;5&quot;&gt;</span><br><span class="line">            &lt;ContentPresenter RecognizesAccessKey=&#x27;True&#x27; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;&lt;/ContentPresenter&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/ControlTemplate&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line">    </span><br><span class="line">&lt;StackPanel&gt;</span><br><span class="line">    &lt;!--为第一个Button元素设置模板。使用上面修改后的控件模板--&gt;</span><br><span class="line">    &lt;Button Template=&quot;&#123;StaticResource button_template&#125;&quot; Padding=&quot;5&quot; Margin=&quot;5&quot; Height=&quot;50&quot;&gt;我是Button1&lt;/Button&gt;</span><br><span class="line">    &lt;Button Padding=&quot;5&quot; Margin=&quot;5&quot; Height=&quot;50&quot;&gt;我是Button2&lt;/Button&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br></pre></td></tr></table></figure><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p>DataTemplate，数据模板的上一级必须是ItemTemplate</p><p><a href="https://www.cnblogs.com/1024E/p/15744315.html">https://www.cnblogs.com/1024E/p/15744315.html</a></p><p>数据模板的作用就是对于集合控件中的每个数据进行外观显示设置，这样不必使用循环进行操作，而且xmal中也没有循环。对于一个集合控件，定义的数据模板是针对每个集合控件的子项来说的。是每个子项的数据模板。或者说，集合控件在生成子项时，根据定义好的数据模板去定义出每个子项。<font color="red">所以数据模板用来装饰集合中的每一条数据如何显示,而控件模板应用于每一个控件，对某个控件外观修饰，无法对数据进行修饰</font>&gt;</p><p><strong>ItemsControl</strong>条目模板，用来设置设置各种相似控件的，仅起展示作用。而数据模板用来展示相似数据的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemsControl&gt;</span><br><span class="line">                        &lt;ItemsControl.ItemsPanel&gt;</span><br><span class="line">                            &lt;ItemsPanelTemplate&gt;</span><br><span class="line">                                &lt;UniformGrid Columns=&quot;2&quot;&gt;&lt;/UniformGrid&gt;</span><br><span class="line">                            &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">                        &lt;/ItemsControl.ItemsPanel&gt;                      </span><br><span class="line">                            &lt;Button Style=&quot;&#123;StaticResource MaterialDesignIconButton&#125;&quot; ToolTip=&quot;Google Chrome&quot;&gt;</span><br><span class="line">                                &lt;materialDesign:PackIcon Kind=&quot;GoogleChrome&quot; Height=&quot;24&quot; Width=&quot;24&quot; &gt;&lt;/materialDesign:PackIcon&gt;</span><br><span class="line">                            &lt;/Button&gt;</span><br><span class="line">&lt;/ItemsControl&gt;</span><br></pre></td></tr></table></figure><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>wpf数据绑定<a href="https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/data/?view=netdesktop-6.0">https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/data/?view=netdesktop-6.0</a></p><p><a href="https://www.cnblogs.com/zh7791/p/11379942.html">https://www.cnblogs.com/zh7791/p/11379942.html</a></p><p>binding的标准形式：{Binding ElementName&#x3D;源, Path&#x3D;属性,Mode&#x3D;方式,FallbackValue&#x3D;默认值,UpdateSourceTrigger&#x3D;触发方式}。</p><p>binding中有两个属性：path用来寻找控件中的属性，source（ElementName(有名字的控件之间),RelativeSource(无名字的控件))用来寻找控件，</p><p><strong>没有Path的情况</strong>：使用了资源，Source是某些固定的字符串或者int类型，它是固定的，因此他没有属性</p><p>**没有Source的情况：**因为使用了DataContext，将DataContext作为自己的Source。注意每个标签都有DataContext属性。但是如果没有为当前控件设置datacontext的话，该控件会将父级控件的dataContext借过来作为自己的属性值。</p><p>在prism中系统会默认将View中的DataContext设置为对应的ViewModel，所以这也是为什么在绑定的时候不需要设置Source而直接设置path的值就会与ViewModel中的属性相关联。（没指定Source，DataContext就是Source，指定了Source，则source为指定的控件，datacontext指向VIewmodel）</p><p>另一种方式是在后台使用this.DataContext&#x3D;类名绑定类。一般用在集合控件中，集合中的每一个item就是一个dataContext,所以对于集合类控件，直接写{binding}意味着与集合中的每一项进行绑定。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xmlns:local=&quot;cls-namespace:WpfApplication&quot;</span><br><span class="line">&lt;StackPanel.DataContext&gt;</span><br><span class="line">&lt;local:Student Id=&quot;6&quot; Age=&quot;29&quot; Name=&quot;Tim&quot;/&gt;//相当于StackPanel.DataContext= new Student&#123;Id=6,Age=29,Name=Tim&#125;,DataContext可以是各种类型，string，int类型都可。</span><br><span class="line">&lt;/StackPanel.DataContext&gt;</span><br><span class="line">绑定时如下,没有Source</span><br><span class="line">&lt;TextBox Text=&quot;&#123;Binding Path=Id&#125;&quot;&gt;path会自动沿着树寻找具有id属性的值。</span><br><span class="line">&lt;TextBox Text=&quot;&#123;Binding Path=Age&#125;&quot;&gt;</span><br><span class="line">&lt;TextBox Text=&quot;&#123;Binding Path=Name&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>既没有Source也没有Path的情况：当DataContext是个简单对象，即没有属性等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;StackPanel.DataContext&gt;</span><br><span class="line">&lt;sys:String&gt;HelloWorld&lt;/sys:Strings&gt;</span><br><span class="line">&lt;/StackPanel.DataContext&gt;</span><br><span class="line"></span><br><span class="line">&lt;StackPanel&gt;</span><br><span class="line">&lt;TextBlock Text=&quot;&#123;Binding&#125;&quot;/&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br></pre></td></tr></table></figure><p>以下是针对Listbox和ItemsControl的DataContext溯源问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ListBox </span><br><span class="line">                        x:Name=&quot;menuBar&quot;</span><br><span class="line">                        ItemsSource=&quot;&#123;Binding MenuBars&#125;&quot;</span><br><span class="line">                        &gt;</span><br><span class="line">                    &lt;i:Interaction.Triggers&gt;</span><br><span class="line">                        &lt;i:EventTrigger</span><br><span class="line">                            EventName=&quot;SelectionChanged&quot;&gt;</span><br><span class="line">                            &lt;i:InvokeCommandAction</span><br><span class="line">如下：在command中想要绑定ViewModel中Navigate方法，</span><br><span class="line">第一种方式是用相邻控件方式先找到ListBox作为Source，在Path中如果不指定DataContext则它会报错，（因为Source是ListBox，而ListBox中无Navigate属性，）而从上面“没有Source的情况”分析可知，ListBox的DataContext指向ViewModel</span><br><span class="line">                                1.Command=&quot;&#123;Binding DataContext.NavigateCommand, RelativeSource=&#123;RelativeSource AncestorType=ListBox, Mode=FindAncestor &#125;&#125;&quot;</span><br><span class="line"> 第二种方式是直接绑定，因为交互触发器并不位于DataTemplate里面，所以，它的DataContext并不是ItemSource里面的项，根据上面“没有Source的情况”可知，此时的DataContext就是Source，而此时DataContext是ViewModel了，而如果改为Command=&quot;&#123;binding DataConetext.NavigateCommand&#125;&quot;也是错误的，因为Source已经为ViewModel，了DataContext则会被认为是ViewmModel中的属性，而ViewModel中没有该属性。</span><br><span class="line">                               //  2.Command=&quot;&#123;binding NavigateCommand&#125;&quot;</span><br><span class="line">                                CommandParameter=&quot;&#123;Binding ElementName=menuBar, Path=SelectedItem&#125;&quot; /&gt;//返回当前选中项</span><br><span class="line">                        &lt;/i:EventTrigger&gt;</span><br><span class="line">                    &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">                    &lt;ListBox.ItemTemplate&gt;</span><br><span class="line">                        &lt;DataTemplate&gt;</span><br><span class="line">                            &lt;StackPanel Orientation=&quot;Horizontal&quot; Margin=&quot;10&quot;&gt;</span><br><span class="line">                                &lt;materialDesign:PackIcon Kind=&quot;&#123;Binding Icon&#125;&quot;  /&gt;</span><br><span class="line">                                &lt;TextBlock Text=&quot;&#123;Binding Title&#125;&quot; Margin=&quot;20,0,0,0&quot;/&gt;</span><br><span class="line">                            &lt;/StackPanel&gt;</span><br><span class="line">                        &lt;/DataTemplate&gt;</span><br><span class="line">                    &lt;/ListBox.ItemTemplate&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> ItemsControl与Listbox不同，在返回参数时，ListBox具有SelectedItem属性来返回对象，而ItemsControl是没有的，所以需要将其写在DataTemplate来返回对象。一旦放在DataTemplate里面了，则此时的DataContext就指向了ItemsSource里面的每个对象。所以在Command绑定方面与ListBox不一样。</span><br><span class="line"> </span><br><span class="line"> &lt;ItemsControl</span><br><span class="line">                 ItemsSource=&quot;&#123;Binding Memo&#125;&quot;</span><br><span class="line">                &lt;ItemsControl.ItemsPanel&gt;</span><br><span class="line">                    &lt;ItemsPanelTemplate&gt;</span><br><span class="line">                        &lt;WrapPanel</span><br><span class="line">                            Margin=&quot;10&quot;&gt;&lt;/WrapPanel&gt;</span><br><span class="line">                    &lt;/ItemsPanelTemplate&gt;</span><br><span class="line">                &lt;/ItemsControl.ItemsPanel&gt;</span><br><span class="line">                &lt;ItemsControl.ItemTemplate&gt;</span><br><span class="line">                    &lt;DataTemplate&gt;</span><br><span class="line">                        &lt;StackPanel</span><br><span class="line">                            Background=&quot;Green&quot;</span><br><span class="line">                            Width=&quot;150&quot;</span><br><span class="line">                            Height=&quot;100&quot;</span><br><span class="line">                            Margin=&quot;10&quot;&gt;</span><br><span class="line">                                &lt;i:Interaction.Triggers&gt;</span><br><span class="line">                                    &lt;i:EventTrigger</span><br><span class="line">                                        EventName=&quot;MouseLeftButtonUp&quot;&gt;</span><br><span class="line">                                        &lt;i:InvokeCommandAction</span><br><span class="line"> </span><br><span class="line">                                            CommandParameter =&quot;&#123;Binding&#125;&quot;//返回当前项</span><br><span class="line">1. 可以看到，要想绑定到ViewModel中的SelectedCommand方法，首先让source跳出ItemsSource中的项，此时datacontext指向了Viewmodel，否则指向ItemsSource中的项</span><br><span class="line"> Command=&quot;&#123;Binding Path=DataContext.SelectedCommand, RelativeSource=&#123;RelativeSource Mode=FindAncestor,AncestorType=ItemsControl&#125;&#125;&quot; /&gt; </span><br><span class="line">2.如下，则此时上下文指向ItemsSource中的项，但是该项没有SelectedCommand方法。所以报错</span><br><span class="line"> &lt;Command=&quot;&#123;Binding SelectedCommand&#125;&quot; /&gt;</span><br><span class="line">3.也会报错，因为DataContext指向ItemsSource中的项，同2</span><br><span class="line">&lt;Command=&quot;&#123;Binding DataContext.SelectedCommand&quot; /&gt;</span><br><span class="line">4.也会报错，因为Source已经为ItemsControl,但是ItemsControl里面没有SelectedCommand属性。</span><br><span class="line"> Command=&quot;&#123;Binding SelectedCommand, RelativeSource=&#123;RelativeSource Mode=FindAncestor,AncestorType=ItemsControl&#125;&#125;&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">                                    &lt;/i:EventTrigger&gt;</span><br><span class="line">                                &lt;/i:Interaction.Triggers&gt;</span><br></pre></td></tr></table></figure><h4 id="1-wpf元素之间绑定"><a href="#1-wpf元素之间绑定" class="headerlink" title="1.wpf元素之间绑定"></a>1.wpf元素之间绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Slider x:Name=&quot;mySlider&quot; Width=&quot;300&quot; Background=&quot;yellow&quot;/&gt;</span><br><span class="line">&lt;TextBox Text=&quot;&#123;Binding ElementName=mySlider,Path=Value&#125;&quot; /&gt;Path指的是绑定的对应控件的哪个属性</span><br></pre></td></tr></table></figure><h4 id="2-控件与model类中属性进行绑定（单向绑定）"><a href="#2-控件与model类中属性进行绑定（单向绑定）" class="headerlink" title="2.控件与model类中属性进行绑定（单向绑定）"></a>2.控件与model类中属性进行绑定（单向绑定）</h4><p>​1）.使用datacontext与model类进行绑定</p><p>​2）.text属性与model类中属性绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox x:Name=&quot;tb&quot; Width=&quot;200&quot; Text=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">tb.DataContext = new classmate();这个写在初始化中</span><br></pre></td></tr></table></figure><h4 id="3-xaml与viewmodel绑定（单向绑定）"><a href="#3-xaml与viewmodel绑定（单向绑定）" class="headerlink" title="3.xaml与viewmodel绑定（单向绑定）"></a>3.xaml与viewmodel绑定（单向绑定）</h4><p>类似2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Width=&quot;200&quot; Text=&quot;&#123;Binding Name&#125;&quot;/&gt;</span><br><span class="line">DataContext = new Person &#123; Name=&quot;张三&quot;&#125;;</span><br><span class="line">public class classmateViewModel</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125; = &quot;张三&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-Xaml与资源进行绑定："><a href="#4-Xaml与资源进行绑定：" class="headerlink" title="4.Xaml与资源进行绑定："></a>4.Xaml与资源进行绑定：</h4><p>控件与资源之间，通过{Binding Source&#x3D;{StaticResource 资源名}}的方式进行绑定，如果资源还有其他属性，则需要指定Path对应的属性名，若纯文本内容，则不需要指定Path。获取硬编码的数据，将数据写在资源里面，然后通过staticResource获取。通常将资源写在window里面，因为对应每个窗口中的顶级资源。如果多个窗口使用相同的资源，则不是将其定义在window下而是定义在App.xaml文件中，这样多个窗口共用同一资源,参考<a href="https://www.cnblogs.com/rolayblog/p/15630417.html%EF%BC%88%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90%E5%AD%97%E5%85%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%83%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%B5%84%E6%BA%90%EF%BC%89">https://www.cnblogs.com/rolayblog/p/15630417.html（注意使用资源字典的原因是因为可能会布置多个资源）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">何为资源：就是文件或者写死的东西，任何.Resource都是资源</span><br><span class="line"> &lt;Window.Resources&gt;//&lt;StaticPanel.Resources&gt;</span><br><span class="line">        &lt;sys:String x:Key=&quot;zero&quot;&gt;静夜思&lt;/sys:String&gt;</span><br><span class="line">        &lt;sys:String x:Key=&quot;one&quot;&gt;床前明月光，疑似地上霜。&lt;/sys:String&gt;</span><br><span class="line">        &lt;sys:String x:Key=&quot;two&quot;&gt;举头望明月，低头思故乡。&lt;/sys:String&gt;</span><br><span class="line">    &lt;/Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel Orientation=&quot;Vertical&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; &gt;</span><br><span class="line">        &lt;TextBlock x:Name=&quot;title&quot;  Text=&quot;&#123;Binding Source=&#123;StaticResource zero&#125;&#125;&quot; Margin=&quot;5&quot; Padding=&quot;5&quot; FontSize=&quot;20&quot; TextAlignment=&quot;Center&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">        &lt;TextBlock x:Name=&quot;first&quot;  Text=&quot;&#123;Binding Source=&#123;StaticResource one&#125;&#125;&quot; Margin=&quot;5&quot; Padding=&quot;5&quot; FontSize=&quot;20&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">        &lt;TextBlock x:Name=&quot;after&quot; Text=&quot;&#123;Binding Source=&#123;StaticResource two&#125;&#125;&quot; Margin=&quot;5&quot; Padding=&quot;5&quot; FontSize=&quot;20&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br></pre></td></tr></table></figure><p>静态资源StaticResource与动态资源DynamicResource的区别：</p><p>在使用过程中，两者无本质差别，使用哪个都可以，区别是使用动态资源的需求是需要动态改变资源里面的内容。</p><h4 id="5-集合类与集合控件绑定"><a href="#5-集合类与集合控件绑定" class="headerlink" title="5.集合类与集合控件绑定"></a>5.集合类与集合控件绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">参考数据模板部分，注意：使用ItemsSource与集合进行绑定时，不要使用List而是使用ObservableCollection代替List，因为后者实现了INotifyCollectionChanged接口，集合变化时会立即通知控件，改变会立即显示</span><br><span class="line">前端</span><br><span class="line">&lt;ListView x:Name=&quot;mylistview&quot;所有的属性都是在listview标签里面设置</span><br><span class="line">                          ItemTapped=&quot;mylistview_ItemTapped&quot;点击事件</span><br><span class="line">                          ItemsSource=&quot;&#123;Binding MenuBars&#125;&quot;&gt;绑定</span><br><span class="line">                    &lt;ListView.ItemTemplate&gt;</span><br><span class="line">                        &lt;DataTemplate&gt;</span><br><span class="line">                            &lt;TextCell Text=&quot;&#123;Binding Name&#125;&quot;后端name与前端text绑定</span><br><span class="line">                             Detail=&quot;&#123;Binding Content&#125;&#125;&quot;/&gt;同上</span><br><span class="line">                        &lt;/DataTemplate&gt;</span><br><span class="line">                    &lt;/ListView.ItemTemplate&gt;</span><br><span class="line">                &lt;/ListView&gt;</span><br><span class="line">         </span><br><span class="line">后端</span><br><span class="line">1.mylistview.ItemsSource = poetryList;//另一种绑定方式</span><br><span class="line">2.private async void mylistview_ItemTapped(object sender, ItemTappedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            await DisplayAlert(&quot;tap&quot;,(e.Item as Poety).Name,&quot;ok&quot;);  使用前端的某一项需将使用ItemTappedEventArgs</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="6-对方法的返回值绑定"><a href="#6-对方法的返回值绑定" class="headerlink" title="6.对方法的返回值绑定"></a>6.对方法的返回值绑定</h4><p>使用ObjectDataProvider绑定</p><p>一些情况下，xaml显示的数据可能是后台中方法返回的值，则无法绑定属性参考深入浅出wpf</p><h3 id="7-对相邻元素进行绑定"><a href="#7-对相邻元素进行绑定" class="headerlink" title="7.对相邻元素进行绑定"></a>7.对相邻元素进行绑定</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">针对未设置Name属性的控件绑定使用RelativeSource进行绑定，Mode模式由FindAncestor，self等，前者表示查询父控件，后者表示查找本身控件，path表示与该控件的某个属性进行绑定。如下，实际上Text最终的值就是Box1</span><br><span class="line">&lt;Grid&gt;</span><br><span class="line">        &lt;StackPanel&gt;</span><br><span class="line">            &lt;TextBox Height=&quot;30&quot; Width=&quot;60&quot; Name=&quot;Box1&quot; Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=self&#125;,Path=Name &#125;&quot;/&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"> 同理如下：如果设置了AncestorType=&#123;x:Type Grid&#125;则在寻找时会忽略非Grid的控件只招Grid类型的控件，AncestorLevel=2表示向上找两层。如下，最终TextBox值为G1，如果删除 AncestorType=&#123;x:Type Grid&#125;则最终为G2</span><br><span class="line"> &lt;Grid Name=&quot;G1&quot;&gt;</span><br><span class="line">        &lt;Grid Name=&quot;G2&quot;&gt;</span><br><span class="line">            &lt;StackPanel Name=&quot;S1&quot;&gt;</span><br><span class="line">                &lt;TextBox Height=&quot;30&quot; Width=&quot;60&quot; Name=&quot;Box1&quot; Text=&quot;&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor, AncestorType=&#123;x:Type Grid&#125;, AncestorLevel=2&#125;,Path=Name &#125;&quot;/&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="绑定模式"><a href="#绑定模式" class="headerlink" title="绑定模式"></a>绑定模式</h4><p>1.default:自动确定，若是可编辑的则双向绑定，若是只读的则单向绑定</p><p>2.OneWay：单向绑定</p><p>3.TwoWay:双向绑定</p><p>4.OneTime:只绑定初始值</p><p>5.OneWayToSource:反过来单向绑定</p><h3 id="git使用方法：参考xamarin视频"><a href="#git使用方法：参考xamarin视频" class="headerlink" title="git使用方法：参考xamarin视频"></a>git使用方法：参考xamarin视频</h3><p>1.数据库打包进项目中更改为嵌入式资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">    &lt;EmbeddedResource Include=&quot;poetrydb.sqlite3&quot;&gt;</span><br><span class="line">      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;</span><br><span class="line">    &lt;/EmbeddedResource&gt;</span><br><span class="line">  &lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>2.数据库拷贝到对应的文件路径时需修改配置文件，否则拷贝的数据库为空：在1的基础上加上LoginName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">    &lt;EmbeddedResource Include=&quot;poetrydb.sqlite3&quot;&gt;</span><br><span class="line">      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;</span><br><span class="line">&lt;LogicalName&gt;poetrydb.sqlite3&lt;/LogicalName&gt;</span><br><span class="line">    &lt;/EmbeddedResource&gt;</span><br><span class="line">  &lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>3.单元测试下Preferce偏好存储不能使用</p><h2 id="MaterialDesign"><a href="#MaterialDesign" class="headerlink" title="MaterialDesign"></a>MaterialDesign</h2><p>一种应用于wpf的前端界面框架；使用方式参考<a href="https://www.cnblogs.com/rolayblog/p/15630417.html">https://www.cnblogs.com/rolayblog/p/15630417.html</a></p><p>引入themes4.8.0ci155nuget包</p><p>App.xaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在Home的Source里面</span><br><span class="line">&lt;Application.Resources&gt;</span><br><span class="line">        &lt;ResourceDictionary&gt;</span><br><span class="line">            &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml&quot; /&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&quot; /&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml&quot; /&gt;</span><br><span class="line">                &lt;ResourceDictionary Source=&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml&quot; /&gt;</span><br><span class="line">            &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">        &lt;/ResourceDictionary&gt;</span><br><span class="line">    &lt;/Application.Resources&gt;</span><br><span class="line">———————————————</span><br><span class="line">原文链接：https://blog.csdn.net/huatoudd/article/details/114529859</span><br></pre></td></tr></table></figure><p>1.&lt;md:DialogHost Identifier&#x3D;“Root”&gt;”，它的作用是用来作为弹出框的载体，用来放置弹出框所在的主页面，dialoghost由三部分组成，宿主控件，覆盖层和对话框，宿主控件包含应将对话框放在其上的内容（一般是整个页面），通常放在xaml的根目录附近，叠加层就是变暗区域，对话框本身就是显示的内容其中md是对MaterialDesign的命名空间的申明，这个xaml意思是将此整个窗口作为对话框的DialogHost，并用“Root”命名作为唯一识别。。此名称将传递到对话框中，告诉对话框悬停在哪个DialogHost上，<a href="https://www.likecs.com/show-284803.html%EF%BC%8Chttps://www.cnblogs.com/IRisingStar/p/16127986.html,%E5%AE%83%E6%98%AF%E7%94%A8%E6%9D%A5%E8%AE%BE%E7%BD%AE%E8%8C%83%E5%9B%B4%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8%E6%9D%A5%E8%AE%BE%E7%BD%AE%E5%B8%83%E5%B1%80%E7%9A%84%E3%80%82">https://www.likecs.com/show-284803.html，https://www.cnblogs.com/IRisingStar/p/16127986.html,它是用来设置范围的，而不是用来设置布局的。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;materialDesign:DialogHost&gt;</span><br><span class="line">//下面这句话相当于后台的messagebox.show();只不过这里可以自定义弹出框的内容</span><br><span class="line">&lt;materialDesign:DialogHost.DialogContent&gt;</span><br><span class="line">        &lt;Grid</span><br><span class="line">            Margin=&quot;16&quot;&gt;</span><br><span class="line">            &lt;TextBlock</span><br><span class="line">                Text=&quot;我的第一个DialogHost&quot;</span><br><span class="line">                FontSize=&quot;20&quot; /&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">    &lt;/materialDesign:DialogHost.DialogContent&gt;</span><br><span class="line">    &lt;materialDesign:DialogHost.Content&gt;//下面是设置非弹框页面，该行代码可以省略，默认赋值给Content，content本身不具备布局功能</span><br><span class="line">    &lt;gird&gt;</span><br><span class="line">            &lt;Button&gt;&lt;/Button&gt;</span><br><span class="line">            &lt;button&gt;&lt;/Button&gt;</span><br><span class="line">            &lt;/grid&gt;</span><br><span class="line">        &lt;/materialDesign:DialogHost.Content&gt;</span><br><span class="line">&lt;/materialDesign:DialogHost&gt;</span><br></pre></td></tr></table></figure><p>我们会看到drawerhost放在dialoghost里面，这是因为实际上将drawerhost赋给了DialogHost.Content属性，drawerhost包含整个页面的内容，是因为它作为导航栏的载体，而dialoghost作为弹框的载体。页面可能会有弹窗，一旦弹窗就按照dialoghost.dialogcontent设置的格式弹窗，如果没有弹框，那么dialoghost实际上可以省略，只使用drawerhost即可</p><p>2.&lt;md:DrawerHost ,它的级别与dialoghost是同一级别，只不过它是一般用来制作导航栏，<a href="https://blog.csdn.net/sD7O95O/article/details/104911926%E3%80%82">https://blog.csdn.net/sD7O95O/article/details/104911926。</a></p><p>3.materialDesign:ColorZone是用来设置背景颜色的，类似border</p><p>传统方式的弹出框如下，弹出框是在整个屏幕的中间弹出</p><p><img src="/2026/01/29/Maui/assets/image-20230321195807935.png" alt="image-20230321195807935"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> &lt;materialDesign:DialogHost CloseOnClickAway=&quot;True&quot;&gt;</span><br><span class="line">// dialoghost.dialogcontet是用来设置弹出框内容的。</span><br><span class="line">        &lt;materialDesign:DialogHost.DialogContent&gt;</span><br><span class="line">            &lt;Grid Margin=&quot;16&quot;&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;我的第一个DialogHost&quot; FontSize=&quot;20&quot;/&gt;</span><br><span class="line">            &lt;/Grid&gt;</span><br><span class="line">        &lt;/materialDesign:DialogHost.DialogContent&gt;</span><br><span class="line">//在非dialoghost.dialogcontet部分是显示灰色。</span><br><span class="line">        &lt;Button Command=&quot;&#123;x:Static materialDesign:DialogHost.OpenDialogCommand&#125;&quot; Width=&quot;160&quot; Content=&quot;打开&quot; Margin=&quot;0,64,0,0&quot;/&gt;</span><br><span class="line"> 对应的图像如下，弹框是在程序界面的中间弹出</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/Maui/assets/image-20230321211231001.png" alt="image-20230321211231001"></p><p><img src="/2026/01/29/Maui/assets/image-20230321194017374.png" alt="image-20230321194017374"></p><p>如下我们可以看见，dialoghost所在的区域是第二行，第二行为变暗区域。</p><p><img src="/2026/01/29/Maui/assets/image-20230418201452091.png" alt="image-20230418201452091"></p><p>4.Card控件：类似于windform中的panel，一种容器，在Materials Design中也非常强调使用卡片式布局,它可以让页面中的元素看起来就像在卡片中一样,并且还能拥有圆角和投影等效果,看上去会有立体的感觉。针对小容器中既有图片又有文字的情况会使用card控件</p><p><img src="/2026/01/29/Maui/assets/image-20230406203155086.png" alt="image-20230406203155086"></p><p>5.materialDesign:TransitioningContent：用来设置动画的。可以设置从哪里飞入<a href="https://www.cnblogs.com/Dotnet9-com/p/13111207.html">https://www.cnblogs.com/Dotnet9-com/p/13111207.html</a>,</p><p><a href="https://dotnet9.com/2020/06/WPF-Food-Application-Login-UI-Design">https://dotnet9.com/2020/06/WPF-Food-Application-Login-UI-Design</a></p><p>6.文字，border设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">正文颜色：Foreground=&quot;&#123;DynamicResource MaterialDesignBodyLight&#125;&quot;</span><br><span class="line">Border分割线颜色:BorderBrush=&quot;&#123;DynamicResource MaterialDesignDivider&#125;&quot; borderthickness=0.1</span><br><span class="line">另一种分割线:  &lt;Separator Style=&quot;&#123;StaticResource MaterialDesignLightSeparator&#125;&quot; /&gt;</span><br><span class="line">另一种分割线： &lt;Border Style=&quot;&#123;StaticResource HorizontalDividerBorder&#125;&quot; /&gt;</span><br><span class="line">自动换行:TextWrapping=&quot;Wrap&quot;</span><br></pre></td></tr></table></figure><p>7.样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按钮样式：Style=&quot;&#123;StaticResource MaterialDesignFlatButton&#125;&quot;</span><br><span class="line">文字样式:Style=&quot;&#123;StaticResource MaterialDesignHeadline5TextBlock&#125;&quot;</span><br></pre></td></tr></table></figure><p>8.图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;materialDesign:PackIcon Kind=&quot;Gift&quot; /&gt;</span><br></pre></td></tr></table></figure><p>9.PupBox</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;materialDesign:PopupBox </span><br><span class="line">       Style=&quot;&#123;StaticResource MaterialDesignMultiFloatingActionPopupBox&#125;&quot;&gt;</span><br><span class="line">      &lt;StackPanel&gt;</span><br><span class="line">        &lt;Button Click=&quot;GitHubButton_OnClick&quot;</span><br><span class="line">                Content=&quot;&#123;materialDesign:PackIcon Kind=Github,Size=20&#125;&quot;</span><br><span class="line">                ToolTip=&quot;GitHub&quot; /&gt;</span><br><span class="line">        &lt;Button Background=&quot;&#123;DynamicResource PrimaryHueMidBrush&#125;&quot;</span><br><span class="line">        &lt;/Button&gt;</span><br><span class="line">      &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/materialDesign:PopupBox&gt;</span><br></pre></td></tr></table></figure><p>10.Button</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：方形flat(无外边框)，outline(有外边框),Raise(带背景色)圆形float,背景为图片Icon</span><br><span class="line">动画：&lt;Button</span><br><span class="line">    materialDesign:ShadowAssist.ShadowAnimationDuration=&quot;0:0:0.5&quot;</span><br><span class="line">    Style=&quot;&#123;StaticResource MaterialDesignRaisedDarkButton&#125;&quot;&gt;</span><br><span class="line">  Long Duration</span><br><span class="line">&lt;/Button&gt;</span><br></pre></td></tr></table></figure><p>11.隐藏文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">materialDesign:HintAssist.Hint=&quot;Setting 1&quot;</span><br></pre></td></tr></table></figure><p>12.圆形，方形进度条</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">  materialDesign:ButtonProgressAssist.IsIndicatorVisible=&quot;True&quot;</span><br><span class="line">  materialDesign:ButtonProgressAssist.Value=&quot;75&quot;</span><br><span class="line">  Content=&quot;&#123;materialDesign:PackIcon DotsHorizontal&#125;&quot;</span><br></pre></td></tr></table></figure><p>13.卡片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;materialDesign:Card</span><br><span class="line">  Width=&quot;200&quot;&gt;</span><br><span class="line">  &lt;Grid&gt;</span><br><span class="line">    &lt;Grid.RowDefinitions&gt;</span><br><span class="line">      &lt;RowDefinition</span><br><span class="line">        Height=&quot;140&quot; /&gt;</span><br><span class="line">      &lt;RowDefinition</span><br><span class="line">        Height=&quot;*&quot; /&gt;</span><br><span class="line">      &lt;RowDefinition</span><br><span class="line">        Height=&quot;Auto&quot; /&gt;</span><br><span class="line">    &lt;/Grid.RowDefinitions&gt;</span><br><span class="line">    &lt;Image</span><br><span class="line">      Width=&quot;196&quot;</span><br><span class="line">      Height=&quot;140&quot;</span><br><span class="line">      Source=&quot;Resources/Chartridge046_small.jpg&quot;</span><br><span class="line">      Stretch=&quot;UniformToFill&quot; /&gt;//图片均匀填充区域</span><br><span class="line">    &lt;Button</span><br><span class="line">      Grid.Row=&quot;0&quot;</span><br><span class="line">      Margin=&quot;0,0,16,-20&quot;</span><br><span class="line">      HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">      VerticalAlignment=&quot;Bottom&quot;</span><br></pre></td></tr></table></figure><p>14.允许反转的卡片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;materialDesign:Flipper</span><br><span class="line">  IsFlippedChanged=&quot;Flipper_OnIsFlippedChanged&quot;</span><br><span class="line">  Style=&quot;&#123;StaticResource MaterialDesignCardFlipper&#125;&quot;&gt;</span><br><span class="line">  //正面</span><br><span class="line">  &lt;materialDesign:Flipper.FrontContent&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">      Width=&quot;184&quot;</span><br><span class="line">      Margin=&quot;8&quot;</span><br><span class="line">      Command=&quot;&#123;x:Static materialDesign:Flipper.FlipCommand&#125;&quot;//反转命令</span><br><span class="line">      Content=&quot;FLIPPABLZ!&quot;</span><br><span class="line">      Style=&quot;&#123;StaticResource MaterialDesignFlatButton&#125;&quot; /&gt;</span><br><span class="line">  &lt;/materialDesign:Flipper.FrontContent&gt;</span><br><span class="line">  //反面</span><br><span class="line">  &lt;materialDesign:Flipper.BackContent&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">      Width=&quot;184&quot;</span><br><span class="line">      Margin=&quot;8&quot;</span><br><span class="line">      Command=&quot;&#123;x:Static materialDesign:Flipper.FlipCommand&#125;&quot;</span><br><span class="line">      Content=&quot;GO BACK&quot;</span><br><span class="line">      Style=&quot;&#123;StaticResource MaterialDesignFlatButton&#125;&quot; /&gt;</span><br><span class="line">  &lt;/materialDesign:Flipper.BackContent&gt;</span><br><span class="line">&lt;/materialDesign:Flipper&gt;</span><br></pre></td></tr></table></figure><p>15.后退按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">            &lt;materialDesign:PackIcon</span><br><span class="line">              HorizontalAlignment=&quot;Right&quot;</span><br><span class="line">              Kind=&quot;ArrowLeft&quot; /&gt;</span><br></pre></td></tr></table></figure><p>16.panel.zindex</p><p>通过该附加属性来设置两个重合的控件，哪个控件放在上面。</p><p>17.dialoghost弹出，收缩窗口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md中自带一些方法可以绑定在command上面。仅操作前端的数据，不操作后端的数据，也可以通过viewmodel中的方法去弹出框</span><br><span class="line">Command=&quot;&#123;x:Static materialDesign:DialogHost.OpenDialogCommand&#125;&quot;，不必绑定后端了</span><br><span class="line">Command=&quot;&#123;x:Static materialDesign:DialogHost.CloseDialogCommand&#125;&quot;</span><br></pre></td></tr></table></figure><p>18.Memu控件，用于菜单栏即下拉列表</p><p>19.ToolBars工具栏，即快捷图标</p><p>20.单行文本:textbox，多行文本richtextbox</p><p>21.日期选择:datapicker</p><p>22.时间选择:TimePicker</p><p>23.消息通知snackbar</p><p>24.选项卡：可以用来实现导航栏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;TabControl</span><br><span class="line">  Width=&quot;300&quot;&gt;</span><br><span class="line">  &lt;TabItem</span><br><span class="line">    Header=&quot;TAB 1&quot;&gt;</span><br><span class="line">    &lt;TextBlock</span><br><span class="line">      Margin=&quot;8&quot;</span><br><span class="line">      Text=&quot;Default Tab 1&quot; /&gt;</span><br><span class="line">  &lt;/TabItem&gt;</span><br><span class="line">  &lt;TabItem</span><br><span class="line">    Header=&quot;TAB 2&quot;&gt;</span><br><span class="line">    &lt;TextBlock</span><br><span class="line">      Margin=&quot;8&quot;</span><br><span class="line">      Text=&quot;Default Tab 2&quot; /&gt;</span><br><span class="line">  &lt;/TabItem&gt;</span><br><span class="line">&lt;/TabControl&gt;</span><br></pre></td></tr></table></figure><p>25.例如listbox，tabcontrol等集合控件，如果想要设置内容的布局，可以通过HorizontalContentAlignment&#x3D;”Center”，VerticleContentAlignment来设置item的布局。</p><p>26.滑动条sliderbar</p><p><img src="/2026/01/29/Maui/assets/image-20230509212646768.png" alt="image-20230509212646768"></p><p>27.进度条progressbar</p><p><img src="/2026/01/29/Maui/assets/image-20230509212712348.png" alt="image-20230509212712348"></p><h1 id="Maui"><a href="#Maui" class="headerlink" title="Maui"></a>Maui</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>首先执行的文件是AppShell.xaml文件，看见里面首先启动的页面才是MainPage.xaml</p><p><strong>App.xaml</strong>. 此文件定义应用将在 XAML 布局中使用的应用程序资源。</p><p><strong>App.xaml.cs</strong>. 这是 此文件定义 App 类。此类在运行时表示应用程序。此类中的构造函数创建一个初始窗口并将其分配给属性;此属性确定应用程序开始运行时显示哪个页面。</p><p><strong>AppShell.xaml</strong>  .NET MAUI 提供了许多对多平台应用有益的功能，包括应用样式、基于 URI 的导航和布局选项，包括浮出控件导航和应用程序根目录的选项卡。</p><p><strong>MainPage.xaml</strong>。此文件包含用户界面定义。该控件使控件垂直排列（在堆栈中），如果视图太大而无法在设备上显示，则提供滚动条。</p><p><strong>MainPage.xaml.cs.</strong> 这是页面的代码隐藏。</p><p><strong>MauiProgram.cs</strong>。 每个本机平台都有不同的起点来创建和初始化应用程序。可以在项目的<strong>PlatForms</strong>文件夹下找到此代码。此代码是特定于平台的，但最后它调用静态类的方法。该类和方法在各个platforms的的代码中被调用。提供用于注册字体、为依赖项注入配置服务、为控件注册自定义处理程序等任务的方法</p><p><strong>PlatForms</strong>：此文件夹包含特定于平台的初始化代码文件和资源。</p><p><img src="/2026/01/29/Maui/assets/image-20230314205607664.png" alt="image-20230314205607664"></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><img src="/2026/01/29/Maui/assets/image-20230314213245906.png" alt="image-20230314213245906"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlexLayout`，它与`StackLayout` 类似，如果它们不适合单行或列，允许您包装它包含的子控件，。此布局还提供了对齐和适应不同屏幕尺寸的选项。例如，FlexLayout 控件可以在垂直排列时将其子控件向左、向右或居中对齐。</span><br></pre></td></tr></table></figure><p>还有两种布局：VertialStackLayout和HorizontalStackLayout这两种是显示指定了布局方式，优化比StackLayout更好一些，StackLayout可以通过属性设置为前面两种方式的布局</p><p>位置选项：在wpf的水平和垂直布局有left，right，center，top，bottom属性，而在maui中改为了start，end和center属性如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VerticalOptions=&quot;End&quot; HorizontalOptions=&quot;Start&quot;</span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>内容页通常显示视图。视图使您能够以特定方式检索和显示数据。内容页面的默认视图是 <code>ContentView</code>，它按原样显示项目。如果缩小视图，项目可能会从显示中消失，直到调整视图大小为止。</p><p>ScrollView<code> 使您能够在滚动窗口中显示项目;如果缩小窗口，则可以上下滚动以显示项目。</code> </p><p><code>CarouselView``是一个可滚动的视图，使用户能够在项目集合中轻扫。</code></p><p>CollectionView&#96;可以从具名数据源中检索数据，并使用模板作为格式显示每个项目。还有许多其他类型的视图可用。</p><h2 id="使用代码进行平台区分"><a href="#使用代码进行平台区分" class="headerlink" title="使用代码进行平台区分"></a>使用代码进行平台区分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">针对平台页面大小不同，pading或者颜色等也有差别，可以针对某个平台进行独特的设计</span><br><span class="line">xaml中区分</span><br><span class="line">对于 iOS 以外的平台，填充将保持设置为其默认值“0，0，0，0”。对于 WinUI 和 Android，您可以使用其他块将填充设置为 30 磅：</span><br><span class="line">&lt;VerticalStackLayout&gt;</span><br><span class="line">    &lt;VerticalStackLayout.Padding&gt;</span><br><span class="line">        &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot;&gt;</span><br><span class="line">            &lt;On Platform=&quot;iOS&quot; Value=&quot;30,60,30,30&quot; /&gt;</span><br><span class="line">            &lt;On Platform=&quot;Android&quot; Value=&quot;30&quot; /&gt;</span><br><span class="line">            &lt;On Platform=&quot;WinUI&quot; Value=&quot;30&quot; /&gt;</span><br><span class="line">        &lt;/OnPlatform&gt;</span><br><span class="line">    &lt;/VerticalStackLayout.Padding&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/VerticalStackLayout&gt;</span><br><span class="line"></span><br><span class="line">简化语法：</span><br><span class="line">&lt;VerticalStackLayout Padding=&quot;&#123;OnPlatform iOS=&#x27;30,60,30,30&#x27;, Default=&#x27;30&#x27;&#125;&quot;&gt;</span><br><span class="line">    &lt;!--XAML for other controls goes here --&gt;</span><br><span class="line">&lt;/VerticalStackLayout&gt;</span><br><span class="line"></span><br><span class="line">后台区分平台：使用deviceInfo</span><br><span class="line">MyStackLayout.Padding = </span><br><span class="line">    DeviceInfo.Platform == DevicePlatform.iOS</span><br><span class="line">        ? new Thickness(30, 60, 30, 30) // Shift down by 60 points on iOS only</span><br><span class="line">        : new Thickness(30); // Set the default margin to be 30 points</span><br></pre></td></tr></table></figure><h2 id="行和列定义"><a href="#行和列定义" class="headerlink" title="行和列定义"></a>行和列定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid&gt;</span><br><span class="line">    &lt;Grid.RowDefinitions&gt;</span><br><span class="line">        &lt;RowDefinition /&gt;</span><br><span class="line">        &lt;RowDefinition /&gt;</span><br><span class="line">        &lt;RowDefinition /&gt;</span><br><span class="line">    &lt;/Grid.RowDefinitions&gt;</span><br><span class="line">    &lt;Grid.ColumnDefinitions&gt;</span><br><span class="line">        &lt;ColumnDefinition /&gt;</span><br><span class="line">        &lt;ColumnDefinition /&gt;</span><br><span class="line">    &lt;/Grid.ColumnDefinitions&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">简化为</span><br><span class="line">&lt;Grid RowDefinitions=&quot;*, *, *&quot; ColumnDefinitions=&quot;*, *&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/Grid&gt;</span><br></pre></td></tr></table></figure><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h3 id="浮出控件导航FlyoutItem"><a href="#浮出控件导航FlyoutItem" class="headerlink" title="浮出控件导航FlyoutItem"></a>浮出控件导航FlyoutItem</h3><p><img src="/2026/01/29/Maui/assets/image-20230317202546033.png" alt="image-20230317202546033"></p><p>上面的图标是通过设置flyBehavior属性为flyout而显示的，默认为disable，如果为locked则自动展开，如下</p><p>在AppShell.xaml中设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Shell</span><br><span class="line">    x:Class=&quot;MauiApp3.AppShell&quot;</span><br><span class="line">  。。。</span><br><span class="line">    FlyoutBehavior=&quot;Locked&quot;&gt;</span><br></pre></td></tr></table></figure><p>浮出控件导航是一种导航类型，其中菜单项窗口从设备屏幕一侧滑动（或飞出）。它通常通过点击所谓的“汉堡包”菜单或三条水平线堆叠在一起的图标来调用。弹出菜单由几个部分组成：Header<code>FlyoutItems</code>MenuItems&#96;Footer</p><p><img src="/2026/01/29/Maui/assets/image-20230315205244754.png" alt="image-20230315205244754"></p><p><code>FlyoutItem</code>需要托管在<code>Shell</code>页面中，该页面用作应用程序的主页，通过设置它里面的属性来展示展开框所显示的内容。您可以通过设置其ShellContent属性来指定点击时显示的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">flyoutitmes</span><br><span class="line">&lt;Shell xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;</span><br><span class="line">       xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span><br><span class="line">       xmlns:controls=&quot;clr-namespace:Xaminals.Controls&quot;</span><br><span class="line">       xmlns:views=&quot;clr-namespace:Xaminals.Views&quot;</span><br><span class="line">       x:Class=&quot;Xaminals.AppShell&quot;&gt;</span><br><span class="line">    &lt;FlyoutItem Title=&quot;Cats&quot;//flyoutitme用来定义定义浮动控件里面的列表</span><br><span class="line">                Icon=&quot;cat.png&quot;&gt;</span><br><span class="line">       &lt;Tab&gt;</span><br><span class="line">           &lt;ShellContent ContentTemplate=&quot;&#123;DataTemplate views:CatsPage&#125;&quot; /&gt;//shellContent是导航标记，用来定义导航到CatsPage.xaml页面</span><br><span class="line">       &lt;/Tab&gt;</span><br><span class="line">    &lt;/FlyoutItem&gt;</span><br><span class="line">    &lt;FlyoutItem Title=&quot;Dogs&quot;</span><br><span class="line">                Icon=&quot;dog.png&quot;&gt;</span><br><span class="line">       &lt;Tab&gt;</span><br><span class="line">           &lt;ShellContent ContentTemplate=&quot;&#123;DataTemplate views:DogsPage&#125;&quot; /&gt;</span><br><span class="line">       &lt;/Tab&gt;</span><br><span class="line">    &lt;/FlyoutItem&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br><span class="line"></span><br><span class="line">简化为</span><br><span class="line">&lt;Shell xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;</span><br><span class="line"> 。。。&quot;&gt;</span><br><span class="line">   &lt;ShellContent Title=&quot;Cats&quot;</span><br><span class="line">                 Icon=&quot;cat.png&quot;</span><br><span class="line">                 ContentTemplate=&quot;&#123;DataTemplate views:CatsPage&#125;&quot; /&gt;</span><br><span class="line">   &lt;ShellContent Title=&quot;Dogs&quot;</span><br><span class="line">                 Icon=&quot;dog.png&quot;</span><br><span class="line">                 ContentTemplate=&quot;&#123;DataTemplate views:DogsPage&#125;&quot; /&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br><span class="line">menuitems</span><br><span class="line">&lt;Shell ...&gt;</span><br><span class="line">    ...            </span><br><span class="line">    &lt;MenuItem Text=&quot;Help&quot;</span><br><span class="line">              IconImageSource=&quot;help.png&quot;</span><br><span class="line">              Command=&quot;&#123;Binding HelpCommand&#125;&quot;</span><br><span class="line">              CommandParameter=&quot;https://learn.microsoft.com/dotnet/maui/fundamentals/shell&quot; /&gt;    </span><br><span class="line">&lt;/Shell&gt;</span><br><span class="line"></span><br><span class="line">header</span><br><span class="line">&lt;Shell ...&gt;</span><br><span class="line">    &lt;Shell.FlyoutHeader&gt;</span><br><span class="line">        &lt;Grid&gt;</span><br><span class="line">            &lt;Image Source=&quot;header-image.png&quot;&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">    &lt;/Shell.FlyoutHeader&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br><span class="line"></span><br><span class="line">footer</span><br><span class="line">&lt;Shell ...&gt;</span><br><span class="line">    &lt;Shell.FlyoutFooter&gt;</span><br><span class="line">        &lt;Grid&gt;</span><br><span class="line">            &lt;Image Source=&quot;footer-image.png&quot;&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">    &lt;/Shell.FlyoutFooter&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br></pre></td></tr></table></figure><h3 id="选项卡导航TabBar"><a href="#选项卡导航TabBar" class="headerlink" title="选项卡导航TabBar"></a>选项卡导航TabBar</h3><p><img src="/2026/01/29/Maui/assets/image-20230316200301165.png" alt="image-20230316200301165"></p><p>在移动设备上，选项卡条通常具有有限的空间，并且只能显示固定数量的选项卡，具体取决于设备大小和方向。建议仅使用三到四个选项卡。如果需要四个以上的选项卡，请考虑使用其他导航模式，例如浮出控件项导航。</p><p>请创建<code>TabBar类的实例作为``Shell</code>类的子级。然后将<code>Tab</code>对象添加到 <code>TabBar</code>对象中，在<code>Tab</code>对象中，<code>ShellContent</code>应设置为对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Shell xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot;</span><br><span class="line">       xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot;</span><br><span class="line">       xmlns:views=&quot;clr-namespace:Xaminals.Views&quot;</span><br><span class="line">       x:Class=&quot;Xaminals.AppShell&quot;&gt;</span><br><span class="line">    &lt;TabBar&gt;</span><br><span class="line">       &lt;Tab Title=&quot;Moon Phase&quot;</span><br><span class="line">            Icon=&quot;moon.png&quot;&gt;</span><br><span class="line">           &lt;ShellContent ContentTemplate=&quot;&#123;DataTemplate local:MoonPhasePage&#125;&quot; /&gt;通过shellContent标记实现导航到对应的MoonPhasePage.xaml页面</span><br><span class="line">       &lt;/Tab&gt;</span><br><span class="line">       &lt;Tab Title=&quot;Sunrise&quot;</span><br><span class="line">            Icon=&quot;sun.png&quot;&gt;</span><br><span class="line">           &lt;ShellContent ContentTemplate=&quot;&#123;DataTemplate local:SunrisePage&#125;&quot; /&gt;</span><br><span class="line">       &lt;/Tab&gt;</span><br><span class="line">    &lt;/TabBar&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br></pre></td></tr></table></figure><h3 id="Stack导航"><a href="#Stack导航" class="headerlink" title="Stack导航"></a>Stack导航</h3><p>浮出控件和选项卡导航提供了一种有用的机制，使用户能够随时选择要查看的页面。用户只需选择适当的选项卡或浮出控件项即可导航到页面。这种形式的导航对于彼此具有<em>对等</em>关系的数据项非常有用。但是，对于分层数据，stack导航可能更合适。stack导航使用户能够<em>向下钻取</em>一系列页面，其中堆栈中的下一页提供上一页上所选项目的更详细视图。（类似于树结构，每个标题可能对应多个图片内容等情况）</p><ul><li><p><code>BackButtonBehavior</code>，BackButtonBehavior<code>类型 ，定义后退按钮行为的附加属性。</code></p></li><li><p><code>CurrentItem</code>，<code>ShellItem</code>类型为 ，表示当前选定的项目。</p></li><li><p>CurrentPage<code>，Page</code>类型，为当前显示的页面。&#96;</p></li><li><p><code>CurrentState</code>，<code>ShellNavigationState</code>类型为 、<code>Shell</code> 的当前导航状态。</p></li><li><p><code>Current</code>、<code>Shell</code>的类型、<code>Application.Current.MainPage</code>的类型转换别名。</p><p>导航是通过从<code>Shell</code>类调用<code>GoToAsync</code>方法来执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btnComet.Clicked += async (s, e) =&gt; await Shell.Current.GoToAsync(&quot;astronomicalbodydetails?astroName=comet&quot;);</span><br><span class="line">btnEarth.Clicked += async (s, e) =&gt; await Shell.Current.GoToAsync(&quot;astronomicalbodydetails?astroName=earth&quot;);</span><br><span class="line">btnMoon.Clicked += async (s, e) =&gt; await Shell.Current.GoToAsync(&quot;astronomicalbodydetails?astroName=moon&quot;);</span><br><span class="line">btnSun.Clicked += async (s, e) =&gt; await Shell.Current.GoToAsync(&quot;astronomicalbodydetails?astroName=sun&quot;);</span><br></pre></td></tr></table></figure><p>路由被定义在FlyoutItem<code>, </code>TabBar<code>, </code>Tab<code>, and </code>ShellContent的属性里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;Shell ...&gt;</span><br><span class="line">    &lt;FlyoutItem ... </span><br><span class="line">        Route = &quot;astronomy&quot;&gt;</span><br><span class="line">        &lt;ShellContent ...</span><br><span class="line">            Route=&quot;moonphase&quot; /&gt;</span><br><span class="line">        &lt;ShellContent ...</span><br><span class="line">            Route=&quot;sunrise&quot; /&gt;</span><br><span class="line">    &lt;/FlyoutItem&gt;</span><br><span class="line">    &lt;FlyoutItem&gt;</span><br><span class="line">        &lt;ShellContent ...</span><br><span class="line">            Route=&quot;about&quot; /&gt;</span><br><span class="line">    &lt;/FlyoutItem&gt;</span><br><span class="line">&lt;/Shell&gt;</span><br><span class="line"></span><br><span class="line">后台注册，写在appshell.xaml.cs的构造函数里面</span><br><span class="line">Routing.RegisterRoute(&quot;astronomicalbodydetails&quot;, typeof(AstronomicalBodyPage));</span><br><span class="line">后台导航，写在页面的构造函数里面。参数变量是bodyName,参数值是celestialName</span><br><span class="line">await Shell.Current.GoToAsync($&quot;astronomicalbodydetails?bodyName=&#123;celestialName&#125;&quot;);`</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="判断网络是否连接"><a href="#判断网络是否连接" class="headerlink" title="判断网络是否连接"></a>判断网络是否连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">networkaccess类里面有五个值：ConstrainedInternet, Internet, Local, None, and Unknown</span><br><span class="line">if (Connectivity.Current.NetworkAccess == NetworkAccess.None)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectivityChanged事件还使您能够确定设备是否已连接到互联网。当网络状态更改时，将自动触发该事件。例如，如果从活动网络连接开始并最终丢失它，则会引发该事件以通知您有关更改的信息。传递给事件处理程序的参数之一是对象。此对象包含一个名为 的属性。可以使用该属性来确定是否已连接到互联网。下面是一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connectivity.Current.ConnectivityChanged += Connectivity_ConnectivityChanged;</span><br><span class="line">...</span><br><span class="line">void Connectivity_ConnectivityChanged(object sender, ConnectivityChangedEventArgs  e)</span><br><span class="line">&#123;</span><br><span class="line">    bool stillConnected = e.IsConnected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p><code>HttpClient</code>是一个 .NET 类，应用可以使用该类从 REST Web 服务发送 HTTP 请求和接收 HTTP 响应。Web 服务公开的资源由一组 URI 标识。URI 将 Web 服务的地址与该地址上可用资源的名称组合在一起。</p></li></ul><h2 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h2><h4 id="偏好存储"><a href="#偏好存储" class="headerlink" title="偏好存储"></a>偏好存储</h4><p>就是一种小型数据库，通过键值进行保存。用于处理简单的片段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Preferens.Set(&quot;key&quot;,result.Text);按照键值对进行保存</span><br><span class="line">Preferens.Get(&quot;key&quot;,&quot;NoValue&quot;);根据键进行获取，第二个参数表示未获取到情况下的默认值</span><br><span class="line">该类还存在remove，clear，containkey(是否存在)等方法</span><br></pre></td></tr></table></figure><h4 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h4><p>uwp，Android，ios针对不同平台提供了同一个方法获取存储路径，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label1.Text = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);uwp，Android，ios通用，路径名在不同的平台下是不同的。</span><br><span class="line">Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));path.combine方法自动根据不同平台分成不同的路径写法，以进行保存，避免手动去拼路径字符串</span><br></pre></td></tr></table></figure><p>数据库打包进项目里面：复制到项目里面需要右键数据库属性，生成操作改为嵌入式资源</p><h4 id="web服务存储"><a href="#web服务存储" class="headerlink" title="web服务存储"></a>web服务存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = new HttpClient();</span><br><span class="line">         var response = await httpClient.GetAsync(&quot;https://v2.jinrishici.com/token&quot;);访问接口</span><br><span class="line">         var json = response.Content.ReadAsStringAsync();//获取json</span><br><span class="line">         var token = JsonConvert.DeserializeObject&lt;jinrishici&gt;(await json);json转c#需要导newtonsoft.json包</span><br><span class="line">         label1.Text = token.data;</span><br></pre></td></tr></table></figure><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>就是将xaml，文本文件等保存以流的形式保存在文件系统里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">using System.Text.Json;</span><br><span class="line">using System.IO;</span><br><span class="line"></span><br><span class="line">// Data to be written to the file system, and read back later</span><br><span class="line">List&lt;Customer&gt; customers = ...;</span><br><span class="line"></span><br><span class="line">// Serialize and save</span><br><span class="line">string fileName = ...;</span><br><span class="line">var serializedData = JsonSerializer.Serialize(customers);</span><br><span class="line">File.WriteAllText(fileName, serializedData);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Read and deserialize</span><br><span class="line">var rawData = File.ReadAllText(fileName);</span><br><span class="line">customers = JsonSerializer.Deserialize&lt;List&lt;Customer&gt;&gt;(rawData);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EF</title>
      <link href="/2026/01/29/ef%E5%AD%A6%E4%B9%A0/"/>
      <url>/2026/01/29/ef%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Enitity-framework-ef-学习"><a href="#Enitity-framework-ef-学习" class="headerlink" title="Enitity framework (ef)学习"></a>Enitity framework (ef)学习</h1><p>属于ORM；O：DOmainObject领域模型</p><p>​R；Ralation Database 关系型数据库</p><p>​M：Maping映射关系</p><p>ORM就是将相应的实体映射到相应的数据库表，然后使用orm框架封装好的api进行数据库访问，减少了自己写数据库访问类的步骤**。</p><p>三种开发方式： 1.dbfirst：先创建数据库再开发（不推荐）</p><p>​2.modelfirst：先创建模型再创建数据库（不推荐）</p><p>​3.codefirst:代码优先（推荐）</p><span id="more"></span><p>注意事项：</p><p>1.增删改查方法返回类型都是实体类型，而SaveChange返回的都是int类型，只有增删改才使用savechange方法，查询不用。这在设置接口的时候非常重要。</p><h3 id="ef中的类型对应sqlserver中的类型"><a href="#ef中的类型对应sqlserver中的类型" class="headerlink" title="ef中的类型对应sqlserver中的类型"></a>ef中的类型对应sqlserver中的类型</h3><p><font color="red">efcore中属性被命名为Id或者类名+Id会被自动设置为主键，若类型为int或者guid，则主键自增长</font></p><p>string ——nvarchar(Max)</p><p>Guid——UinqueIdentifier,它使用的mac地址，时间戳等信息生成的全球唯一id，而且不是连续的，因此他不能作为索引，sqlserver可以不将主键设置为索引，但是mysql中必须将逐渐设置为索引，所以在mysql中不能使用guid</p><p>对象&#x2F;引用类型——无映射，但是会在数据库中自动生成类名+id的外键</p><p><img src="/2026/01/29/ef%E5%AD%A6%E4%B9%A0/assets/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题"></p><p><img src="/2026/01/29/ef%E5%AD%A6%E4%B9%A0/assets/%E6%97%A0%E6%A0%87%E9%A2%982.png" alt="无标题2">必须将数据访问层与Ui层隔离开来，不应该将上下文暴露在UI层中，所以创建Service层，将上下文实例只在仓储层进行使用</p><p><strong>创建上下文的方式</strong></p><p>1.using(var context &#x3D; new Context())</p><p>{</p><p>​var blog &#x3D; _BlogRepository.Get(context,BlogId);</p><p>​context.saveChanges();</p><p>}</p><p>2.DI注册：</p><p>使用autofac等，或者自带的注册工具注入之后，直接使用即可</p><p>在Programe里面注册之后</p><p>var blog &#x3D; _BlogRepository.Get(BlogId);</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>0.引入efcore.sqlserver，和efcore tools两个包，有时候需要efcore design包</p><p>1.创建实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Book</span><br><span class="line">   &#123;</span><br><span class="line">       public long id &#123; get; set; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2.创建继承自DbContest的类：DBContext将对数据库的所有操作都封装进去，向上访问数据库，向下访问实体类，里面封装了例如增删改查多个方法。而MyDbContext就相当于一个自己的数据库，DbContext相当于一个通用的数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> class MyDbContext:DbContext</span><br><span class="line">    &#123;</span><br><span class="line">       第一种创建上下文方式： 使用有参构造（推荐），在program.cs里面注册之后，会将options传递给DbContextOptions类，然后再通过有参构造传递给DbContext类，因为DbContextOptions不需要在其他地方使用，所以不必创建一个新的变量来接收.使用泛型是因为表示该参数将接收哪个配置项，因为可能会有来自MyDbContext2的options传递给base(options)</span><br><span class="line">        public MyDbContext(DbContextOptions&lt;MyDbContext&gt; options):base(options)</span><br><span class="line">        &#123;</span><br><span class="line">        //这是efcore之前的数据库初始化策略。core之后用context.Database.EnsureCreated()</span><br><span class="line">        DataBase.SetInitializer(new DropCreateDataBaseIfModelChanges&lt;MyDbContext&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        //重写OnModelCreating方法,进行fluentapi配置：https://www.cnblogs.com/wyy1234/archive/2018/09/18/9670529.html</span><br><span class="line">​        protected override void OnModelCreating(ModelBuilder modelBuilder)</span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​            base.OnModelCreating(modelBuilder);</span><br><span class="line">​            //fluentapi配置</span><br><span class="line">​        &#125;</span><br><span class="line">        public DbSet&lt;Book&gt; Books &#123; get; set; &#125;//用来说明数据库中有Book类的表，如果还有其他类就再写一个DbSet</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">//然后在program.cs文件里面进行注入，进行配置，这是一种注册的语法糖，实际上底层仍然使用的SCope进行注册，目的是将MyDbContext进行注册，以方便后面所有的操作都是使用的MyDbContext类（Dbcontext注册不能使用Singleton，因为efcore是非线程安全的，）</span><br><span class="line">        services.AddDbContext&lt;MyDbContext&gt;(options=&gt;&#123;options.usesqlserver(&quot;连接字符串&quot;,b=&gt;b.MigrationAssemble(&quot;program.cs所在的项目名&quot;))&#125;)//另一种写法：services.AddDbContext&lt;MyDbContext&gt;(options=&gt;&#123;options.usesqlserver(builder.Configuration.GetConnectionString(&quot;ConnectionString&quot;);通过方法去获取json数据</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> fluent使用方式:1.引入nuget包定义一个类继承于IEntityTypeConfiguration接口，里面进行fluent配置，然后在onModelCreating里面调用该配置类即可（推荐（https://blog.csdn.net/Fanbin168/article/details/79603230））。2.也可以将fluentapi直接写在onmodelcreating里面（https://www.cnblogs.com/wyy1234/archive/2018/09/18/9670529.html），但是一旦类比较多，就显得臃肿，所以对于每个类的配置，写自己的配置类继承IEntityTypeConfiguration</span><br><span class="line"> public class PostConfiguration : IEntityTypeCOnfiguration&lt;Post&gt;</span><br><span class="line"> &#123;</span><br><span class="line"> //第一种，引入Configure方法</span><br><span class="line"> public void Configure(EntityTypeBuilder&lt;Post&gt; builder);</span><br><span class="line"> //进行fluent配置</span><br><span class="line"> builder.property(x=&gt;x.Title).IsRequired().HasMaxLength(100);</span><br><span class="line"> //第二种：直接使用PostConfiguration的构造方法</span><br><span class="line"> public PostConfiguration()</span><br><span class="line"> &#123;</span><br><span class="line"> ToTable(&quot;Posts&quot;);</span><br><span class="line"> HasKey(t=&gt;t.Id);</span><br><span class="line"> Property(x=&gt;x.id).HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);//设置主键自增长</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public class PersonConfiguration : IEntityTypeCOnfiguration&lt;Person&gt;</span><br><span class="line"> &#123;</span><br><span class="line"> public void Configure(EntityTypeBuilder&lt;Person&gt; builder);</span><br><span class="line"> //进行fluent配置</span><br><span class="line"> builder.property(x=&gt;x.name).IsRequired().HasMaxLength(100);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>class MyDbContext:DbContext    {       //第二种创建上下文：使用无参构造 （不推荐，因为无法将连接字符串写死了）：重写OnConfiguring方法，将数据库连接配置在这个方法里面    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)    {        base.OnConfiguring(optionsBuilder);        //配置连接字符串        optionsBuilder.UseSqlServer(&quot;数据库连接字符串&quot;);    }    //重写父类方法,用来进行键映射，可以进行fluent api的配置。    protected override void OnModelCreating(ModelBuilder modelBuilder)    {//同上    }       public DbSet&lt;Book&gt; Books { get; set; }//用来说明数据库中有Book类的表，如果还有其他类就再写一个DbSet</code></pre><p> 3.判断是否需要创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.DataBase.EnsureCreate();若数据库已存在，则不处理，若不存在，则创建数据库</span><br></pre></td></tr></table></figure><p>4.数据库迁移Migration</p><p>nuget安装microsoft.entityframework.tools</p><p>运行add-migration即可生成建表语句，但是为了留下数据库操作记录，自己需要添加一个变量名 例如</p><p>add-migration init后面的init就是一个变量民以方便查看，实际上执行命令的是add-migration,然后执行update-database才表示建表命令执行</p><h3 id="数据库初始化策略"><a href="#数据库初始化策略" class="headerlink" title="数据库初始化策略"></a>数据库初始化策略</h3><p>​        方式1：如果数据库不存在，就创建（不推荐）context.Database.EnsureCreated()<br>​        方式2：总是创建数据库，无论存在与否(不推荐)context.Database.EnsureDeleted()+context.Database.EnsureCreated()</p><p>​确保删除：确保删除context.Database.EnsureDeleted()</p><h3 id="主键，外键，索引的区别"><a href="#主键，外键，索引的区别" class="headerlink" title="主键，外键，索引的区别"></a>主键，外键，索引的区别</h3><p><a href="https://www.cnblogs.com/xxeleanor/p/15024557.html">https://www.cnblogs.com/xxeleanor/p/15024557.html</a></p><h1 id="UnitOfWork工作单元"><a href="#UnitOfWork工作单元" class="headerlink" title="UnitOfWork工作单元"></a>UnitOfWork工作单元</h1><p>它是对efcore的一种封装，使用起来更加好用，需要引用efcore autohistory包</p><p>定义仓库，让其继承repository和irepository</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每个仓库都进行该操作，实际上引用了反射</span><br><span class="line">public class TodoRepository : Repository&lt;Todo&gt;, IRepository&lt;Todo&gt;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        public TodoRepository(MyTodo3DbContext dbContext) : base(dbContext)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下载unitofwork文件：具体使用可参考arch的unitofwork的readme部分。</p><h2 id="FlentApi总结："><a href="#FlentApi总结：" class="headerlink" title="FlentApi总结："></a>FlentApi总结：</h2><p>0.对每个属性配置的时候都要使用Property(x&#x3D;&gt;x….)。。。</p><p>1.设置表名：modelBuilder.Entity《Blog》.ToTable(“Blogs”);</p><p>2.手动配置主键：modelBuilder.Entity《BLog》().HasKey(k&#x3D;&gt;k.Id);(注：若主键为int且值为手动分配，则需显示指定非标识列modelBuilder.Entity《BLog》().HasKey(k&#x3D;&gt;k.Id).Property(p&#x3D;&gt;p.Id).HasDatabaseGenerateOption(DataBaseGeneratedOption.None);)</p><p>3.数值类型转换（C#中类型与数据库类型手动匹配时，都是通过HasColumeType进行设置）</p><p>使用hasColumeType()进行设置（同下）</p><p>4.字符串类型转换：</p><p>string默认转换为nvarchar(Max)</p><p>modelBuilder.Entity《BLog》().Property(p&#x3D;&gt;p.Name).HasColumeType(“varchar”).hasMaxlength(50);</p><p>modelBuilder.Entity《BLog》().Property(p&#x3D;&gt;p.Name).HasColumeType(“varchar”).isMaxLength();&#x2F;&#x2F;设置为最大长度</p><p>5.设置为字符串类型不可为null，和可为null（对于值类型，默认就是IsRequired的，对于引用类型，需要显示配置为null）</p><p>modelBuilder.Entity《BLog》().Property(p&#x3D;&gt;p.Name).IsRequired();</p><p>modelBuilder.Entity《BLog》().Property(p&#x3D;&gt;p.Name).IsOptional();</p><p>6.修改日期类型</p><p>默认为Date类型</p><p>modelBuilder.Entity《BLog》().Property(p&#x3D;&gt;p.CreateTime).HasColume(“DATETIME2”);</p><p>7.复杂类型映射：</p><p>对于User中有个Address类型，若Address中没有主键配置，则Address的属性会映射为User表中的字段，名称为Address_属性名,即两个类对应一个表，一旦Address有自己的id主键，则建表时会创建两个表，两个表之间有映射。</p><p>但是添加User对象时，必须也将Address创建对象，否则报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var user = new User()</span><br><span class="line">&#123;</span><br><span class="line">name=&quot;&quot;;</span><br><span class="line">Address = new Address()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.创建索引：</p><p>使用HasIndex(p&#x3D;&gt;p.name);</p><p>9.设置主键：HasKey(x&#x3D;&gt;x.id);</p><p>10：设置自增</p><pre><code>Property(x=&gt;x.id).HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);//设置主键自增长</code></pre><p>11.关系配置</p><p>​一对一关系配置(Student与Contact类一对一)：HasOptional(x&#x3D;&gt;)x.Contact.WithRequired(m&#x3D;&gt;m.Student)(这是ef不是efcore)</p><p><strong>以下都是根据dbfirst开发方式进行的。</strong></p><p>context.cs的DbSet里面里面写了很多增删改查的方法，即DbFirstEntitiels简称**<font color="red">上下文类，这在程序中是核心</font>**，在程序中调用的所有的方法都是上下文类中的方法。</p><p><img src="/2026/01/29/ef%E5%AD%A6%E4%B9%A0/assets/%E6%8D%95%E8%8E%B72.jpg" alt="捕获2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//分页查询：需要三个参数1.当前页 2.每一页的个数 3.总页数，每一页可以显示的页码数</span><br><span class="line">//pageIndex:查询结果中表示跳过的页数</span><br><span class="line">//pageSize:查询结果中表示每页的个数</span><br><span class="line">static void pageQuery(int pageIndex,int pageSize) &#123;</span><br><span class="line">    using (var db= new DbFirstEntities()) &#123; </span><br><span class="line">        //查询前必须进行排序，使用linq进行分页</span><br><span class="line">        var result = db.Student.OrderBy(s =&gt; s.Id).Skip((pageIndex - 1) * pageSize).Take(pageSize).ToList();//这是固定的</span><br><span class="line">        foreach (var item in result)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item.Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：</p><p>1.<font color="red">对数据的修改只是修改了内存中的数据，想要修改数据库中的数据的画必须使用savachangesAsync()方法，自然增删改查也就需要使用savechangesAsync()方法。</font>&gt;实际上调用增删改查的语句执行对某个表进行了状态的表示。Add()是告诉数据库在添加的时候执行什么对应的sql命令，而savechanges（）方法是检测到实体对象改变了，告诉数据库开始执行对应的命令。操作里面的表进行增删改查，查询方法后面必须使用firstOrdefault或者tolist才会执行，增加删除修改必须调用savechanges方法</p><p>2.ef也提供了可以使用sql语句进行操作的方法；数据库上下文对象.database.executesqlcommand(“sql语句”);</p><h3 id="延迟加载：用到数据的时候才会进行加载"><a href="#延迟加载：用到数据的时候才会进行加载" class="headerlink" title="延迟加载：用到数据的时候才会进行加载"></a>延迟加载：用到数据的时候才会进行加载</h3><p>当浏览图片时，图片较多，当滚动条滚动到对应位置图片才会加载显示，只有用到数据的时候才会进行加载。默认情况下ef启用延迟加</p><p>载，可以手动关闭。</p><p>延迟加载，它的导航属性必须加上virtual关键词</p><p>延迟加载必备的三个条件：</p><p>1.Configuation.ProxyCreationEnable&#x3D;true;</p><p>2.Configuration.LazyLoadingEnable&#x3D;true;</p><p>3.导航属性修饰符为Virtual</p><h3 id="饥饿加载："><a href="#饥饿加载：" class="headerlink" title="饥饿加载："></a>饥饿加载：</h3><p>一般设计到子父类，当父类加载的同时子类也进行加载.使用Include()方法。例如</p><p>MyDbContext.Customes.Include(d&#x3D;&gt;d.post).FirstOrDefault();</p><p>若后续还有子类MyDbContext.Customes.Include(“Orders”).ThenInclude(c&#x3D;&gt;c.aaa)</p><h3 id="显示加载：禁用延迟加载后可以使用显示加载进行延迟执行"><a href="#显示加载：禁用延迟加载后可以使用显示加载进行延迟执行" class="headerlink" title="显示加载：禁用延迟加载后可以使用显示加载进行延迟执行"></a>显示加载：禁用延迟加载后可以使用显示加载进行延迟执行</h3><p>解决关闭延迟加载后通过显示加载来延迟加载相关实体</p><p>快照式变更追踪：自动启用</p><p>代理式变更追踪:没什么用</p><p>context.Entry(…)的形式。</p><h3 id="一对多，多对多-一对一"><a href="#一对多，多对多-一对一" class="headerlink" title="一对多，多对多,一对一"></a>一对多，多对多,一对一</h3><p>官方文档 <a href="https://learn.microsoft.com/zh-cn/ef/core/modeling/relationships?tabs=fluent-api,fluent-api-simple-key,simple-key">https://learn.microsoft.com/zh-cn/ef/core/modeling/relationships?tabs=fluent-api%2Cfluent-api-simple-key%2Csimple-key</a></p><p>hasXXX().withYYY()表示A实体有xxx个B，B实体有YYY个A对象。XXX和YYY有one和Many两个可选值</p><p><strong>导航属性</strong>：就是将其他类作为本类中的字段，分为单向导航，和多向导航<a href="https://www.shuzhiduo.com/A/amd0m61Xzg/">https://www.shuzhiduo.com/A/amd0m61Xzg/</a></p><p>为什么同时需要外键和导航属性：<a href="https://blog.csdn.net/wsnbbdbbdbbdbb/article/details/122285977">https://blog.csdn.net/wsnbbdbbdbbdbb/article/details/122285977</a></p><p>**单向导航：**比如用户类可能被多个其他的类作为属性，这个情况我们只需要在多的里面声明用户类即可，不必在用户类中声明所有的调用者，fluentapi配置的时候不需要在withmany指定属性即可</p><p><strong>多向导航</strong>：一对多或者多对多中只有该两者之间关系比较密切，比如用户类只作为一个类的属性，不会作为其他类的属性</p><p>例如前面创建表时如果字段是引用类型则不会映射到数据库中，在ef中这就是一对多，多对多。实际上就是外键。并且使用【Foreignkey】修饰，或者使用fluentapi</p><p>在类中配置完外键之后，还需要使用fluentapi进行配置，两表之间的配置选择任意一个即可，对于单向导航，只能配置在一方</p><p>在实际项目开发中，对于主从结构的一对多一般声明为双向导航，其他的比如被很多表引用的基础表，都是用单向导航</p><p><img src="/2026/01/29/ef%E5%AD%A6%E4%B9%A0/assets/image-20230401092454204.png" alt="image-20230401092454204"></p><p><strong>一对一</strong>:（最复杂）在学生中添加简历字段，同时在简历中添加学生字段</p><p>在一对一中，必须显式的在类中声明一个外键属性</p><p>例如学生和简历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;</span><br><span class="line">int id,</span><br><span class="line">string name,</span><br><span class="line">int resumeId,//一对一中，必须显示指定外键HasForeignKey(c=&gt;c.StudentId)</span><br><span class="line">Resume resume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Resume&#123;</span><br><span class="line">int id,</span><br><span class="line">int studentId,</span><br><span class="line">Student student&#125;</span><br><span class="line">然后使用hasone().withone()进行配置</span><br></pre></td></tr></table></figure><p><strong>一对多（多对一）</strong>：例如一个班级对应多个学生，一个学生对应一个班级（分别从班级和学生的角度看）。</p><p>一对多中，会自动生成外键，所以可以不必显式指定外键</p><p>class{id,name ,List&lt;Student》}</p><p>Student{id,name,age,class}(学生的外键是班级id)&#x2F;&#x2F;学生表</p><p>在类中添加完外键后，需要使用fluentapi设置配置：在onmodelcreating中进行设置，，配置可以放在任意一方</p><p>例如</p><p>在A实体类中配置builder.HasOne&lt;B》(c&#x3D;&gt;c.B).withMany(d&#x3D;&gt;d.A）表示A和B是一对多的关系，lambda表达式c.B中的B属性是对应B实体的。</p><p>builder.entity&lt;Post》().Hasone(P&#x3D;&gt;P.Blog).withMany(b&#x3D;b.post).HasForignkey(p&#x3D;&gt;p.blogForeignkey)</p><p>使用的hasone().withmany();或者hasmany().withOne()的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一对多</span><br><span class="line">//班级表</span><br><span class="line">public class Class</span><br><span class="line">&#123;</span><br><span class="line">public long id;</span><br><span class="line">public string name;</span><br><span class="line">public List&lt;Student&gt; list;//如果是一对多，在一里面使用集合作为导航属性，在多里面使用类为导航属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//学生表</span><br><span class="line">public class Stduent</span><br><span class="line">&#123;</span><br><span class="line">public long id;</span><br><span class="line">public string name;</span><br><span class="line">public long? classid;//默认约定：以类名+Id作为外键，对应下面的Class引用类型，也可以不写，数据库生成时会自动生成一个classid字段，若需要获取外键值，则可以手动添加上该外键。如果有想要单独获取外键的需求，可以使用类名+id的形式，如果没有该需求，可以不用写，efcore会在数据库中自动生成，若在类中定义了外键，那么就要使用fluentapi进行关系配置。</span><br><span class="line">//增加一个Class班级引用类型字段,外键必须使用virtrual修饰</span><br><span class="line">public Virtural Class Class;//在多里面使用一中的类作为导航属性</span><br><span class="line">public int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类中创建班级对象之后直接往Student的Class字段中直接赋值即可。</span><br><span class="line">//上面默认使用类名+Id作为外键后需要使用fluentapi指定外键为ClassId</span><br><span class="line">class StudentConfig : IEntityTypeConfiguration&lt;Student&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public void Configure(EntityTypeBuilder&lt;Student&gt; builder)</span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(&quot;T_Student&quot;);</span><br><span class="line">            this.HasRequried(e=&gt;e.Class).WithMany().HasForeignKey(e=e.ClassId);//一个学生必须有一个班级，一个班级有多个学生，外键为Classid</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>**多对多：**多个老师对应多个学生（此时需要引入一个中间表）</p><p>Student{id,name,age,classid,list}&#x2F;&#x2F;学生表体现出一对多</p><p>teacher{id,name,phoneNum,list}&#x2F;&#x2F;老师表体现出一对多</p><p>studentTeacher{studentid,teacherid}&#x2F;&#x2F;中间表引入上面两个（可以省略，但不建议省略）</p><p>同样使用fluentapi在任意一方进行配置，使用的hasmany(),withmany()的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">多对多</span><br><span class="line">public class Teacher</span><br><span class="line">&#123;</span><br><span class="line">public int id;</span><br><span class="line">public string name;</span><br><span class="line">public string sex;</span><br><span class="line">public List&lt;Student&gt; list;//体现一对多</span><br><span class="line">&#125;</span><br><span class="line">public class Student</span><br><span class="line">&#123;</span><br><span class="line">public int id;</span><br><span class="line">public string name;</span><br><span class="line">public string sex;</span><br><span class="line">public string score;</span><br><span class="line">public List&lt;Teacher&gt; list;//体现一对多</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//中间表；只需要两者的id即可</span><br><span class="line">public class TeacherStudent</span><br><span class="line">&#123;</span><br><span class="line">public int teacherId;</span><br><span class="line">public int Stduentid;</span><br><span class="line">public Teacher teacher;</span><br><span class="line">public Student student;</span><br><span class="line">&#125;</span><br><span class="line">使用fluentapi：</span><br><span class="line">modelbuilder.entity&lt;PostTag&gt;().HasOne(pt=&gt;pt.Post).withmany(p=&gt;p.posttags).hasforiegn(pt=&gt;pt.postId)</span><br><span class="line">modelbuilder.entity&lt;PostTag&gt;().HasOne(pt=&gt;pt.Tag).withmany(t=&gt;t.posttags).hasforiegn(pt=&gt;pt.TagId)</span><br></pre></td></tr></table></figure><p>**映射方法：**以下都是使用fluentapi进行配置</p><p>1.hasOptional();&#x2F;&#x2F;有一个或者没有</p><p>2.hasRequired();&#x2F;&#x2F;有一个必须的</p><p>3.hasmany（）；&#x2F;&#x2F;有很多的</p><p>4.withoptional();&#x2F;&#x2F;反向的有一个或者没有</p><p>5.withrequired()；&#x2F;&#x2F;反向必须的</p><p>6.withmany();&#x2F;&#x2F;反向有很多的。</p><p>举例：在A实体中配置：this.HasRequred(p&#x3D;&gt;p.B).withMany();&#x2F;&#x2F;表示在A中有一个B，在B中有多个A；满足一对多</p><p>​在A实体中配置：this.HasRequired(p&#x3D;&gt;p.B).withReuqired();&#x2F;&#x2F;表示A中一个B，B中有一个A：满足一对一</p><h3 id="获取关联数据："><a href="#获取关联数据：" class="headerlink" title="获取关联数据："></a>获取关联数据：</h3><p>例如获取id&#x3D;&#x3D;3的班级及其学生</p><p>db.Student.Include(a&#x3D;&gt;a.class).single(a&#x3D;&gt;a.id&#x3D;&#x3D;1);</p><h3 id="添加关联数据"><a href="#添加关联数据" class="headerlink" title="添加关联数据"></a>添加关联数据</h3><p>班级中添加学生0 </p><p>class c1 &#x3D; new class();</p><p>Student s1 &#x3D; new Student(“张三”);</p><p>Student s2&#x3D; new Student(“李四”);</p><p>c1.Students.Add(s1);</p><p>c1.Students.Add(s2);</p><p>await db.savechangesAsync();</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>例如Blog里面有Post属性,Post里面有Author属性</p><p>context.Blogs.Include(blog&#x3D;&gt;blog.Posts).ThenInclude(Post&#x3D;&gt;Post.Author).ToList();</p><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>var blogsLike &#x3D; blogs.where(d&#x3D;&gt;EF.Functions.Like(d.name,”abcd”))；查询名字以abcd开头</p><h3 id="efcore中的特性设置"><a href="#efcore中的特性设置" class="headerlink" title="efcore中的特性设置"></a>efcore中的特性设置</h3><p><strong>排除映射，排除实体</strong></p><p>方法1.【notmapped】或者【ignore】；用到类上就不会映射成表，用到属性上就不会映射对应的属性</p><p>2.fluentapi中设置 modelbuilder.entity《blog》().ignore(b&#x3D;b.loadedfromdatabase);</p><p>注意：日期需要单独设置【datatype(DataType.Date)】</p><p><strong>主键</strong></p><p>1.【key】</p><p>2.fluentapi中设置modelbuilder.entity《blog》().haskey(c&#x3D;new {c.state,c.licenseplate});</p><p><strong>映射成表</strong></p><p>1.DBSet《BLog》 blog{get;set}</p><p>2.modelbuilder.entity《blog》();</p><p><strong>改列名</strong>、字段</p><p>【column(“blog_id”)】</p><p>modelbuilder.entity《blog》().property(b&#x3D;&gt;b.BlogId).HasColumnName(“blog_id”);</p><p><strong>该列的长度</strong></p><p>【column(typename&#x3D;”varchar(200)”)】</p><p>modelbuilder.entity《blog》().property(b&#x3D;&gt;b.BlogId).HasColumnType(“varchar(200)”).isrequired();</p><p>【minlength】最小长度【maxlength】最大长度</p><p>【stringlength】最大、最小长度</p><p>【table】：设置表明及表的结构</p><p>【index】配置该列为索引</p><p>【foreignkey】：该列为外键</p><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>查询不需要执行savechanges方法</p><p>tolist();</p><p>where();</p><p>find();</p><p>First();</p><p>FirstOrDefault();</p><p>single();&#x2F;&#x2F;查询一条</p><p>singleOrdefault();</p><p>last();</p><p>select();</p><p>LastOrdefault();</p><p>count();</p><p>LongCount();</p><p>min()</p><p>Max();</p><p>Average();</p><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><p>conext.entity.add();</p><p>context.savechanges();</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>context.dbset《entity》.remove(object)();</p><p>context.savechanges();</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>context.dbset《entity》.update(object);</p><p>context.savechanges();</p><h2 id="仓储模式"><a href="#仓储模式" class="headerlink" title="仓储模式"></a>仓储模式</h2><p>优点：1.依赖注入要用泛型所以使用仓储。尽量使用scoped进行注入</p><p>​2.仓储模式不固定服务于某个数据库，所以只需要进行简单的更改即可更换数据库例如之前使用的是sqlserver，那么注入时就是用</p><p>services.AddScoped《IStudentRepository，SqlStudentRepository》（）；即可</p><p>现在更换到Oracle，只需要注入时修改为services.AddScoped《IStudentRepository，OracleStudentRepository》()；</p><p>​3.若50个实体类，则需创建100个类文件，比较枯燥，所以使用泛型仓储。</p><p>​4.推荐使用异步操作</p><p>​5.Controller里面不应该有DbContext，所以将其封装在Repository里面</p><p>有两种方式实现仓储：</p><p>1.每个实现类对应一个接口，则50个实现类有50个接口，并且一一对应，而且每个接口和每个实现类都要自己写一遍</p><p>2.节约代码。即首先创建一个IRepositoryBase接口和RepositoryBase实现类，里面为通用方法，实现类实现接口中的方法。，然后创建其他的接口和实现类，仍然是一一对应，但是所有接口都实现IRepositoryBase接口，这样就只需要写自己独有的方法，同理所有的实现类继承RepositoryBase类和自己的接口，这样只需要实现自己接口中的方法。大量节约了代码</p><p>步骤：1.创建两个文件IRepository (约定)和RepositoryBase（通用功能）</p><p>举例</p><p>&#x2F;&#x2F;查询,里面封装了几乎所有方法，在使用的时候，我们只需要挑选异步的，并且选择合适的即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">public interface IRepository&lt;T1,T2&gt; where T1:Class //T1为类，T2为主键类型</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​IQueryable&lt;T1&gt; GetAll();</span><br><span class="line"></span><br><span class="line">​List&lt;T1&gt; GetAllList();</span><br><span class="line"></span><br><span class="line">​Task List&lt;List&lt;T1&gt;&gt; GetAllListAsync();</span><br><span class="line"></span><br><span class="line">​LIst&lt;T1&gt; GetAllList(Expression&lt;Expression Fuc&lt;T1,bool&gt;&gt; f2)</span><br><span class="line"></span><br><span class="line">   Task List&lt;LIst&lt;T1&gt;&gt; GetAllListAsync(Expression&lt;Fuc&lt;T1,bool&gt;&gt; f2)</span><br><span class="line"></span><br><span class="line">​T1 Single(Expression&lt;Func&lt;T1,bool&gt;&gt; f2);</span><br><span class="line"></span><br><span class="line">​Task&lt;T1&gt; SingleAsync(Expression&lt;Func&lt;T1,T2&gt;&gt; f2);</span><br><span class="line"></span><br><span class="line">​T1 FirstOrDefault(Expression&lt;Func&lt;T1,bool&gt;&gt; f2);</span><br><span class="line"></span><br><span class="line">​Task&lt;T1&gt; FirstOrDefaultAsync(Expression&lt;Func&lt;T1,bool&gt;&gt; f2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line"></span><br><span class="line">Task&lt;T1&gt; InsertAsync(T1 t1)</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line"></span><br><span class="line">Task&lt;T1&gt; UpdateAsync（T1 t1）；</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"></span><br><span class="line">Task DeleteAsync(T1 t1)</span><br><span class="line"></span><br><span class="line">Task DeleteAsycn(Expression&lt;Func&lt;T1，bool&gt;f2&gt;)</span><br><span class="line"></span><br><span class="line">//总数</span><br><span class="line"></span><br><span class="line">Task&lt;int&gt; CountAsync();</span><br><span class="line"></span><br><span class="line">//其他通用方法</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RepositoryBase实现</span><br><span class="line"></span><br><span class="line">public class RepositoryBase&lt;T1,T2&gt;:IRepository&lt;T1,T2&gt; where T1:class</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​//注入</span><br><span class="line"></span><br><span class="line">protectd readonly AppDbContext _dbContext;</span><br><span class="line"></span><br><span class="line">public virtual DbSet&lt;T1&gt; Table= _dbContext.Set&lt;T1&gt;();</span><br><span class="line"></span><br><span class="line">public RepositoryBase(AppDbContext dbContext)</span><br><span class="line"></span><br><span class="line">​&#123;</span><br><span class="line"></span><br><span class="line">​_dbContext = dbContext；</span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line"></span><br><span class="line">IQueryable&lt;T1&gt; GetAll()</span><br><span class="line"></span><br><span class="line">​&#123;</span><br><span class="line"></span><br><span class="line">​return Table.Queryable();</span><br><span class="line"></span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​Task List&lt;List&lt;T1&gt;&gt; GetAllListAsync()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​return await GetAll().ToListAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Task List&lt;LIst&lt;T1&gt;&gt; GetAllListAsync(Expression&lt;Fuc&lt;T1,bool&gt;&gt; f2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​return await GetAll().where(f2).ToListAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​Task&lt;T1&gt; SingleAsync(Expression&lt;Func&lt;T1,T2&gt;&gt; f2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​return await GetAll().SingleAsync(f2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​Task&lt;T1&gt; FirstOrDefaultAsync(Expression&lt;Func&lt;T1,bool&gt;&gt; f2)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​return await GetAll().FirstOrDefaultAsync(f2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//添加</span><br><span class="line"></span><br><span class="line">Task&lt;T1&gt; InsertAsync(T1 t1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​var newentity = await Table.AddAsync(t1);</span><br><span class="line"></span><br><span class="line">​await saveAsync();</span><br><span class="line"></span><br><span class="line">return newentity.entity();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修改(同步省略了)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​public async Task&lt;T1&gt; updateAsync(T1 t1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​AttachIfNot(t1);</span><br><span class="line"></span><br><span class="line">​Table.update(t1);</span><br><span class="line"></span><br><span class="line">​await saveAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除(同步省略了)</span><br><span class="line"></span><br><span class="line">Task DeleteAsync(T1 t1)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​AttachIfNot(t1);</span><br><span class="line"></span><br><span class="line">​Table.Remove(t1);</span><br><span class="line"></span><br><span class="line">​await saveChangeAsync();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Task DeleteAsycn(Expression&lt;Func&lt;T1，bool&gt;f2&gt;)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​foreach(var entity in GetAll().where(f2).ToList())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​await DeleteAsync(t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后让其他类通过结成RepositoryBase的方式提供泛型类即可。</span><br><span class="line">例如ShopRepository&lt;Shop1,Shop2&gt;:RepositoryBase&lt;Shop1,Shop2&gt;//泛型仅起到占位符的作用，并不是通过创建对象的方式传给泛型</span><br><span class="line">&#123;</span><br><span class="line">public ShopRepository(...):Base(...)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乐观锁悲观锁解决并发冲突"><a href="#乐观锁悲观锁解决并发冲突" class="headerlink" title="乐观锁悲观锁解决并发冲突"></a>乐观锁悲观锁解决并发冲突</h2><p>并发冲突：当客户端同时两个或者两个以上的请求，同时读取并修改同一个数据时叫做并发冲突</p><p>解决问题：为了解决多个用户同时访问同一个资源引起的并发冲突</p><p>悲观锁：将资源锁定，确保只有一个使用者操作被锁定的资源。（使用简单）</p><p>乐观锁：允许多个用户同时访问，通过检测避免算法避免冲突，导致最后一条记录被保存。推荐使用 （使用较难，但是ef底层默认使用乐观并发）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决一种特殊情况</span><br><span class="line">方式1：通过检测主键之外实体的属性检测并发冲突</span><br><span class="line">Property(p=&gt;p.Name).IsConcurrencyToken();</span><br><span class="line">方式2:设置行版本：添加一个字节数组</span><br><span class="line">public byte[] RowVersion&#123;get;set;&#125;</span><br><span class="line">Property(p=&gt;p.RowVersion).IsRowVersion();</span><br></pre></td></tr></table></figure><p>出现并发异常的解决办法就是如何处理异常并重试</p><p>中级版本1客户端获胜2数据库获胜3合并获胜</p><p>高级版本：使用Polly重试策略《你必须掌握的ef6与efcore2.0》p227</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>1.使用Dbcontext的DataBase.log属性打印到控制台</p><p>​context.DataBase.log &#x3D; Console.WriteLine();</p><p>2.打印到文件里面</p><p>var sw &#x3D; new StreamWriter(@”d:\data.log”){AutoFlush&#x3D;true};</p><p>context.DataBase.Log &#x3D; s&#x3D;&gt;{sw.write(s</p><p>)}</p><p>3.结构化输出：</p><p>​继承自DatabaseLogFormatter的类</p><p>以上都只能在demo中使用，下面的是在正规项目中使用</p><p>4.使用Nlog的IDbInterceptor接口：参考《你必须掌握的enitityframework6.x与2.0》p171</p><p>前期未使用日志，后期可以通过配置文件加上，不必关闭服务器参考《你必须掌握的enitityframework6.x与2.0》p172</p><h4 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h4><p>使用拦截器监控sql的性能</p><p>方式1：实现IDbCommandInterceptor接口</p><p>方式2：实现DbCommandInterceptor类</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>将数据插入多个表中时，如果对其中一个表插入数据失败，就应该回滚其他事务（增删改需要，查询不需要）</p><p>案例说明事务：从银行账户A转移到B账户，一是从A账户提取金额，二是将金额存入账户B中。假设进程1成功，但进程二失败，那么这些钱将从A中扣除，但不会存在B账户。此时通过事务来完成操作，事务就是将一系列操作作为整体处理，要么全部成功，要么全部失败</p><h3 id="连接弹性"><a href="#连接弹性" class="headerlink" title="连接弹性"></a>连接弹性</h3><p>由于网络超时，死锁导致操作中断，此时需要重新打开连接数据库并重试进行操作。连接弹性就是自动完成这种重试操作</p><p>ef自带的四种重试策略：setExecutionStrategy(…)不够强大·。使用Polly库</p><h3 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h3><p>builder.Hasone( m&#x3D;&gt;m.Contact).WithOne(p&#x3D;&gt;p.Student).HasForeignKey<StudentContact>(k&#x3D;&gt;k.Id).OnDeletee(DeleteBehavior.Cascade);</StudentContact></p><p>​Restrict:只删除主体，依赖实体不变</p><p>​SetNull;依赖实体中的外键属性设为null</p><p>​CasCade:相关实体也被删除</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>1.预编译视图：使用ef power tools，右击上下文文件，实体框架-》生成视图：第二种方法使用api（推荐），第三种方法：使用efinteractiveviews</p><p>2.关闭数据库初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class efconfiguration :dbconfiguration </span><br><span class="line">public efConfiguration()</span><br><span class="line">&#123;</span><br><span class="line">setDatabseInitializer(EfDbContext)(null);</span><br><span class="line">或者setDatabseInitializer(EfDbContext)(new NullDatabaseInitiallizer&lt;EfDbContext&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.5避免数据库版本查询</p><p>ef会每次都查询数据库的版本，若自己已知版本，则可以直接写死，使用Imanifesttoken类中的resolvemanifesttoken方法</p><p>3.安装ef程序集</p><p>4.AsNoTracking</p><p>使用savechanges时，会自动调用detectchanges方法对每个属性和数据库的值进行比较，继而保存，但是对于查询操作，我们不会对数据进行修改，所以使用AsNoTracking不对数据进行比对，节约时间。所以单单对于查询操作，可以使用AsNoTracking。</p><p>如何使用asnotracking 1.每次查询后面使用一次asNoTracking()</p><p>​2.直接在上下文中将AsNoTracking()为所有的查询开启，慎重</p><p>5.缓存</p><p>利用主键查询的时候，使用find方法而不是firstordefault或sigleordefault方法，因为find方法底层使用了缓存</p><p>6.避免导航查询重复查询导航项</p><p>Custom里面有个Order项，每次查询的Custom时候都会自动从数据库中查询Order，但是如果想要Custome里面的Order项，则必须再回数据库查询一下Custom的Order数据，重复操作，所以使用Include可以将Order放在缓存里面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.Customers.where(p=&gt;p.Name==&quot;jack&quot;).Include(d=&gt;d.Orders).ToList();</span><br></pre></td></tr></table></figure><p>7.添加索引</p><p>。。。</p><p>8.关闭detectchanges方法</p><p>对于插入操作，不需要进行数据对比，所以可以关闭detectchanges方法</p><p>9.批量插入时，不要循环对每个对象添加调用Add方法，而是将所有对象放在一个集合里面，然后使用Addrange方法进行批量插入</p><p>10.使用异步查询</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap</title>
      <link href="/2026/01/29/bootstrap/"/>
      <url>/2026/01/29/bootstrap/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;快捷键.test&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;test&quot;&gt;快捷键#test&lt;/div&gt;</span><br><span class="line">&lt;a href=&quot;&quot; class=&quot;test&quot;&gt;快捷键.test&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//nav.navbar.navbar-expand-lg.bg-dark</span><br><span class="line">&lt;nav class=&quot;navbar navbar-expand-lg bg-dark&quot;&gt;</span><br><span class="line">&lt;/nav&gt;</span><br><span class="line"></span><br><span class="line">//a.navbar-brand</span><br><span class="line">&lt;a href=&quot;&quot; class=&quot;navbar-brand&quot;&gt;我在b站玩编程&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">//div.collapse navbar-lollapse</span><br><span class="line">&lt;div class=&quot;collapse navbar-lollapse&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootstrap共包含3个容器。1.流体容器 2.固定容器 3.栅格容器</span><br><span class="line">bootstrap中的栅格布局</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/bootstrap.min.css&quot;&gt;引入css</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.container&#123;</span><br><span class="line">background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">div[class |=col]&#123;</span><br><span class="line">border: 1px solid;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;container&quot; &gt;使用之前设定容器为固定容器</span><br><span class="line">&lt;div class=&quot;row&quot; &gt;第一行，每一行默认为12列</span><br><span class="line">&lt;div class=&quot;col-lg-2&quot; style=&quot;height:100px&quot;&gt;col-lg-2&lt;/div&gt;这个div占用2列</span><br><span class="line">&lt;div class=&quot;col-lg-4&quot; style=&quot;height:100px&quot;&gt;col-lg-4&lt;/div&gt;这个div占用4列，其余空着，显示结果见下图1</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/bootstrap.js&quot;&gt;&lt;/script&gt;引入script</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1745925336496.png" alt="1745925336496"></p><center>图1</center><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">注意：lg(large)表示应用于大屏pc（&gt;=1200），md代表中屏pc(&gt;=992px~1200px)，sm代表平板(&lt;=768px~&lt;992px)，xs代表移动手机(&lt;768px)，。但是使用的时候一般是下面这样使用：以bootstrap官网为例（https://www.bootcss.com/），当窗体缩小一定程度，需要原本为为一行4个的图标变成了1行3个，再缩小，逐渐减小到1个，因此将代码改为如下部分</span><br><span class="line">&lt;div class=&quot;container&quot; &gt;使用之前设定容器为固定容器</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;第一行，每一行默认为12列</span><br><span class="line">下面的表示，当窗体为大屏时展现为1行4列，当窗体为中屏时展现为1行3列，当窗体为小屏时展现为1行2列（找到相加为12的那个，即col-lg-3），另外的数值就是用来显示列之间的比例的</span><br><span class="line">&lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot; col-sm-12&gt;col-lg-2&lt;/div&gt; </span><br><span class="line">&lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot; col-sm-12&gt;col-lg-4&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot; col-sm-12&gt;col-lg-4&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;col-lg-3 col-md-4 col-sm-6&quot; col-sm-12&gt;col-lg-4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">表示PC时为2列（相加为12，），手机时为1列，当转换为到1列时，上面的宽度与下面的宽度比为12：6=2：1，如下图所示</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-12 col-md-8&quot;&gt;.col-xs-12 .col-md-8&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">PC时为3列（col-md-4），手机时为2列（col-xs-6），且比例为1：1：1，如下图</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-6 col-md-4&quot;&gt;.col-xs-6 .col-md-4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1746003777674.png" alt="1746003777674"></p><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1746004091416.png" alt="1746004091416"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果在一个 .row 内包含的列（column）大于12个，包含多余列（column）的元素将作为一个整体单元被另起一行排列。如下图</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-9&quot; style=&quot;background-color: aquamarine;&quot;&gt;.col-xs-9&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-4&quot; style=&quot;background-color: skyblue;&quot;&gt;.col-xs-4&lt;br&gt;Since &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-xs-6&quot; style=&quot;background-color: orange;&quot;&gt;.col-xs-6&lt;br&gt;Subsequent columns continue along the new line.&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1746004437339.png" alt="1746004437339"></p><h2 id="删除槽"><a href="#删除槽" class="headerlink" title="删除槽"></a>删除槽</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">槽就是左右两侧的外框，默认未30px</span><br><span class="line">未删除槽如下图</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1746007183279.png" alt="1746007183279"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已删除槽如下图</span><br></pre></td></tr></table></figure><p><img src="/2026/01/29/bootstrap/Users\ghf\AppData\Roaming\Typora\typora-user-images\1746007168282.png" alt="1746007168282"></p><h2 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h2><p>看官网</p><h2 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">向后移动3列</span><br><span class="line">  &lt;div class=&quot;col-md-9 col-md-push-3&quot;&gt;.col-md-9 .col-md-push-3&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;col-md-3 col-md-pull-9&quot;&gt;.col-md-3 .col-md-pull-9&lt;/div&gt;向前移动9个</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2>2.bootstrap使用注意点：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引入boostrap文件时有两种引用方式1.静态引入（运行快，但需要提前下载） 2.网络资源引入（运行慢，但使用方便）</span><br><span class="line">方式1. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/bootstrap.min.css&quot;&gt;</span><br><span class="line">方式2. </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blazor</title>
      <link href="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/"/>
      <url>/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><code>Blazor Server</code> 托管模型具有以下优点：（网页文件都是cshtml类型，因为是服务端渲染）</p><ul><li>下载项大小明显小于 <code>Blazor WebAssembly</code> 应用，且应用加载速度快得多。</li><li>支持瘦客户端。 例如，<code>Blazor Server</code> 应用适用于不支持 <code>WebAssembly</code> 的浏览器以及资源受限的设备。</li><li>应用的 .NET&#x2F;C# 代码库（其中包括应用的组件代码）不适用于客户端。</li></ul><p><code>Blazor Server</code> 托管模型具有以下局限性：</p><ul><li>通常延迟较高。 每次用户交互都涉及到网络跃点。</li><li>不支持脱机工作。 如果客户端连接失败，应用会停止工作。</li></ul><p><code>Blazor WebAssembly</code> 托管模型具有以下优点：（网页文件都是razor类型，因为是客户端渲染）</p><ul><li>没有 .NET 服务器端依赖，应用下载到客户端后即可正常运行。</li><li>工作可从服务器转移到客户端。</li></ul><p><code>Blazor WebAssembly</code> 托管模型具有以下局限性：</p><ul><li><p>应用仅可使用浏览器功能。</p></li><li><p>需要可用的客户端硬件和软件（例如 <code>WebAssembly</code> 支持）。</p></li><li><p>下载项大小较大，应用加载耗时较长。</p><span id="more"></span></li></ul><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="项目目录："><a href="#项目目录：" class="headerlink" title="项目目录："></a><strong>项目目录：</strong></h2><p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/blazor/project-structure?view=aspnetcore-7.0">https://learn.microsoft.com/zh-cn/aspnet/core/blazor/project-structure?view=aspnetcore-7.0</a></p><p>shared：将自定义组件放在该文件夹（局部组件或者布局文件），该组件只对外提供属性和事件作为标签的属性的事件，使用parameter进行标注，而具体的事件绑定的方法是在page文件夹里面的文件进行逻辑书写,不需带路由</p><p>page：对外展示的整个页面放在该文件夹，需带路由（&#x2F;page）</p><p>_Import.Razor文件：引用razor使用的标签对应的类，例如input，editform等</p><p><strong>根据目录分析网页加载原理：</strong></p><p>首先网站加载后，首先加载的是wwwroot下的index.html文件，而不是index.razor组件，那么index.razor组件是如何嵌入到index.html里面去的呢？在index.html里面有这样一句话：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;定义了一个app的div</span><br></pre></td></tr></table></figure><p>然后在program.cs中，有builder.RootComponents.Add<App>(“#app”);这样一句话，说明将App这个组件嵌入到id为app的div中，而App.razor中有《Router AppAssembly&#x3D;”@typeof(App).Assembly”&gt;将加载page文件夹下的所有路由，并建立对应的路由表，当url匹配到对应的路由之后，就会将对应的razor文件嵌入到index.html的id为app的div中，运行之后通过查看源码可以查看到index.razor嵌入到index.html中</App></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.RootComponents.Add&lt;HeadOutlet&gt;(&quot;head::after&quot;);program.cs中的该行表示将HeadOutlet组件添加到index.html中的head标签的最后一行，该组件一般包含pagetitle组件等</span><br></pre></td></tr></table></figure><p>**通过反编译：**每个razor文件最后都会编译成cs类：例如index.razor&#x3D;&#x3D;index.cs文件&#x3D;&#x3D;index类，里面的@code{}等等，都是index类里面的内容。包括html标签，都会使用对象.方法的方式提交标签内容。例如_builder.addMarkupContent(1,”button”)将所有标签组合成一起后传送到前端。类似于javaservlet</p><p>支持异步</p><p>@+字段：调用c#中的属性</p><p>@+事件&#x3D;“方法名”；绑定到事件</p><p>@code{</p><p>​纯c#代码</p><p>}</p><p>事件绑定时如何使用lambda表达式：使用@()里面添加表达式</p><p>例如&lt;input @onclick&#x3D;”@(</p><p>​()&#x3D;&gt;{cw.writeLine(“lambda”);}</p><p>​ )”&gt;</p><p><strong>前后端分离</strong>将c#代码与razor代码分开，例如在index.razor所在文件夹中，创建一个index.razor.cs的类，会出现Index类报错，在public后添加partial即可</p><p>传统netcore转blazor：1.builder.AddServerSideBlazor2.app.MapBlazorHup()3.app.MapFallBackTopage(“&#x2F;.Host”)(BlazorServer)</p><p>blazor中的依赖注入与传统的构造方法注入不同，使用的是在最上部使用@inject Http http进行注入,传统注入是构造注入</p><p>第二种方式，创建一个组件+Base.cs的类，让其继承ComponentBase类也可前后分离，然后让前端的razor组件使用@inherit 组件Base即可。但是写法必须参照razor里面的@code的写法，例如注入使用【inject】的形式</p><h2 id="级联参数"><a href="#级联参数" class="headerlink" title="级联参数"></a><strong>级联参数</strong></h2><p>如果要将值传递给组件的直接子组件，可以使用组件参数。 当具有包含子组件的子组件的较深层次结构时，事情便会变得难以应付。 组件参数不会从上级组件或沿着层次结构向下自动传递到下级组件。 为了完美处理此问题，Blazor 包含了级联参数。 在组件中设置级联参数的值时，其值将自动提供给所有子组件。</p><p>(CascadingValue)：用来父组件与子组件之间传递参数的另一种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">@page &quot;/specialoffers&quot;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Special Offers&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;CascadingValue Name=&quot;DealName&quot; Value=&quot;Throwback Thursday&quot;&gt;</span><br><span class="line">    &lt;!-- Any descendant component rendered here will be able to access the cascading value. --&gt;</span><br><span class="line">&lt;/CascadingValue&gt;</span><br><span class="line">子组件中</span><br><span class="line">&lt;h2&gt;Deal: @DealName&lt;/h2&gt;</span><br><span class="line">@code &#123;</span><br><span class="line">    [CascadingParameter(Name=&quot;DealName&quot;)]</span><br><span class="line">    private string DealName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AppState传递参数"><a href="#AppState传递参数" class="headerlink" title="AppState传递参数"></a>AppState传递参数</h2><p>用于解决两个不相关的组件之间相互传递参数。</p><p>使用注入注册的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaSalesState</span><br><span class="line">&#123;</span><br><span class="line">    public int PizzasSoldToday &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">// Add services to the container</span><br><span class="line">builder.Services.AddRazorPages();</span><br><span class="line">builder.Services.AddServerSideBlazor();</span><br><span class="line"></span><br><span class="line">// Add the AppState class</span><br><span class="line">builder.Services.AddScoped&lt;PizzaSalesState&gt;();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@page &quot;/&quot;</span><br><span class="line">@inject PizzaSalesState SalesState</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Welcome to Blazing Pizzas&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Today, we&#x27;ve sold this many pizzas: @SalesState.PizzasSoldToday&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @onclick=&quot;IncrementSales&quot;&gt;Buy a Pizza&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">@code &#123;</span><br><span class="line">    private void IncrementSales()</span><br><span class="line">    &#123;</span><br><span class="line">        SalesState.PizzasSoldToday++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件引用"><a href="#组件引用" class="headerlink" title="组件引用"></a><strong>组件引用</strong></h2><p>例如《child @ref&#x3D;”@test”》 等价于在child test &#x3D; new child将组件看作对象，使用test.对象的形式访问子组件中的内容</p><p>**布局：**布局文件是一种特殊的组件，在布局文件中，在nav和footer中有个@body代码，该代码表示凡是使用@layout 应用该布局文件是会将代码填充到@body内容部分，若没使用@layout指定，则默认为@layout MainLayout.razor。布局文件两个特殊的要求。</p><ul><li>必须继承 <code>LayoutComponentBase</code> 类。@inherits LayoutComponentBase</li><li>必须在要呈现发起引用的组件内容的位置包含 <code>@Body</code> 指令。</li><li>若要使用组件则@layout BlazingPizzasMainLayout</li></ul><p>如果要将默认布局应用于 Web 应用的所有文件夹中的所有组件，可以在 App.razor 组件中执行此操作，可以像在第 2 单元中学到的那样，在该组件中配置 Router 组件。 在 <code>&lt;RouteView&gt;</code> 标记中，使用 <code>DefaultLayout</code> 属性。</p><p>**修改title和head内容：**因为默认是在index.html中，如果修改比较麻烦，对于单页面想要修改，则使用pagetitle组件修改title，使用headContent组件修改head部分，不必再再index.html中修改。</p><h2 id="数据链接"><a href="#数据链接" class="headerlink" title="数据链接"></a><strong>数据链接</strong></h2><p>实现父组件属性改变情况下子组件属性也改变，反之也可实现，传统方式无法实现即@bind-{Property},@bind-{Property}:event ,@bind-{Property}:get,@bind-{Property}:set</p><p>1.razor文件命名必须以大写字母开头</p><p>razor语法：<a href="https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-7.0">https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/razor?view=aspnetcore-7.0</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">参考官方文档</span><br><span class="line">1.下面这两种呈现的结果是一样的，里面既可以写html代码，也可以写c#代码</span><br><span class="line">@code &#123;</span><br><span class="line">    //这种方式用在blazor中的</span><br><span class="line">&#125;</span><br><span class="line">@&#123;</span><br><span class="line">//这种方式是在cshmlt中使用的，mvc中的razor，不要使用在blazor中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@&#123;</span><br><span class="line">    Student student = new Student &#123; Name = &quot;jerry&quot; ,age=20 &#125;;</span><br><span class="line">    public class Student</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125; = &quot;jerry&quot;;</span><br><span class="line">        public int age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;上面的代码等价于如下代码，及@&#123;&#125;中的代码放在一个类里面，该类名实际就是文件名</span><br><span class="line">public Test&#123;</span><br><span class="line">Student student = new Student &#123; Name = &quot;jerry&quot; ,age=20 &#125;;</span><br><span class="line">    public class Student</span><br><span class="line">    &#123;</span><br><span class="line">        public string Name &#123; get; set; &#125; = &quot;jerry&quot;;</span><br><span class="line">        public int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果想要输出@，就使用@@，若是电子邮件格式，则里面的@不会进行转义,其中name变量为jerry</span><br><span class="line">qq@Name.com会原样输出</span><br><span class="line">qq@@Name.com会输出为qq@Name.com</span><br><span class="line">qq@(Name).com会输出为qqjerry.com</span><br><span class="line">2.svg图像格式</span><br><span class="line">3.隐式razor表达式：就是使用@对象.变量名（面向对象）的方式代替@变量名的方式，但不能加上泛型，因为泛型中的&lt;&gt;会误判为html中的&lt;&gt;，若使用泛型，使用显式表达式</span><br><span class="line">4.显式razor表达式(建议全部使用显式的)：使用@();括号里面的内容是c#代码，括号外都是html代码</span><br><span class="line"> @(DateTime.Now - TimeSpan.FromDays(7))，显式表达式可以使用泛型</span><br><span class="line">5.表达式编码:htmlhelper不在学习范围内。</span><br><span class="line">6.在html里面写for循环</span><br><span class="line">@for (var i = 0; i &lt; people.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    var person = people[i];</span><br><span class="line">    &lt;text&gt;Name: @person.Name&lt;/text&gt;</span><br><span class="line">&#125;</span><br><span class="line">7.显式行转换（看见认识即可，不会使用）： @:Name: @person.Name 使用@:进行换行，等价于</span><br><span class="line">&lt;p&gt;Name: @person.Name&lt;/p&gt;</span><br><span class="line">8.控制语句if,else，循环结构：while，for，foreach</span><br><span class="line">9.@using:用来释放非托管资源</span><br><span class="line">10@try，catch</span><br><span class="line">11注释：ctrl+k+c</span><br><span class="line">12添加特性：Test.razor最终编译成一个Test类，及</span><br><span class="line">public Test&#123;</span><br><span class="line">...</span><br><span class="line">&#125;如何在它上面添加授权特性，就是使用@attribute [Authorize]等价于</span><br><span class="line">[Authorize]</span><br><span class="line">public Test&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">13.@using 引入命名空间</span><br><span class="line">14.@implements Student让Test.razor最终生成的Test类实现某个Student接口</span><br><span class="line">15.@inherits用于继承某个其他的组件</span><br><span class="line">16.@inject依赖注入，不要使用传统的构造注入</span><br><span class="line">17.@layout 布局</span><br><span class="line">18.@namespace 设置命名空间</span><br><span class="line">19.@page 设置路由</span><br><span class="line">20.@attibute 为razor文件指定特性</span><br><span class="line">21.@attributes html中的标签属性放在c#代码中，这样比较规整</span><br><span class="line">22.@key:再数据不断增加的情况下，不会失去焦点（闪烁的光标）</span><br></pre></td></tr></table></figure><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>页面中通过事件绑定到方法如下（单向绑定）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&gt;Click me&lt;/button&gt;通过@方法名的方式绑定到方法。</span><br><span class="line"></span><br><span class="line">@code &#123;</span><br><span class="line">    private void IncrementCount()</span><br><span class="line">    &#123;</span><br><span class="line">        currentCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双向绑定：使用@bind</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">绑定属性：@bind=&quot;inputvalue&quot;等价于@bing:value=&quot;inputvalue&quot;。</span><br><span class="line">绑定事件：@bind:event=&quot;onchange&quot;如果没有写绑定事件，则默认绑定到失去焦点事件(onchange事件)</span><br><span class="line">完成代码： &lt;input @bind-value=&quot;inputvalue&quot; @bind-value:event=&quot;onchange&quot; /&gt;</span><br><span class="line">如果执行完官方事件之后，还想要执行自定义函数，则使用@bind:after=&quot;方法名&quot;</span><br><span class="line">设置绑定日期的格式：&lt;input @bind=&quot;birthdate&quot; @bind:format=&quot;dd-MM-yyyy&quot; /&gt;</span><br></pre></td></tr></table></figure><p>函数如何获取事件传递过来的参数？</p><p>private void IncrementCount(MouseEventArgs e)    {}不同的事件提供不同的事件参数，如何区分如下：一般是将事件前面的on去掉，然后后面加上EventArgs</p><p>当方法中需要主动获取标签里面的内容。则通过绑定事件对应的参数进行传入，参数类型如何确定？将鼠标放在事件上，会提示ChangeEventArgs或者其他类型的参数</p><p><img src="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/assets/image-20221002212652264.png" alt="image-20221002212652264"></p><h2 id="页面中获取c-代码中的属性作为标签的属性值（通过c-代码控制css属性）"><a href="#页面中获取c-代码中的属性作为标签的属性值（通过c-代码控制css属性）" class="headerlink" title="页面中获取c#代码中的属性作为标签的属性值（通过c#代码控制css属性）"></a>页面中获取c#代码中的属性作为标签的属性值（通过c#代码控制css属性）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 style=&quot;font-style:@Style&quot;&gt;Counter&lt;/h1&gt;通过@属性名的方式绑定到属性。，这种方式只是单向绑定，即前端页面数值改变并不会改变后端数据的大小。</span><br><span class="line">@code &#123;</span><br><span class="line">    private int currentCount = 0;</span><br><span class="line">    private string Style = &quot;italic&quot;;斜体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">双向绑定:前端数据改变，同时后端对应的属性值也会立即随之改变,默认是鼠标离开输入框的时候会自动更改后端数据的值，如果更改为在数据输入的同时更改值则添加一个属性为@bind:event=&quot;oninput&quot;</span><br><span class="line">&lt;input @bind:&quot;Name&quot;/&gt;即将input的value与Name进行双向绑定。</span><br><span class="line">&lt;input @bind-Title=&quot;Name&quot;&gt;&lt;/input&gt;</span><br><span class="line">@bind:等价于@bind：</span><br></pre></td></tr></table></figure><h2 id="模板组件"><a href="#模板组件" class="headerlink" title="模板组件"></a>模板组件</h2><p>主页面时index.razor</p><p>当主页面引用组件的时候，使用&lt;组件名&gt;&lt;&#x2F;组件名称&gt;的方法进行引用其他组件 </p><h2 id="组件参数"><a href="#组件参数" class="headerlink" title="组件参数"></a>组件参数</h2><p>（相当于标签属性）：引用组件的时候，如果在调用者的文件里面传递参数给被调用的组件，则须在被调用者的对应的属性里面写上【parameter】参数，相当于将Title属性暴露出去，类似于形参</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">一个Component组件</span><br><span class="line">page &quot;/Counter&quot;</span><br><span class="line">&lt;h1&gt;@Title&lt;/h1&gt;Component组件显示Title，调用c#中的title属性</span><br><span class="line">@Code</span><br><span class="line">&#123;</span><br><span class="line">[Parameter]</span><br><span class="line">private string Title&#123;get;set;&#125;</span><br><span class="line">[Paramter]</span><br><span class="line">private EventCallBack&lt;MouseEventArgs&gt; OnClick&#123;get;set;&#125;为该组件定义OnClick事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在index里面引用Component组件</span><br><span class="line">&lt;Component Title=&quot;c#&quot; Onclick=&quot;@show&quot;/&gt;这样就会将Title的值传递给组件中的Title属性，然后在组件中显示出Title的值</span><br><span class="line">@code&#123;</span><br><span class="line">public void show()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2><p>使用EventCallback</p><p>将函数作为参数在组件中进行传递</p><h2 id="路由配置，在App-razor里面"><a href="#路由配置，在App-razor里面" class="headerlink" title="路由配置，在App.razor里面"></a>路由配置，在App.razor里面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router组件用来遍历程序集里面的所有@page生成的路由表</span><br><span class="line">&lt;Router AppAssembly=&quot;@typeof(App).Assembly&quot;&gt;</span><br><span class="line">    &lt;Found Context=&quot;routeData&quot;&gt;</span><br><span class="line">    routeview组件用来接收所有的路由参数以及指定默认的布局</span><br><span class="line">        &lt;RouteView RouteData=&quot;@routeData&quot; DefaultLayout=&quot;@typeof(MainLayout)&quot; /&gt;</span><br><span class="line">        打开网页的时候，首先就会定位到h1标签所修饰的内容</span><br><span class="line">        &lt;FocusOnNavigate RouteData=&quot;@routeData&quot; Selector=&quot;h1&quot; /&gt;                           </span><br></pre></td></tr></table></figure><p>使用@page“&#x2F;Counter”等价于使用@Attribute[Route(“&#x2F;Counter”)],相当于在该组件的类上面添加了该路由特性</p><p>执行方法的时候进行导航，分为调用者和被调用者，如下 1.通过控件进行导航 </p><p>首先在调用者里面引入路由对象，这是注入，而注册仍然是在program类里面</p><p>@inject NavigationManager nm</p><p>创建控件，绑定方法</p><p>&lt;button @onclick&#x3D;”NavTo”&gt;update<br> public void NavTo()</p><pre><code>{调用方法导航到对应的页面    nm.NavigateTo(&quot;test&quot;);}</code></pre><p> 被调用者需要设置对应的路由url</p><p> @page “&#x2F;test”</p><p> 2.通过链接进行导航</p><p> 使用Navlink标签指定href进行导航</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink class=&quot;nav-link&quot; href=&quot;&quot; Match=&quot;NavLinkMatch.All&quot;&gt;</span><br><span class="line">                &lt;span class=&quot;oi oi-home&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; Home</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">属性</span><br><span class="line">NavLinkMatch.All：使用此值时，只有在链接的 href 与当前 URL 完全匹配时，该链接才突出显示为活动链接。</span><br><span class="line">NavLinkMatch.Prefix：使用此值时，当链接的 href 与当前 URL 的第一部分匹配时即baseurl，该链接就突出显示为活动链接。 例如，假设你拥有链接 &lt;NavLink href=&quot;pizzas&quot; Match=&quot;NavLinkMatch.Prefix&quot;&gt;。 当前 URL 为 http://www.contoso.com/pizzas 及该 URL 中的任意位置（例如 http://www.contoso.com/pizzas/formaggio）时，此链接将突出显示为活动链接。 此行为可帮助用户了解自己当前正在查看网站的哪一部分。</span><br></pre></td></tr></table></figure><p>路由参数：例如前端使用url传参，后端如何接收：使用路由参数，为类中的属性&#x2F;字段添加[parameter]特性,凡是使用parameter修饰的属性都表示该属性作为url的接收参数，通过OnInitialized方法对传递进来的参数进行处理，该方法表示该组件启动之后首先做的事情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@page &quot;/test/&#123;parameter1:int&#125;&quot;参数传递给parameter1，并且约束为int类型</span><br><span class="line">//@page &quot;/FavoritePizza/&#123;*favorites&#125;&quot;使用*可以获取所有的路由参数,例如url为http://www.contoso.com/favoritepizza/margherita/hawaiian，则最后favorites捕获的是margherita/hawaiian，而不是单单的margherita</span><br><span class="line">&lt;p&gt;Your favorite pizza is: @Favorite&lt;/p&gt;</span><br><span class="line">@code&#123;</span><br><span class="line">[parameter]</span><br><span class="line">//在url中显示parameter2=。。。，而不是parameter1</span><br><span class="line">[SupplyParameterFromQuery(Name = &quot;parameter2&quot;)];</span><br><span class="line">public string parameter1&#123;get;set;&#125;</span><br><span class="line">protected override void OnInitialized()</span><br><span class="line">    &#123;</span><br><span class="line">        parameter1 = parameter1 ?? &quot;fantastic&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">以上代码参数的传递顺序为@page中的parameter1首先获取，然后是传递给在@code中parameter1，在然后是在p标签中进行显示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>路由约束可设置的情况：</p><table><thead><tr><th>bool</th><th>{vegan:bool}</th><th><code>http://www.contoso.com/pizzas/true</code></th></tr></thead><tbody><tr><td>datetime</td><td>{birthdate:datetime}</td><td><code>http://www.contoso.com/customers/1995-12-12</code></td></tr><tr><td>decimal</td><td>{maxprice:decimal}</td><td><code>http://www.contoso.com/pizzas/15.00</code></td></tr><tr><td>double</td><td>{weight:double}</td><td><code>http://www.contoso.com/pizzas/1.234</code></td></tr><tr><td>float</td><td>{weight:float}</td><td><code>http://www.contoso.com/pizzas/1.564</code></td></tr><tr><td>guid</td><td>{pizza id:guid}</td><td><code>http://www.contoso.com/pizzas/CD2C1638-1638-72D5-1638-DEADBEEF1638</code></td></tr><tr><td>long</td><td>{totals ales:long}</td><td><code>http://www.contoso.com/pizzas/568192454</code></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">当前完整 URI，例如 http://www.contoso.com/pizzas/margherita?extratopping=pineapple。使用NavManager.ToAbsoluteUri(NavManager.Uri)</span><br><span class="line">基本 URI，例如 http://www.contoso.com/。</span><br><span class="line">基本相对路径，例如 pizzas/margherita。</span><br><span class="line">查询字符串，例如 ?extratopping=pineapple。</span><br><span class="line">获取baseuri</span><br><span class="line">protected override void OnInitialized()</span><br><span class="line">&#123;</span><br><span class="line">HomePageURI = NavManager.BaseUri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">获取查询参数：使用QueryHelpers</span><br><span class="line">@page &quot;/pizzas&quot;</span><br><span class="line">@using Microsoft.AspNetCore.WebUtilities</span><br><span class="line">@inject NavigationManager NavManager</span><br><span class="line">@code &#123;</span><br><span class="line">protected override void OnInitialized()</span><br><span class="line">&#123;</span><br><span class="line">var uri = NavManager.ToAbsoluteUri(NavManager.Uri);</span><br><span class="line">if (QueryHelpers.ParseQuery(uri.Query).TryGetValue(&quot;extratopping&quot;, out var extraTopping))</span><br><span class="line">&#123;</span><br><span class="line">ToppingName = System.Convert.ToString(extraTopping);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">使用editform代替html默认的form</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;EditForm Model=&quot;@student&quot; OnValidSubmit=&quot;HandleValidSubmit&quot;&gt;//model表示绑定到哪个对象，这样下面的标签才可以使用。onvalidsubmit表示提交之后触发对应的事件(可以不写事件)</span><br><span class="line">    &lt;DataAnnotationsValidator/&gt;//进行数据验证的条件</span><br><span class="line">    &lt;ValidationSummary/&gt;//错误消息汇总在一起，一般使用下面的message</span><br><span class="line">    &lt;InputText @bind-Value=&quot;@student.Code&quot;/&gt;</span><br><span class="line">    &lt;ValidationMessage For=&quot;()=&gt;student.Code&quot;/&gt;</span><br><span class="line">    &lt;InputText @bind-Value=&quot;@student.Name&quot;/&gt;</span><br><span class="line">    &lt;ValidationMessage For=&quot;()=&gt;student.Name&quot;/&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;submit&lt;button/&gt;当提交之后，会依次从上往下执行数据验证</span><br><span class="line">&lt;/EditForm&gt;</span><br><span class="line">对应的类</span><br><span class="line">@code&#123;</span><br><span class="line">@using System.ComponentModel.DataAnnotations</span><br><span class="line">Stduent student = new Stduent();</span><br><span class="line">    public class Stduent</span><br><span class="line">    &#123; </span><br><span class="line">        [required]</span><br><span class="line">        public string Code &#123; get; set; &#125;</span><br><span class="line">        [required]</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="input组件"><a href="#input组件" class="headerlink" title="input组件"></a>input组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inputtext单行</span><br><span class="line">inputtextarea多行</span><br><span class="line">inputnumber</span><br><span class="line">inputselect</span><br><span class="line">inputdate日期</span><br><span class="line">inputcheckbox选择框</span><br></pre></td></tr></table></figure><h2 id="razor组件-页面-之间如何传递参数-组件参数"><a href="#razor组件-页面-之间如何传递参数-组件参数" class="headerlink" title="razor组件(页面)之间如何传递参数(组件参数)"></a>razor组件(页面)之间如何传递参数(组件参数)</h2><p>razor组件作为标签嵌入到父组件时，如何将父组件中的字段传递到子组件中的字段？</p><p>1.子组件字段使用parameter修饰（参考路由部分</p><p>2.子组件作为标签写入父组件，其字段作为标签的属性。不要在get，set中写逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br><span class="line">子组件Test.razor中</span><br><span class="line">@code&#123;</span><br><span class="line">[parameter]</span><br><span class="line">public string? childName&#123;get;set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">父组件UserTest.razor中</span><br><span class="line">&lt;Test childName=&quot;@parentName&quot;&gt;&lt;/Test&gt;</span><br><span class="line">@code&#123;</span><br><span class="line">public string? ParentName&#123;get;set;&#125;</span><br><span class="line">&#125;</span><br><span class="line">如何在&lt;Test&gt;&lt;/Test&gt;开始和结束标签之间添加内容？</span><br><span class="line">1.隐式方式：在子组件中定义添加下面的属性作为接收参数，该属性的名字是固定的ChildContent不能改变</span><br><span class="line">[Parameter]</span><br><span class="line">public RenderFragment ChildContent&#123;get;set;&#125; </span><br><span class="line">2.显示方式：改ChildContent为MyContent </span><br><span class="line">public RenderFragment MyContent&#123;get;set;&#125; </span><br><span class="line">使用时则如下</span><br><span class="line">&lt;Test&gt;</span><br><span class="line">&lt;MyContent&gt;</span><br><span class="line">&lt;p&gt;这是添加内容&lt;/p&gt;</span><br><span class="line">&lt;/MyContent&gt;</span><br><span class="line">&lt;/Test&gt;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/assets/image-20230203091316922.png" alt="image-20230203091316922"></p><p>0：将所有组件编译成类</p><p>1：该方法将当前所有使用parameter修饰的属性或caclingparameter的属性注入到组件中</p><p>2：用来执行界面渲染之前需执行的操作（自定义）</p><p>3：每次被parameter修饰的属性值发生改变时，都会调用该方法(自定义)</p><p>4：OnAfterRenderAsync：每次渲染后需执行的操作（自定义）</p><p><img src="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/assets/image-20230318212033418.png" alt="image-20230318212033418"></p><h2 id="js与c-互操作"><a href="#js与c-互操作" class="headerlink" title="js与c#互操作"></a>js与c#互操作</h2><p>JavaScript 添加到 Blazor 应用的方法是使用 HTML <code>&lt;script&gt;</code> 元素。 若要将 JavaScript 代码添加到 Blazor 应用，请在 Pages&#x2F;_Host.cshtml 文件或 wwwroot&#x2F;index.html 文件中的现有 <code>&lt;script src=&quot;_framework/blazor.*.js&quot;&gt;&lt;/script&gt;</code> 标记后添加 <code>&lt;script&gt;</code> 标记，表示引用了某个现成的库，如果单纯使用js语法，不需要此步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;_framework/blazor.server.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script src=&quot;https://cdn.jsdelivr.net/npm/sweetalert@latest/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.jsinterop.ijsruntime">IJSRuntime</a> 从 .NET 代码调用 JavaScript 函数。 若要使 JS 互操作运行时可用，请将 <code>IJSRuntime</code> 抽象实例注入 Blazor 页面，在文件顶部附近的 <code>@page</code> 指令之后。</p><p><code>IJSRuntime</code> 接口公开了几种方法来调用 JavaScript 代码：</p><ul><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.jsinterop.ijsruntime.invokeasync">InvokeAsync</a></li><li><a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.jsinterop.jsruntimeextensions.invokevoidasync">InvokeVoidAsync</a></li></ul><p>使用 <code>InvokeAsync&lt;TValue&gt;</code> 调用返回值的 JavaScript 函数，否则调用 <code>InvokeVoidAsync</code>。 顾名思义，这两种方法都是异步的，因此请使用 C# <code>await</code> 运算符来捕获任何结果。 <code>InvokeAsync</code> 和 <code>InvokeVoidAsync</code> 方法的参数是要调用的 JavaScript 函数的名称，后跟函数所需的任何参数。 JavaScript 函数必须属于 <code>window</code> 作用域或 <code>window</code> 子作用域。 参数必须可序列化为 JSON。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@inject OrderState OrderState</span><br><span class="line">@inject IJSRuntime JavaScript</span><br><span class="line"></span><br><span class="line">async Task RemovePizzaConfirmation(Pizza removePizza)</span><br><span class="line">&#123;</span><br><span class="line">    if (await JavaScript.InvokeAsync&lt;bool&gt;(</span><br><span class="line">        &quot;confirm&quot;,</span><br><span class="line">        $&quot;&quot;&quot;Do you want to remove the &quot;&#123;removePizza.Special!.Name&#125;&quot; from your order?&quot;&quot;&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        OrderState.RemoveConfiguredPizza(removePizza);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js调用.net代码：  <a href="https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.jsinterop.dotnetobjectreference">DotNetObjectReference</a> 此类是 JS 互操作库的一部分。 <code>DotNet</code> 类公开了帮助程序函数 <code>invokeMethod</code> 和 <code>invokeMethodAsync</code>。 使用 <code>invokeMethod</code> 运行方法并等待结果，使用 <code>invokeMethodAsync</code> 异步调用方法。 <code>invokeMethodAsync</code> 方法返回 JavaScript <code>Promise</code>。</p><h2 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h2><p>使用editform组件代替html中的form标签，editform与form的区别如下：</p><p>​1数据绑定。 可将对象与 EditForm 关联。 EditForm 的作用类似于用于数据输入和显示的对象视图。<br>​2验证。 EditForm 提供了广泛且可扩展的验证功能。 可以向指定验证规则的 EditForm 中的元素添加属性。 EditForm 将自动应用这些规则。 将在本模块的后续单元中介绍此功能。<br>​3表单提交。 HTML 表单将在提交后向表单处理程序发送一个发布请求。 该表单处理程序应会执行提交过程，然后显示任何结果。 EditForm 遵循 Blazor 事件模型；请指定捕获 OnSubmit 事件的 C# 事件处理程序。 事件处理程序执行提交逻辑。<br>​4输入元素。 HTML 表单使用 <input> 控件收集用户输入，并使用 submit 按钮发布表单以供处理。 EditForm 可以使用这些相同的元素，但 Blazor 提供了具有其他功能（例如内置验证和数据绑定）的输入组件库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;EditForm Model=@currentForecast&gt;</span><br><span class="line">    &lt;InputDate @bind-Value=currentForecast.Date&gt;&lt;/InputDate&gt;</span><br><span class="line">    &lt;InputNumber @bind-Value=currentForecast.TemperatureC&gt;&lt;/InputNumber&gt;</span><br><span class="line">    &lt;InputText @bind-Value=currentForecast.Summary&gt;&lt;/InputText&gt;</span><br><span class="line">&lt;/EditForm&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTML &lt;form&gt; 元素支持 &lt;input&gt; 元素，以便用户能够输入数据。 &lt;input&gt; 有一个 type 属性，用于指定输入的类型及其显示方式（作为数字、文本框、单选按钮、复选框、按钮等）。</span><br><span class="line">Blazor 拥有自己的一组组件，旨在专用于 &lt;EditForm&gt; 元素并支持其他功能中的数据绑定。 下表列出了这些组件。 当 Blazor 呈现包含这些组件的页面时，它们将转换为表中列出的相应 HTML &lt;input&gt; 元素。 一些 Blazor 组件是通用的；类型参数由 Blazor 运行时根据绑定到元素的数据类型确定：</span><br><span class="line"></span><br><span class="line">输入组件呈现为 (HTML)</span><br><span class="line">InputCheckbox&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">InputDate&lt;TValue&gt;&lt;input type=&quot;date&quot;&gt;</span><br><span class="line">InputFile&lt;input type=&quot;file&quot;&gt;</span><br><span class="line">InputNumber&lt;TValue&gt;&lt;input type=&quot;number&quot;&gt;</span><br><span class="line">InputRadio&lt;TValue&gt;&lt;input type=&quot;radio&quot;&gt;</span><br><span class="line">InputRadioGroup&lt;TValue&gt;一组子单选按钮</span><br><span class="line">InputSelect&lt;TValue&gt;&lt;select&gt;</span><br><span class="line">InputText&lt;input&gt;</span><br><span class="line">InputTextArea&lt;textarea&gt;</span><br><span class="line">这些元素中的每一个都具有由 Blazor 识别的属性，例如 DisplayName（用于将输入元素与标签关联）和 @ref（可用于保存对 C# 变量中的字段的引用）。 任何无法识别的非 Blazor 属性都将按原样传递给 HTML 呈现器。 这意味着可以利用 HTML 输入元素属性。 例如，可以将 min、max 和 step 属性添加到 InputNumber 组件，它们将作为所呈现的 &lt;input type=&quot;number&quot;&gt; 元素的一部分正常运行。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p> Blazor 支持两种类型的验证：声明性和编程性。</p><p>1.声明性：使用组件： DataAnnotationsValidator 组件（进行验证）和ValidationSummary （进行汇总错误信息）</p><p><img src="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/assets/image-20230319194531505.png" alt="image-20230319194531505"></p><p><img src="/2026/01/29/blazor%E5%AD%A6%E4%B9%A0/assets/image-20230319194514083.png" alt="image-20230319194514083"></p><p>想要在每个控件旁边显示验证消息，请使用多个 ValidationMessage 组，使用 <code>For</code> 属性将每个 ValidationMessage 控件与模型的特定属性相关联</p><p>&lt;InputText id&#x3D;”name” @bind-Value&#x3D;”pizza.Name” &#x2F;&gt;</p><p> &lt;ValidationMessage For&#x3D;”@(() &#x3D;&gt; pizza.Name)” </p><p>2.编程性：自己使用js或者c#以编程方式逐个字段地检查和验证数据。 但是，不建议使用这种方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class PizzaBase : ValidationAttribute</span><br><span class="line">&#123;</span><br><span class="line">    public string GetErrorMessage() =&gt; $&quot;Sorry, that&#x27;s not a valid pizza base.&quot;;</span><br><span class="line"></span><br><span class="line">    protected override ValidationResult IsValid(</span><br><span class="line">        object value, ValidationContext validationContext)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value != &quot;Tomato&quot; || value != &quot;Pesto&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            return new ValidationResult(GetErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ValidationResult.Success;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用时如下：</span><br><span class="line"> [PizzaBase]</span><br><span class="line">    public string Base &#123; get; set; &#125;</span><br></pre></td></tr></table></figure><p>三种验证事件：</p><ul><li><p><code>OnValidSubmit</code>. 如果输入域成功通过其验证属性定义的验证规则，则会触发此事件。</p></li><li><p><code>OnInvalidSubmit</code>. 如果表单上的任何输入域都未能通过其验证属性定义的验证，则会触发此事件。</p></li><li><p><code>OnSubmit</code>. 无论所有输入域是否有效，提交 EditForm 时都会发生此事件。</p><p>对于在单个输入域级别实现基本验证的 EditForm，<code>OnValidSubmit</code> 和 <code>OnInvalidSubmit</code> 事件很有用。 如果验证要求更复杂，例如将一个输入域与另一个输入域进行交叉检查以确保值的有效组合，请考虑使用 <code>OnSubmit</code> 事件。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>​        required</p><p>​        Range：检查是否在合理范围内</p><p>​        [EmailAddress]</p><ul><li><code>[ValidationNever]</code>. 如果要确保该字段从不包含在验证中，请使用此注释。</li><li><code>[CreditCard]</code>. 如果要记录用户的有效信用卡号，请使用此注释。</li><li><code>[Compare]</code>. 如果要确保模型中的两个属性匹配，请使用此注释。</li><li><code>[Phone]</code>. 如果要记录用户的有效电话号码，请使用此注释。</li><li><code>[RegularExpression]</code>. 如果通过将值与正则表达式进行比较来检查值的格式，请使用此注释。</li><li><code>[StringLength]</code>. 如果要检查字符串值的长度是否不超过最大长度，请使用此注释。</li><li><code>[Url]</code>. 如果要记录用户的有效 URL，请使用此注释。</li></ul></li></ul><h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p>使用NavMenu</p><h2 id="WebApi"><a href="#WebApi" class="headerlink" title="WebApi"></a>WebApi</h2><p>blazor也可实现类似WebApi形式的前后端分离，使用Controller形式。<a href="https://learn.microsoft.com/zh-cn/training/modules/interact-with-data-blazor-web-apps/5-exercise-access-data-from-blazor-components">https://learn.microsoft.com/zh-cn/training/modules/interact-with-data-blazor-web-apps/5-exercise-access-data-from-blazor-components</a></p><h1 id="三方ui库"><a href="#三方ui库" class="headerlink" title="三方ui库"></a>三方ui库</h1><p>matblazor，masablazor,bootstrapblazor</p><h3 id="WpfBlazor"><a href="#WpfBlazor" class="headerlink" title="WpfBlazor"></a>WpfBlazor</h3><p><a href="https://www.cnblogs.com/Dotnet9-com/p/16868009.html">https://www.cnblogs.com/Dotnet9-com/p/16868009.html</a></p><h3 id="MauiBlazor"><a href="#MauiBlazor" class="headerlink" title="MauiBlazor"></a>MauiBlazor</h3><p>开启hyper-v和安装HAXM</p><p><a href="https://learn.microsoft.com/zh-cn/dotnet/maui/get-started/installation?view=net-maui-7.0&tabs=vswin">https://learn.microsoft.com/zh-cn/dotnet/maui/get-started/installation?view=net-maui-7.0&amp;tabs=vswin</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>avalonia</title>
      <link href="/2026/01/29/Avalonia/"/>
      <url>/2026/01/29/Avalonia/</url>
      
        <content type="html"><![CDATA[<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/2026/01/29/Avalonia/assets/image-20260112221236868.png" alt="image-20260112221236868"></p><span id="more"></span><p>第一项：使用codebehind</p><p>第二项：使用mvvm框架，支持windows，macos 和linux</p><p>第三项：cross-platform 支持windows，macos 和linux，ios，android，wasm</p><p>项目结构</p><p><img src="/2026/01/29/Avalonia/assets/image-20260112224345382.png" alt="image-20260112224345382"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">program.cs中的代码解释</span><br><span class="line">internal sealed class Program</span><br><span class="line">&#123;</span><br><span class="line">    [STAThread] //单线程</span><br><span class="line">    public static void Main(string[] args) =&gt; BuildAvaloniaApp()</span><br><span class="line">        .StartWithClassicDesktopLifetime(args);//启动应用程序生命周期管理</span><br><span class="line"></span><br><span class="line">    // Avalonia configuration, don&#x27;t remove; also used by visual designer.</span><br><span class="line">    public static AppBuilder BuildAvaloniaApp()</span><br><span class="line">        =&gt; AppBuilder.Configure&lt;App&gt;()//设置启动文件为APP.axaml.cs类</span><br><span class="line">            .UsePlatformDetect()//设置平台，windows，linux，macos</span><br><span class="line">            .WithInterFont()//设置字体</span><br><span class="line">            .LogToTrace();//设置日志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mainwindow中的解释</span><br><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;这是 Avalonia UI 本身的XAML命名空间声明。这是必需的，否则文件将无法被识别为Avalonia XAML文档；</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;这是XAML语言命名空间的声明；</span><br><span class="line">        x:Class=&quot;AvaloniaApplication1.MainWindow&quot;&gt;这是上面声明的扩展（用于&#x27;x&#x27;）告诉XAML编译器在文件中找到相关联的类的位置。</span><br><span class="line">&lt;/Window&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">App.xaml代码的解释</span><br><span class="line">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaAppPro1.App&quot;</span><br><span class="line">             xmlns:local=&quot;using:AvaloniaAppPro1&quot;</span><br><span class="line">             RequestedThemeVariant=&quot;Default&quot;&gt;//主题颜色，包含default,Dark,Light</span><br><span class="line">    &lt;Application.DataTemplates&gt;</span><br><span class="line">        &lt;local:ViewLocator/&gt;</span><br><span class="line">    &lt;/Application.DataTemplates&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;Application.Styles&gt;</span><br><span class="line">        &lt;FluentTheme /&gt;</span><br><span class="line">    &lt;/Application.Styles&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure><p>App.xaml.cs解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public partial class App : Application</span><br><span class="line">&#123;</span><br><span class="line">    public override void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        AvaloniaXamlLoader.Load(this);//加载app.axaml这个文件</span><br><span class="line">    &#125;</span><br><span class="line">//框架加载完成，可创建窗口等操作</span><br><span class="line">    public override void OnFrameworkInitializationCompleted()</span><br><span class="line">    &#123;</span><br><span class="line">        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)//判断是否是桌面环境</span><br><span class="line">        &#123;</span><br><span class="line">            DisableAvaloniaDataAnnotationValidation();</span><br><span class="line">            desktop.MainWindow = new MainWindow</span><br><span class="line">            &#123;</span><br><span class="line">                // 为主窗口(MainView)设置数据上下文(DataContext)</span><br><span class="line">                // 这样 MainView 及其所有子控件都能访问到 MainViewModel 里的数据。绑定方式二：在xaml中生命datacontext进行绑定</span><br><span class="line">                DataContext = new MainWindowViewModel(),//绑定view和viewmodel</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base.OnFrameworkInitializationCompleted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DisableAvaloniaDataAnnotationValidation()</span><br><span class="line">    &#123;</span><br><span class="line">        // Get an array of plugins to remove</span><br><span class="line">        var dataValidationPluginsToRemove =</span><br><span class="line">            BindingPlugins.DataValidators.OfType&lt;DataAnnotationsValidationPlugin&gt;().ToArray();</span><br><span class="line"></span><br><span class="line">        // remove each entry found</span><br><span class="line">        foreach (var plugin in dataValidationPluginsToRemove)</span><br><span class="line">        &#123;</span><br><span class="line">            BindingPlugins.DataValidators.Remove(plugin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p><code>virtual</code> 译为 “虚拟的”，在 C# 中用于修饰<strong>方法、属性、索引器或事件</strong>，核心作用是：<strong>允许子类通过 <code>override</code> 关键字重写（覆盖）基类的这个成员</strong>。</p><h2 id="CodeBehind-代码后置"><a href="#CodeBehind-代码后置" class="headerlink" title="CodeBehind:(代码后置)"></a>CodeBehind:(代码后置)</h2><p>代码后台文件通常具有<code>.axaml.cs</code>文件扩展名，并且通常在IDE中显示在XAML文件的下一级.在使用code-behind时，通常需要访问在XAML中定义的控件。需要通过在XAML中使用<code>Name</code>（或<code>x:Name</code>）属性为所需的控件指定名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Name=&quot;greetingButton&quot;&gt;Hello World&lt;/Button&gt;</span><br><span class="line"> 可以通过code-behind中自动生成的greetingButton字段访问该按钮：</span><br><span class="line"> public MainWindow()</span><br><span class="line">       &#123;</span><br><span class="line">           InitializeComponent();</span><br><span class="line">           greetingButton.Content = &quot;Goodbye Cruel World!&quot;;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="布局控件："><a href="#布局控件：" class="headerlink" title="布局控件："></a>布局控件：</h2><p>所有控件及其属性可参考文档Avalonia Control Gallery：<a href="https://github.com/AvaloniaUI/ControlCatalogStandalone">https://github.com/AvaloniaUI/ControlCatalogStandalone</a></p><p>布局控件：<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/building-layouts/panels-overview">https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/building-layouts/panels-overview</a></p><p>Grid</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102527502.png" alt="image-20260111102527502"></p><p>StackPanel:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102607285.png" alt="image-20260111102607285"></p><p>DockPanel:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102648592.png" alt="image-20260111102648592"></p><p>WrapPanel:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102742081.png" alt="image-20260111102742081"></p><p>Canvas:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102809582.png" alt="image-20260111102809582"></p><p>UniformGrid:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111102826353.png" alt="image-20260111102826353"></p><h3 id="布局属性："><a href="#布局属性：" class="headerlink" title="布局属性："></a>布局属性：</h3><p><a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/building-layouts/alignment-margins-and-padding">https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/building-layouts/alignment-margins-and-padding</a></p><p>HorizontalAlignment和VerticalAlignment:</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111103027102.png" alt="image-20260111103027102"></p><p>margin与pading,Spacing之间的区别：</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111170856089.png" alt="image-20260111170856089"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111104902951.png" alt="image-20260111104902951"></p><p>Spacing：用来设置子元素之间的间距</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111110035976.png" alt="image-20260111110035976"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111110111108.png" alt="image-20260111110111108"></p><h2 id="内置控件"><a href="#内置控件" class="headerlink" title="内置控件"></a>内置控件</h2><p>官方文档：<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/controls/builtin-controls">https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/controls/builtin-controls</a>)</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111105147266.png" alt="image-20260111105147266"></p><p>重点：Border:border通常用来包裹其他的控件,为其添加边框圆角背景色等视觉效果</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111105648715.png" alt="image-20260111105648715"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111110437172.png" alt="image-20260111110437172"></p><p>常用主题库和控件库：</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111112258778.png" alt="image-20260111112258778"></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>为什么需要资源？假设现在有一个应用，界面上有很多按钮，文本框，面板等控件，你希望所有的按钮都用统一的颜色字体和圆角样式，方便后期统一调整和维护，如果每个控件都单独设置属性不仅代码冗余而且维护成本极高，这个时候资源系统就能帮你解决这些问题。通过集中声明和复用资源可以让界面的风格统一在修改样式的时候只需要修改一个地方所有引用的地方都会自动更新。（将属性值抽离出来生成资源）。</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111140459747.png" alt="image-20260111140459747"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111140544490.png" alt="image-20260111140544490"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111140850272.png" alt="image-20260111140850272"></p><p>第二种方式：将资源卸载文件里面，然后使用ResourceInclude来引用</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111140939143.png" alt="image-20260111140939143"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111141037096.png" alt="image-20260111141037096"></p><p>将资源可以存放的地方</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111141342829.png" alt="image-20260111141342829"></p><p>使用资源</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111141458763.png" alt="image-20260111141458763"></p><p>举例：</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111141546387.png" alt="image-20260111141546387"></p><p>资源查找顺序</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111141716966.png" alt="image-20260111141716966"></p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>如果我们希望统一管理控件的外观，比如所有按钮都长成一样，鼠标在悬停的时候有特殊的效果。仅仅靠资源还不够，这个时候我们就需要样式系统了。样式可以让我们批量定义控件的外观和交互逻辑及大提示的UI开发的效率和可维护性。（将控件的动态行为抽离出来）</p><p>声明样式</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111142644291.png" alt="image-20260111142644291"></p><p>引用样式</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111142735497.png" alt="image-20260111142735497"></p><p>样式选择器</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111142913101.png" alt="image-20260111142913101"></p><p>举例</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143020236.png" alt="image-20260111143020236"></p><p>举例引用第三方控件的样式</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143127524.png" alt="image-20260111143127524"></p><p>选择所有属于Button或者继承Button类型的控件</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143236786.png" alt="image-20260111143236786"></p><p>选择Name为NameButton的控件</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143438405.png" alt="image-20260111143438405"></p><p>类选择器</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143508801.png" alt="image-20260111143508801"></p><p>伪类选择器</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143636561.png" alt="image-20260111143636561"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143647706.png" alt="image-20260111143647706"></p><p>举例</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143908991.png" alt="image-20260111143908991"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111143940079.png" alt="image-20260111143940079"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111144017866.png" alt="image-20260111144017866"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111144033190.png" alt="image-20260111144033190"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111144212132.png" alt="image-20260111144212132"></p><p>样式的优先级（就近原则）</p><h2 id="控件主题"><a href="#控件主题" class="headerlink" title="控件主题"></a>控件主题</h2><h2 id="绑定（binding）"><a href="#绑定（binding）" class="headerlink" title="绑定（binding）"></a>绑定（binding）</h2><p><a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/data/data-binding/">https://docs.avaloniaui.net/zh-Hans/docs/basics/data/data-binding/</a></p><p>通常情况下使用数据上下文进行绑定，将view与viewmodel绑定起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">前端的代码如何能够识别出后端的属性是通过数据上下文即datacontext实现的。</span><br><span class="line">绑定方式一：通过后端绑定</span><br><span class="line">desktop.MainWindow = new MainWindow</span><br><span class="line">        &#123;</span><br><span class="line">        //何为dataContext,实际上就是将前端xaml中的标签定义为一个类或者对象，将其与后端的对象对应起来。这样 MainView 及其所有子控件都能访问到 MainViewModel 里的数据</span><br><span class="line">        // 为主窗口(MainView)设置数据上下文(DataContext)</span><br><span class="line">            DataContext = new MainWindowViewModel(),</span><br><span class="line">        &#125;;</span><br><span class="line"> 绑定方式二：在前端xaml文件中进行绑定       </span><br><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        。。。</span><br><span class="line">        Icon=&quot;/Assets/avalonia-logo.ico&quot;</span><br><span class="line">        Title=&quot;PoetryPro&quot;</span><br><span class="line">        &lt;!--&gt;ServiceLocator已被注册为全局资源，通过ServiceLocator找到ResultViewModel&lt;--&gt;</span><br><span class="line">        DataContext=&quot;&#123;Binding ResultViewModel , Source=&#123;StaticResource ServiceLocator&#125;&#125;&quot;&gt; </span><br><span class="line"></span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">    &lt;Button Content=&quot;SemiAvalonia&quot;&gt;&lt;/Button&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>我们先在MainWIndow.axaml文件中写定义一个TextBlock控件，用于后续讲解，完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:vm=&quot;using:avalonia_demo.ViewModels&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;200&quot; d:DesignHeight=&quot;80&quot;</span><br><span class="line">        x:Class=&quot;avalonia_demo.Views.MainWindow&quot;</span><br><span class="line">        Title=&quot;avalonia_demo&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;hello avalonia&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>这样直接把TextBlock控件中的文本信息直接写死，会带来维护不便的问题。</p><p>举个例子，如果你想修改上述TextBlock的Text属性值，可以通过代码直接修改控件的属性值：先给TextBlock命个名，然后在代码中通过 Name.Text 的方式来修改值。修改的核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBlock Name=&quot;TestText&quot; Text=&quot;hello avalonia&quot;&gt;&lt;/TextBlock&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestText.Text = &quot;hello avalonia new&quot;;</span><br></pre></td></tr></table></figure><p>这种方式既不方便，也不利于维护。avalonia中的常用做法是，给最外层的根节点-Window 设置一个对象，将Text属性与这个对象中的一个成员变量进行绑定，这个设置的对象，我们就叫数据上下文-DataContext。</p><p>可能这么说还是不太好理解，我们拿示例演示一下。</p><p>我们在App.axaml.cs文件中，找到初始化窗口的代码：desktop.MainWindow &#x3D; new MainWindow();</p><p>这里我们给MainWindow的DataContext（数据上下文属性）设置赋值，这个赋值对象我们取名为MainWindowViewModel，这个MainWindowViewModel的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class MainWindowViewModel</span><br><span class="line">&#123;</span><br><span class="line">    public string? PageDesc &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新建MainWindow对象时，将对象的DataContext属性设置为MainWindowViewModel的实例</p><pre><code>public override void OnFrameworkInitializationCompleted(){    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)    {        desktop.MainWindow = new MainWindow()        {            // 给 MainWindow 添加数据上下文            DataContext = new MainWindowViewModel(){                PageDesc = &quot;avalonia ui&quot;            }        };    }    base.OnFrameworkInitializationCompleted();}</code></pre><p>这个MainWindowViewModel中定义了一个PageDesc的属性，属性值为”avalonia ui”，我想让这个属性中的内容，以文本的形式呈现到页面里，应该怎么做呢？</p><p>我们可以使用一堆花括号+Binding关键字，去指定控件属性要绑定DataContext对象的哪一个属性。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study.MainWindow&quot;</span><br><span class="line">        Title=&quot;avalonia_study&quot;&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;&#123;Binding PageDesc&#125;&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>上述代码就是指定TextBlock的Text属性，与DataContext的PageDesc属性相绑定。</p><p>好，让我们回过头来，看如何在MainWindow.axaml文件中，指定DataContext类型是什么，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study.MainWindow&quot;</span><br><span class="line">        xmlns:vm=&quot;clr-namespace:avalonia_study.ViewModels&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainWindowViewModel&quot;</span><br><span class="line">        Title=&quot;avalonia_study&quot;&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;&#123;Binding PageDesc&#125;&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>在WIndow节点中新加了两行代码：xmlns:vm&#x3D;”clr-namespace:avalonia_study.ViewModels”和x:DataType&#x3D;“vm:MainWindowViewModel”</p><p>先来看x:DataType，就是指定DataContext的数据类型是什么，前面的vm: 表示是哪个命名空间下的MainWIndowViewModel类。</p><p>而vm，对应的就是xmlns:vm&#x3D;“clr-namespace:avalonia_study.ViewModels” clr-namespace:后面的那个命名空间，也可以用using代替：</p><p>xmlns:vm&#x3D;”using:avalonia_study.ViewModels”</p><p>最后，我们再来介绍下CompiledBinding。当你启用编译绑定时，如果如果使用了CompiledBinding去做绑定，那么剩下的Binding关键字，会默认在后台变更成ReflectionBinding ，代码如下：</p><pre><code>    &lt;StackPanel&gt;            &lt;!--使用CompiledBinding--&gt;            &lt;TextBlock Text=&quot;{CompiledBinding PageDesc}&quot;&gt;&lt;/TextBlock&gt;            &lt;!--这里虽然用的Binding，但是实际运行时，使用的是ReflectionBinding--&gt;            &lt;TextBlock Text=&quot;{Binding PageDesc}&quot;&gt;&lt;/TextBlock&gt;    &lt;/StackPanel&gt;</code></pre><p><strong>设计时绑定</strong><br>我们安装了预览窗口，这个窗口的实现机制，类似于在后台的镜像环境跑了个代码，把跑出的结果呈现出来。我们可以手动在镜像环境，给窗口的DataContext属性赋值。这个机制就是设计时绑定。添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study.MainWindow&quot;</span><br><span class="line">        xmlns:vm=&quot;using:avalonia_study.ViewModels&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainWindowViewModel&quot;</span><br><span class="line">        Title=&quot;avalonia_study&quot;&gt;</span><br><span class="line">        &lt;!--设计时指定数据上下文对象--&gt;</span><br><span class="line">        &lt;Design.DataContext&gt;</span><br><span class="line">                &lt;!--这里就相当于new MainWindowViewModel()，并将对象赋给DataContext属性--&gt;</span><br><span class="line">                &lt;vm:MainWindowViewModel&gt;&lt;/vm:MainWindowViewModel&gt;</span><br><span class="line">        &lt;/Design.DataContext&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;TextBlock Text=&quot;&#123;CompiledBinding PageDesc&#125;&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>需要重点强调的是，Design.DataContext的设置，只会影响预览窗口相关的内容，代码实际跑起来之后，Design.DataContext中的内容会被舍弃，相当于没有。</p><p>这里我们再验证一下，给MainWindowViewModel对象的PageDesc属性赋值：</p><pre><code>    &lt;Design.DataContext&gt;            &lt;vm:MainWindowViewModel&gt;                    &lt;!--给PageDesc赋值--&gt;                    &lt;vm:MainWindowViewModel.PageDesc&gt;test2&lt;/vm:MainWindowViewModel.PageDesc&gt;            &lt;/vm:MainWindowViewModel&gt;    &lt;/Design.DataContext&gt;</code></pre><p>可以看到预览页面显示了test2，但是实际跑起来的时候并不是test2</p><p><strong>所有控件都有DataContext属性</strong><br>其实，不光上面讲的window有DataContext属性，每个控件，都有DataContext属性，我们来演示一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study.MainWindow&quot;</span><br><span class="line">        xmlns:vm=&quot;using:avalonia_study.ViewModels&quot;</span><br><span class="line">        Title=&quot;avalonia_study&quot;&gt;</span><br><span class="line">&lt;StackPanel&gt;</span><br><span class="line">&lt;!--x:DataType指定控件的编译时DataContext类型--&gt;</span><br><span class="line">&lt;TextBlock x:DataType=&quot;vm:MainWindowViewModel&quot; Text=&quot;&#123;Binding PageDesc&#125;&quot;&gt;</span><br><span class="line">            &lt;TextBlock.DataContext&gt;</span><br><span class="line">                    &lt;vm:MainWindowViewModel&gt;</span><br><span class="line">                            &lt;vm:MainWindowViewModel.PageDesc&gt;test333&lt;/vm:MainWindowViewModel.PageDesc&gt;</span><br><span class="line">                    &lt;/vm:MainWindowViewModel&gt;</span><br><span class="line">            &lt;/TextBlock.DataContext&gt;</span><br><span class="line">    &lt;/TextBlock&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>我们所以我们再这里单独为TextBlock单独设置了DataContext属性.</p><p>或者我们也可以在代码中去设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study.MainWindow&quot;</span><br><span class="line">        xmlns:vm=&quot;using:avalonia_study.ViewModels&quot;</span><br><span class="line">        Title=&quot;avalonia_study&quot;&gt;</span><br><span class="line">&lt;StackPanel&gt;</span><br><span class="line">&lt;!--通过Name属性定义控件名--&gt;</span><br><span class="line">&lt;TextBlock Name=&quot;TextBlockDemo&quot; Text=&quot;&#123;ReflectionBinding PageDesc&#125;&quot;&gt;</span><br><span class="line">    &lt;/TextBlock&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>在MainWindow.axaml.cs文件中手动设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        TextBlockDemo.DataContext = new MainWindowViewModel()</span><br><span class="line">        &#123;</span><br><span class="line">            PageDesc = &quot;test222&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲到这里，我们提一个问题：TextBlock组件，是如何找到要绑定的DataContext的呢？它是这么一套逻辑：首先TextBlock会先找自己身上，有没有设置DataContext属性，如果找到，就用这个，如果没找到，再往上层找，找到父节点设置的DataContext（本例中是StackPanel节点），如果还没找到，接着往上找，一直找到WIndow节点设置的DataContext。官方的示意图如下：</p><p>右边的那个Object可以先不用管，这是mvvm中的内容，大家先理解左边的部分就行。</p><p>这里我们演示一下，如何让子控件找到到父控件的DataContext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;300&quot; d:DesignHeight=&quot;110&quot;</span><br><span class="line">        Width=&quot;800&quot; Height=&quot;450&quot;</span><br><span class="line">        x:Class=&quot;avalonia_study_demo.MainWindow&quot;</span><br><span class="line">        xmlns:vm=&quot;using:avalonia_study_demo.ViewModels&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainWindowViewModel&quot;</span><br><span class="line">        Title=&quot;avalonia_study_demo1&quot;&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &lt;!--这里指定父控件的DataContext类型--&gt;</span><br><span class="line">    &lt;StackPanel x:DataType=&quot;vm:StackPanelDataContext&quot;&gt;</span><br><span class="line">        &lt;!--这里真正为父控件的DataContext赋值--&gt;</span><br><span class="line">        &lt;StackPanel.DataContext&gt;</span><br><span class="line">            &lt;vm:StackPanelDataContext&gt;&lt;/vm:StackPanelDataContext&gt;</span><br><span class="line">        &lt;/StackPanel.DataContext&gt;</span><br><span class="line">        &lt;!--找到的DataContext就是父控件的DataContext--&gt;</span><br><span class="line">        &lt;TextBlock Text=&quot;&#123;Binding StackPageDesc&#125;&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><p>引入每个控件都有DataContext的概念之后，我们再引入一个概念：类型转化。</p><p>我们先定义一个StackPanel包裹TextBlock的代码：</p><pre><code>    &lt;StackPanel&gt;            &lt;TextBlock&gt;&lt;/TextBlock&gt;    &lt;/StackPanel&gt;</code></pre><p>这时我们给StackPanel定义个DataContext对象：StackPanelViewModel，里面有一个PageDesc的string类型的属性。我们想将PageDesc属性，与TextBlock的Text属性进行绑定，要怎么做呢。</p><p>首先定义一个StackPanelViewModel，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace avalonia_study.ViewModels;</span><br><span class="line">public class StackPanelViewModel</span><br><span class="line">&#123;</span><br><span class="line">    public string PageDesc &#123; get; set; &#125; = &quot;avalonia ui&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我要在MainWindow的构造函数后，给StackPanel的DataContext赋值为StackPanelViewModel的对象，我需要在MainWindow.axaml文件中给StackPanel命名：</p><pre><code>    &lt;StackPanel Name=&quot;TestStackPanel&quot;&gt;            &lt;TextBlock&gt;&lt;/TextBlock&gt;    &lt;/StackPanel&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        TestStackPanel.DataContext = new StackPanelViewModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，这时StackPanel组件自身也有DataContext了。如果，我想让TexkBlock的Text属性，绑定到StackPanel的DataConetxt的PageDesc属性上，需要这么写：</p><pre><code>    &lt;StackPanel Name=&quot;TestStackPanel&quot;&gt;            &lt;TextBlock Text=&quot;{Binding $parent.((vm:StackPanelViewModel)DataContext).PageDesc}&quot;&gt;&lt;/TextBlock&gt;    &lt;/StackPanel&gt;</code></pre><p>$parent是指获取父组件，因为不能确定父组件的DataContext属性是什么类型的，所以这里用了个强转，然后再获取PageDesc属性</p><p>这里再稍微做一点延伸：如果想获取的不是父组件的DataContext，而是其他组件的呢？可以给目标组件取个名字，通过 #名字 的形式获取，完整代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;StackPanel Name=&quot;TestStackPanel&quot;&gt;</span><br><span class="line">                &lt;TextBlock Name=&quot;TestBlockDemo&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                &lt;TextBlock Text=&quot;&#123;Binding #TestBlockDemo.((vm:StackPanelViewModel)DataContext).PageDesc&#125;&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        TestBlockDemo.DataContext = new StackPanelViewModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在wpf中有3种方法可以将View与ViewModel连接起来。</p><p>1.在XAML中</p><p>第1步</p><p>将LoginViewModel的命名空间添加到LoginVIew.xaml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:local=&quot;clr-namespace:WPF_DataContext.VIewModel&quot; </span><br></pre></td></tr></table></figure><p>使用UserControl的DataContext属性来分配ViewModel</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">UserControl.DataContext</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">local:LoginViewModel</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">UserControl.DataContext</span>&gt;</span></span><br><span class="line"></span><br><span class="line">使用时，xaml文件课识别后端的Message属性</span><br><span class="line"><span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">&quot;&#123;Binding Message&#125;&quot;</span> <span class="attr">HorizontalAlignment</span>=<span class="string">&quot;Center&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure><p>2.后台代码分配</p><p>在这种方法中，我们将使用<em>RegisterView。 打开RegisterView</em>的代码隐藏类，即<em>RegisterView.xaml.cs</em>并设置<em>this.DataContext</em>值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.DataContext = <span class="keyword">new</span> RegisterViewModel(); <span class="comment">//利用codebehind通过datacontext将view与viewmodel进行连接</span></span><br></pre></td></tr></table></figure><p>您的最终 RegiserView.xaml.cs 将类似于以下代码片段，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">RegisterView</span> : <span class="title">UserControl</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RegisterView</span>()</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            InitializeComponent();  </span><br><span class="line">            <span class="keyword">this</span>.DataContext = <span class="keyword">new</span> RegisterViewModel();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">使用时直接如下：</span><br><span class="line">&lt;TextBlock Text=<span class="string">&quot;&#123;Binding Message&#125;&quot;</span> HorizontalAlignment=<span class="string">&quot;Center&quot;</span>/&gt;    </span><br></pre></td></tr></table></figure><p>3.视图模型定位</p><p>ViewModelLocator 集中代码以连接View和ViewModel。这意味着它为我们提供了将 View 与 ViewModel 绑定的松耦合方式，通过这种方法，View 不需要对它所连接的 ViewModel 进行硬编码。所以基本上我们用五步方法自动化整个过程，</p><ul><li>第 1 步：确定视图，例如<em>LoginView</em>。</li><li>第2步：确定ViewModel，如果我们正确地遵循命名约定，那么View的名称总是以ViewModel结尾。例如 <em>LoginViewModel</em>。</li><li>第 3 步：从第 2 步中获得 ViewModel 类型后，您需要创建该 ViewModel 类型的实例。</li><li>第 4 步：创建一个 ViewModel 实例</li><li>第 5 步：设置视图的 DataContext。</li></ul><p>所有这些步骤都发生在运行时，这就是为什么 View 在编译时不必担心它的 ViewModel 绑定。</p><p><img src="/2026/01/29/Avalonia/assets/image-20260111162735106.png" alt="image-20260111162735106"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111162847865.png" alt="image-20260111162847865"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111162812088.png" alt="image-20260111162812088"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111162907763.png" alt="image-20260111162907763"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111162957224.png" alt="image-20260111162957224"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260111163008310.png" alt="image-20260111163008310"></p><p>样式绑定：</p><p>绑定到控件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextBox Name=&quot;other&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 绑定到命名为 other 控件的 Text 属性 --&gt;</span><br><span class="line">&lt;TextBlock Text=&quot;&#123;Binding #other.Text&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">绑定到祖先控件</span><br><span class="line">&lt;Border Tag=&quot;Hello World!&quot;&gt;</span><br><span class="line">  &lt;TextBlock Text=&quot;&#123;Binding $parent.Tag&#125;&quot;/&gt;</span><br><span class="line">&lt;/Border&gt;</span><br></pre></td></tr></table></figure><p>转换器绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;local:MyConverter x:Key=&quot;converter1&quot;/&gt;</span><br><span class="line">&lt;/Window.Resources&gt;</span><br><span class="line"> </span><br><span class="line">&lt;TextBlock Text=&quot;&#123;Binding Value, Converter=&#123;StaticResource converter1&#125;&#125;&quot;/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="行为（behavior）"><a href="#行为（behavior）" class="headerlink" title="行为（behavior）"></a>行为（behavior）</h2><p>behavior是通过事件去调整前端其他控件的行为，而以往是通过事件调用后端的方法。例如点击按钮触发抽屉栏</p><p>比如你有 10 个 Button 都需要 “点击后禁用 5 秒” 的逻辑，用<code>Click</code>事件需要写 10 次重复代码（或调用公共方法），而用 Behavior 只需封装一次，然后在 10 个 Button 上附加该行为即可，大幅减少冗余代码。</p><ol><li><code>ICommand</code> 是 MVVM 模式的核心组成部分，它的唯一职责是将页面上的用户交互（如按钮点击、列表选择）对应的「业务逻辑」封装在 ViewModel 中，完全与视图（View）解耦。它关注的是「用户操作后要执行什么业务功能」（比如提交表单、查询数据、删除记录、导航页面），不关心视图控件的状态变化，也不包含任何与 UI 相关的逻辑。</li></ol><p>​ICommand的主要功能：</p><p>​（1）按钮点击后<strong>提交表单数据</strong>到服务器；</p><p>​（2）列表项点击后<strong>查询该项目的详情数据</strong>；</p><p>​（3）删除按钮点击后<strong>删除选中的数据记录</strong>并更新列表；</p><p>​（4）保存按钮点击后<strong>校验表单数据合法性</strong>并持久化到本地；</p><p>​（5）导航按钮点击后<strong>跳转到指定页面</strong>（导航逻辑若涉及业务参数，也归属业务逻辑）。</p><ol start="2"><li><p>Behavior:它关注的是「用户如何与控件进行交互，以及交互过程中控件的 UI 状态如何变化」（比如按钮点击后延迟 5 秒禁用、输入框回车触发提交、鼠标拖拽控件、双击列表项触发事件），不关心后续的业务功能，也不包含任何与业务相关的逻辑。<strong>(总结</strong>：前者操作的是viewmodel层，而后者操作的是view层)。</p><p>Behavior的主要功能：</p><p>（1）按钮点击后<strong>禁用自身 5 秒</strong>（防止重复点击）；</p><p>（2）输入框输入完成后<strong>按下回车键触发提交</strong>；</p><p>（3）列表控件<strong>双击项</strong>（而非单击）触发事件；</p><p>（4）鼠标<strong>拖拽控件</strong>改变其位置或大小；</p><p>（5）文本框<strong>输入内容时实时限制输入长度</strong>并改变边框颜色。</p></li></ol><p>使用方法：<a href="https://www.php.cn/faq/1893927.html">https://www.php.cn/faq/1893927.html</a></p><p>1.nuget安装 Avalonia.Xaml.Behaviors</p><p>2.加入声明</p><p>xmlns:i&#x3D;”using:Avalonia.Xaml.Interactivity”<br>xmlns:ia&#x3D;”using:Avalonia.Xaml.Interactions.Core”</p><ol start="3"><li>使用，支持的常见事件名包括<strong>Click</strong>、<strong>Loaded</strong>、<strong>Unloaded</strong>、<strong>PointerPressed</strong>、<strong>PointerReleased</strong>、<strong>LostFocus</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button content=&quot;保存&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;interactivity:interaction.behaviors&gt;</span><br><span class="line"></span><br><span class="line">    &lt;behaviors:eventtriggerbehavior eventname=&quot;Click&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;behaviors:invokecommandaction command=&quot;&#123;Binding SaveCommand&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/behaviors:invokecommandaction&gt;&lt;/behaviors:eventtriggerbehavior&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/interactivity:interaction.behaviors&gt;</span><br><span class="line"></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li><p><strong>使用场景：</strong>（1）页面初次打开时，自动加载数据库中的数据</p><p>​            （2）构建事件与命令之间的关联，一个事件对应哪个命令</p></li></ol><p>适合初始化数据、设置状态等场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;grid&gt;</span><br><span class="line"></span><br><span class="line">  &lt;interactivity:interaction.behaviors&gt;</span><br><span class="line"></span><br><span class="line">    &lt;behaviors:loadedtrigger&gt;</span><br><span class="line"></span><br><span class="line">      &lt;behaviors:invokecommandaction command=&quot;&#123;Binding LoadCommand&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/behaviors:invokecommandaction&gt;&lt;/behaviors:loadedtrigger&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/interactivity:interaction.behaviors&gt;</span><br><span class="line"></span><br><span class="line">&lt;/grid&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>自定义行为，例如TextBox 在 <code>IsVisible=true</code> 时自动聚焦并全选</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class FocusOnVisibleBehavior : Behavior&lt;textbox&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    protected override void OnAttached()</span><br><span class="line">    &#123;</span><br><span class="line">        base.OnAttached();</span><br><span class="line">        AssociatedObject?.PropertyChanged += OnPropertyChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;button class=&quot;copy-button&quot;&gt;复制&lt;/button&gt;&lt;button class=&quot;copy-button&quot; style=&quot;margin-left: 5px; margin-right: 5px;&quot;&gt;AI写代码&lt;/button&gt;&lt;pre class=&quot;brush:php;toolbar:false;&quot;&gt;</span><br><span class="line"></span><br><span class="line">private void OnPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    if (e.Property == Visual.IsVisibleProperty &amp;&amp; AssociatedObject?.IsVisible == true)</span><br><span class="line">    &#123;</span><br><span class="line">        AssociatedObject.Focus();</span><br><span class="line">        AssociatedObject.SelectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected override void OnDetaching() =&gt; </span><br><span class="line">    AssociatedObject?.PropertyChanged -= OnPropertyChanged;&lt;/pre&gt;&lt;p&gt;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">XAML中直接引用</span><br><span class="line">&lt;!-- xmlns:local=&quot;using:YourApp.Behaviors&quot; --&gt;</span><br><span class="line">&lt;button class=&quot;copy-button&quot;&gt;复制&lt;/button&gt;&lt;button class=&quot;copy-button&quot; style=&quot;margin-left: 5px; margin-right: 5px;&quot;&gt;</span><br><span class="line">AI写代码</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;textbox local:focusonvisiblebehavior.attached=&quot;True&quot;&gt;&lt;/textbox&gt;</span><br><span class="line">不复杂但容易忽略：行为只在控件生命周期内有效，确保 ViewModel 中的命令是 ICommand类型（推荐用[RelayCommand]）</span><br><span class="line">&lt;/textbox&gt;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><a href="https://zhuanlan.zhihu.com/p/1971290721341399380">Avalonia 09: 应用程序生命周期 - 知乎</a></p><p>Avalonia 应用程序的生命周期大体分为以下阶段：</p><ul><li><strong>启动</strong>：Program.Main()，应用程序入口。配置 AppBuilder 并启动应用；</li><li><strong>框架初始化</strong>：App.Initialize()，加载 <a href="https://zhida.zhihu.com/search?content_id=266214237&content_type=Article&match_order=1&q=XAML&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3Njg0NTY1ODIsInEiOiJYQU1MIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjY2MjE0MjM3LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.MpekC7S7ZJ-fbrJrv1h_1zhvgx9fdjtc-ic1IELSYVM&zhida_source=entity">XAML</a>、注册全局资源、主题等；</li><li><strong>应用启动</strong>： App.OnFrameworkInitializationCompleted()，框架准备完成，可创建主窗口（MainWindow）;</li><li><strong>运行中</strong>：UI 线程循环，响应事件、绑定数据、用户交互;</li><li><strong>退出</strong>：Window.Closing &#x2F; App.Shutdown()，用户关闭窗口或主动退出。执行清理逻辑</li></ul><p>Window的生命周期是指Window从创建到销毁的整个过程，包括初始化、显示、激活、关闭等状态。</p><h2 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h2><p><a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/assets">https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/assets</a></p><p>Avalonia .NET Core MVVM应用程序解决方案模板会创建一个名为<code>Assets</code>的文件夹（包含<code>avalonia-logo.ico</code>文件），并在项目文件中添加一个元素来包含其中的任何文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;AvaloniaResource Include=&quot;Assets\**&quot;/&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br><span class="line">引用资产</span><br><span class="line">&lt;Image Source=&quot;icon.png&quot;/&gt;</span><br><span class="line">&lt;Image Source=&quot;images/icon.png&quot;/&gt;</span><br><span class="line">&lt;Image Source=&quot;../icon.png&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><h2 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h2><p><img src="/2026/01/29/Avalonia/assets/image-20260129202646591.png" alt="image-20260129202646591"></p><p><img src="/2026/01/29/Avalonia/assets/image-20260129202835138.png" alt="image-20260129202835138"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>需要解决的问题？</p><p>我们定义下这个控件</p><pre><code>    &lt;StackPanel&gt;            &lt;TextBox Margin=&quot;10&quot; Text=&quot;{Binding PageDesc}&quot;&gt;&lt;/TextBox&gt;    &lt;/StackPanel&gt;</code></pre><p>TextBox是定义了一个文本输入框，其中的Text属性指的是文本框中输入的内容。</p><p>之前我们提到过，每个控件都有自己默认的一个Binding Mode，TextBox的Mode属性是TwoWay，也就是说控件的Text属性与绑定的PageDesc属性，相互影响，一个属性改变之后，另一个属性也会跟着变。</p><p>我们为了验证这个结论，将MainWindowViewModel的属性更改一下，让属性变更的时候打印新值到控制台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace avalonia_study.ViewModels;</span><br><span class="line"></span><br><span class="line">public class MainWindowViewModel</span><br><span class="line">&#123;</span><br><span class="line">    private string? _pageDesc;</span><br><span class="line"></span><br><span class="line">    public string? PageDesc</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _pageDesc;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;new PageDesc is:&quot; + value);</span><br><span class="line">            _pageDesc = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">我们把代码运行起来，修改TextBox控件中的文本（也就是控件的Text属性修改），你会发现控制台打印了相关内容，所以我们可以得出结论：当控件的Text文本修改的时候，DataContext对应绑定的属性也会同步修改。（说明前端的view中的数值修改，则viewmodel中的也会随之发生变化）</span><br></pre></td></tr></table></figure><p>接下来我们想验证MainWindowViewModel的属性修改时，TextBox中的Text属性也会同步修改。为了验证这么一个场景，我们设计如下场景：引入一个按钮，当点击按钮的时候，MainWindowViewModel的PageDesc属性加个a字符。代码如下：</p><pre><code>    &lt;StackPanel&gt;            &lt;TextBox Margin=&quot;10&quot; Text=&quot;{Binding PageDesc}&quot;&gt;&lt;/TextBox&gt;            &lt;!--引入一个按钮控件，并绑定点击事件--&gt;            &lt;Button Click=&quot;Button_OnClick&quot;&gt;&lt;/Button&gt;    &lt;/StackPanel&gt;</code></pre><p>MainWindow中的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindow : Window</span><br><span class="line">&#123;</span><br><span class="line">    public MainWindow()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Button_OnClick(object? sender, RoutedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // 改变MainWindow的DataContext的PageDesc属性</span><br><span class="line">        ((MainWindowViewModel)DataContext).PageDesc += &#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而让人悲伤的是，似乎PageDesc的属性变动，并没有影响到TextBox的Text属性（说明viewmodel中的值发生变化并未引起xaml中的值发生变化，即仍然为单单向绑定）。原因是什么呢？</p><p>这里当PageDesc属性变动时，并没有“通知”与这个属性绑定的控件属性。所以在这里，我们需要引入一个通知的机制。因此我们将MainWindowViewModel中的代码改造如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.ComponentModel;</span><br><span class="line"></span><br><span class="line">namespace avalonia_study.ViewModels;</span><br><span class="line"></span><br><span class="line">// INotifyPropertyChanged 是 .NET 提供的一个接口，类可以实现该接口以表示属性已更改其值。</span><br><span class="line">public class MainWindowViewModel: INotifyPropertyChanged</span><br><span class="line">&#123;</span><br><span class="line">    // 因实现接口引入的PropertyChangedEventHandler</span><br><span class="line">    public event PropertyChangedEventHandler? PropertyChanged;</span><br><span class="line">    private string? _pageDesc;</span><br><span class="line">    public string? PageDesc</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _pageDesc;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;new PageDesc is:&quot; + value);</span><br><span class="line">            _pageDesc = value;</span><br><span class="line">            // 广播通知所有的绑定者，告诉它们数据已经改变</span><br><span class="line">            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(PageDesc)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过PropertyChanged?.Invoke方法，通知绑定了PageDesc的控件，PageDesc的值已经变更，你们跟着同步变。这下我们再运行代码尝试，会发现已经实现了我们期望的功能。</p><p>好，接下啦我们看下如何简化上面的代码。引入一个第三方的工具包：CommunityToolkit.Mvvm。将上面的代码修改如下：</p><p>using CommunityToolkit.Mvvm.ComponentModel;</p><p>namespace avalonia_study.ViewModels;</p><p>public partial class MainWindowViewModel: ObservableObject<br>{<br>    [ObservableProperty]<br>    private string? _pageDesc;&#x2F;&#x2F;注意，使用ObservableProperty特性时，属性必须首字母小写或者使用下划线开头<br>}</p><p>使用 MVVM Toolkit 简化 INotifyPropertyChanged,通过使用其 <code>ObservableObject</code> 类以及 Source Generators 功能结合 <code>[ObservableProperty]</code> Attribute.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"></span><br><span class="line">public partial class MyViewModel : ObservableObject</span><br><span class="line">&#123;</span><br><span class="line">    [ObservableProperty]</span><br><span class="line">    private string _name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们再说下Command模式。之前我们定义Button的点击操作，是在Click里面去做的。也可以用Command的形式去做，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Command=&quot;&#123;Binding AddItem&#125;&quot;&gt;add&lt;/Button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public partial class MainWindowViewModel: ObservableObject</span><br><span class="line">&#123;</span><br><span class="line">    [ObservableProperty]</span><br><span class="line">    private string? _pageDesc = &quot;abcd&quot;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    [RelayCommand]</span><br><span class="line">    public void AddItem()</span><br><span class="line">    &#123;</span><br><span class="line">        PageDesc += &#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先解答大家可能会有的两个疑问：</p><p>为什么用command和click的效果看着是一样的？</p><p>通过查看源码发现，Click中调用了Command方法</p><p>既然两者一样，那我为什么不用click而要用command，click看着还更简单诶</p><p>个人关于这块的理解是：有时候一个窗口或控件，会绑定不同的DataContext，如果用click，还需要对DataContext的类型做判断后，采用不同的逻辑</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>用到了ViewLocator，参考张引的视频，博客：<a href="https://www.cnblogs.com/simonoct/p/18976504">Avalonia 学习笔记04. Page Navigation（页面导航） - simonoct - 博客园</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        &lt;!--当Content发生变化时就会显示Content页面，注意：根据RootNavigationService内部的原理，Binding Content中的Content实际上是个ViewModel，</span><br><span class="line">        所以要想显示页面，在RootNavigationService中去不断改变Content，引起属性变化</span><br><span class="line">        avalonia 中 ContentControl 会自动将 Content 作为自身 DataContext，一旦content发生变化，此时框架会触发ServiceLocator中滚动 Match 方法，然后是build方法，将ViewModel转换为对应的View，最终显示在ContentControl中--&gt;</span><br><span class="line">        &lt;!--当前页面需要嵌套另一个页面就使用ContentControl控件，控件中的Content属性相当于当前ContentControl的datacontext，对应的是其他的ViewModel，这样如果绑定到不同的页面我们只需要改变Content即可--&gt;</span><br><span class="line">        &lt;ContentControl Content=&quot;&#123;Binding Content&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/ContentControl&gt;</span><br><span class="line">        </span><br><span class="line">后端的</span><br></pre></td></tr></table></figure><p>所有导航方式可以参考视频：<a href="https://www.bilibili.com/video/BV1a94y1r7cA?spm_id_from=333.788.videopod.sections&vd_source=b7cae512e14e0a063a1ab014969b6164">WPF中如何在MVVM模式下实现导航功能_哔哩哔哩_bilibili</a></p><h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p><a href="https://docs.avaloniaui.net/zh-Hans/docs/guides/data-binding/how-to-create-a-custom-data-binding-converter">https://docs.avaloniaui.net/zh-Hans/docs/guides/data-binding/how-to-create-a-custom-data-binding-converter</a></p><p><strong>转换器</strong> 是一个实现了特定接口的类，它的核心作用是：<strong>在数据绑定过程中，对源数据和目标控件之间的数值进行双向或单向的格式转换</strong>。当源数据的类型 ≠ 控件需要的类型时，就使用转换器。比如：源数据是布尔值 <code>true/false</code>，但控件（如 Button）需要的是 <code>Visibility</code> 枚举（Visible&#x2F;Collapsed）。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>单值转换器（IValueConverter）和多值转换器（IMultiValueConverter）</p><h4 id="常见使用场景（通过转换器实现映射关系）"><a href="#常见使用场景（通过转换器实现映射关系）" class="headerlink" title="常见使用场景（通过转换器实现映射关系）"></a>常见使用场景（通过转换器实现映射关系）</h4><ol><li><strong>类型转换</strong>：bool ↔ Visibility、int ↔ string、DateTime ↔ 格式化字符串（如 “2026-01-23”）。将布尔值转换为颜色：true-&gt;绿色，false-&gt;红色</li><li><strong>值映射</strong>：数字枚举（如 0&#x2F;1&#x2F;2）↔ 文字描述（“未开始”&#x2F;“进行中”&#x2F;“已完成”）。</li><li><strong>条件判断</strong>：根据数值范围显示不同样式 &#x2F; 文本（如数值 &gt; 100 显示 “超标”，否则显示 “正常”）。</li></ol><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Avalonia 中所有转换器都需要实现 <code>IValueConverter</code> 接口，这个接口包含两个核心方法：</p><ol><li><p><code>Convert</code>：从<strong>源数据 → 目标控件</strong>的转换（最常用）。</p></li><li><p><code>ConvertBack</code>：从<strong>目标控件 → 源数据</strong>的转换（双向绑定时使用）。</p><p>举例：一个Button控件，当实现 “布尔值为 true 时控件显示，false 时隐藏”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 自定义转换器：布尔值 → Visibility</span><br><span class="line">public class BoolToVisibilityConverter : IValueConverter</span><br><span class="line">&#123;</span><br><span class="line">    // 源数据（bool）→ 目标控件（Visibility）</span><br><span class="line">    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)</span><br><span class="line">    &#123;</span><br><span class="line">        // 校验输入值是否为bool类型</span><br><span class="line">        if (value is bool boolValue)</span><br><span class="line">        &#123;</span><br><span class="line">            // true → Visible（显示），false → Collapsed（隐藏且不占空间）</span><br><span class="line">            return boolValue ? Visibility.Visible : Visibility.Collapsed;</span><br><span class="line">        &#125;</span><br><span class="line">        // 非bool值默认隐藏</span><br><span class="line">        return Visibility.Collapsed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 目标控件 → 源数据（双向绑定时用，这里不需要则返回null）</span><br><span class="line">    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)</span><br><span class="line">    &#123;</span><br><span class="line">        if (value is Visibility visibility)</span><br><span class="line">        &#123;</span><br><span class="line">            return visibility == Visibility.Visible;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 XAML 中使用转换器</p><ol><li><p>先在 XAML 中引入转换器所在的命名空间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:converters=&quot;using:YourApp.Converters&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>注册声明转换器实例</li></ol></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window.Resources&gt;  </span><br><span class="line">&lt;converters:BoolToVisibilityConverter x:Key=&quot;BoolToVisibility&quot;/&gt; &lt;/Window.Resources&gt;</span><br></pre></td></tr></table></figure><p>3.在绑定中使用转换器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Content=&quot;测试按钮&quot;</span><br><span class="line">        Visibility=&quot;&#123;Binding IsShowButton, Converter=&#123;StaticResource BoolToVisibility&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><a href="https://zhuanlan.zhihu.com/p/689871389">WPF打包成单个可执行的exe文件 - 知乎</a></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><strong>1.设置窗口大小</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window 。。。</span><br><span class="line">//设置预览时窗口大小</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;400&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">       。。。</span><br><span class="line">        Title=&quot;AvaloniaProTest2&quot;</span><br><span class="line">        //设置程序运行时窗口大小</span><br><span class="line">        Width=&quot;400&quot;</span><br><span class="line">        Height=&quot;450&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>2.调试代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using Avalonia.Interactivity;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">在方法中加入下面一句</span><br><span class="line">Debug.WriteLine($&quot;Click! Celsius=&#123;Celsius.Text&#125;&quot;);</span><br></pre></td></tr></table></figure><p><strong>3.Partial的作用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如App.axaml文件最终会将其编译为一个App的类，而App.axaml.cs最终也会编译为一个App类，这样就会类名重复，导致报错，因此使用Partial指明最终将这两个文件编译为同一个App类.</span><br></pre></td></tr></table></figure><p><strong>4.null与“”与String.empty的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">null 它不是一个有效的字符串实例，意味着该变量在堆内存中没有对应的内存空间分配</span><br><span class="line">&quot;&quot;  它表示一个有效的字符串实例，只是这个实例的内容为空（长度为 0，不含任何字符）。</span><br><span class="line">String.empty其本质就是一个内容为空的字符串实例（长度为 0），与“”本质一样</span><br><span class="line">举例</span><br><span class="line">string strNull = null;</span><br><span class="line">string strEmpty1 = &quot;&quot;;</span><br><span class="line">string strEmpty2 = string.Empty;</span><br><span class="line"></span><br><span class="line">// 报错：NullReferenceException，null 没有对应的实例，无法调用 Length 属性</span><br><span class="line">int length1 = strNull.Length;</span><br><span class="line">// 正常执行，返回 0（空字符串的长度为 0）</span><br><span class="line">int length2 = strEmpty1.Length; // 0</span><br><span class="line">int length3 = strEmpty2.Length; // 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">为什么定义字符串变量时需要给它指定为空字符串？</span><br><span class="line">1.如果默认将字符串设为 null，为了保证程序健壮性，你在使用该字符串的任何地方，都必须先添加 null 判断逻辑（if (str != null)），否则就有抛出异常的风险。</span><br><span class="line"></span><br><span class="line">变量默认设为 null（冗余且繁琐）：</span><br><span class="line">string str = null; // 默认null</span><br><span class="line">// 使用前必须先做null检查，否则可能报错</span><br><span class="line">if (str != null &amp;&amp; str.Length &gt; 5) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;字符串长度大于5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.变量默认设为空字符串（简洁且高效）：</span><br><span class="line">string str = string.Empty; // 默认空字符串</span><br><span class="line">// 无需null检查，直接使用，逻辑更简洁</span><br><span class="line">if (str.Length &gt; 5) </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;字符串长度大于5&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">如果不给字符串变量指定默认值会怎么样？</span><br><span class="line">1.如果是在方法、if 代码块、for 循环等内部声明的局部字符串变量，只声明不手动赋值（「什么也不写」），编译阶段就会报错，无法通过编译，更无法运行。</span><br><span class="line">public void TestMethod()</span><br><span class="line">&#123;</span><br><span class="line">    // 只声明局部字符串变量，不手动赋值（什么也不写）</span><br><span class="line">    string str; </span><br><span class="line">    </span><br><span class="line">    // 尝试使用该变量（即使只是打印）</span><br><span class="line">    Console.WriteLine(str); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.如果是在类或结构体中声明的字符串成员变量（字段），只声明不手动赋值（「什么也不写」），编译可以通过，且会被编译器自动初始化为 null</span><br><span class="line">// 定义一个类</span><br><span class="line">public class TestClass</span><br><span class="line">&#123;</span><br><span class="line">    // 只声明字符串成员变量，不手动赋值（什么也不写）</span><br><span class="line">    public string str; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用测试</span><br><span class="line">public void Test()</span><br><span class="line">&#123;</span><br><span class="line">    TestClass testObj = new TestClass();</span><br><span class="line">    // 打印成员变量str的值，结果为 null</span><br><span class="line">    Console.WriteLine(testObj.str == null); // 输出：True</span><br><span class="line">    Console.WriteLine(testObj.str); // 控制台打印：空行（控制台输出null字符串时显示为空）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.record关键字与class的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.声明record时（默认等价于record class），对象实例创建后无法修改其属性值，天生具备线程安全和数据一致性的优势。</span><br><span class="line">// 简化声明</span><br><span class="line">public record Person(string Name, int Age);</span><br><span class="line"></span><br><span class="line">// 完整声明（显式指定属性）</span><br><span class="line">public record Student</span><br><span class="line">&#123;</span><br><span class="line">    public string StudentId &#123; get; init; &#125; // init设置器，仅初始化时可赋值</span><br><span class="line">    public string Name &#123; get; init; &#125;</span><br><span class="line">    public int Grade &#123; get; init; &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;张三&quot;, 28);</span><br><span class="line">person.Name = &quot;李四&quot;; // 编译错误：无法对init只写属性赋值</span><br><span class="line"></span><br><span class="line">2.基于值的相等性判断（而非引用相等性）</span><br><span class="line">普通class的相等性（==、Equals()）默认判断引用地址是否相同（即是否为同一个对象），而record默认重写了Object.Equals()、==、!=等方法，相等性判断基于所有属性的值是否完全一致，与对象引用无关。</span><br></pre></td></tr></table></figure><p><strong>6.项目分层</strong></p><p>UI层调用ViewModel层，ViewModel层调用Service层</p><p><img src="/2026/01/29/Avalonia/assets/image-20260115075922291.png" alt="image-20260115075922291"></p><p>（1）.Dao层&#x3D;Business层<br>DAO（Data Access Object） 模型就是写一个类，把访问数据库的代码封装起来，DAO在数据库与业务逻辑（Service）之间。</p><p>Dao是数据访问层，Dao的作用是封装对数据库的访问：增删改查，不涉及业务逻辑，只是达到按某个条件获得指定数据的要求。</p><p><img src="/2026/01/29/Avalonia/assets/image-20260114201557134.png" alt="image-20260114201557134"></p><p>（2）.Entity层<br>Entity层，顾名思义就是实体层，放置一个个实体，及其相应的set、get方法。如果想要对数据库进行一些操作（比如说读取）的话，就要先写entity层。</p><p><img src="/2026/01/29/Avalonia/assets/image-20260114201730375.png" alt="image-20260114201730375"></p><p>（3.）Service层</p><p>Service被称作业务逻辑层。顾名思义，它处理逻辑上的业务，而不去考虑具体的实现。</p><p><img src="/2026/01/29/Avalonia/assets/image-20260114201829847.png" alt="image-20260114201829847"></p><p>（4）Controller层&#x3D;ViewModel层</p><p>（5）UI层&#x3D;Page层&#x3D;View层</p><p><strong>7.const与static readonly的区别</strong></p><p>两者都可以表示常量，const是程序编译时确定，而static readonly是程序运行是确定。const可以使用static readonly替代，但后者不能被const替代。</p><ol start="8"><li><strong>可空合并运算符</strong>（<code>??</code>）和<strong>可空合并赋值运算符</strong>（<code>??=</code>）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. </span><br><span class="line">?? 是一个二元运算符，核心功能是：判断左侧操作数是否为 null，如果不为 null，则返回左侧操作数；如果为 null，则返回右侧操作数。</span><br><span class="line">它的本质是简化 if (x != null) return x; else return y;</span><br><span class="line">// 传统if判断（冗余）</span><br><span class="line">string str = null;</span><br><span class="line">string result;</span><br><span class="line">if (str != null)</span><br><span class="line">&#123;</span><br><span class="line">    result = str;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    result = &quot;默认字符串&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并运算符写法（简洁）</span><br><span class="line">string result = str ?? &quot;默认字符串&quot;;</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">??= 是 ?? 的衍生运算符，核心功能是：判断左侧变量是否为 null，如果为 null，则将右侧操作数的值赋值给左侧变量；如果不为 null，则不执行任何操作（保持左侧变量原有值）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li><p><strong>&#x3D;&gt;</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">举例</span><br><span class="line">get=&gt; _massage 等价于</span><br><span class="line">get（）</span><br><span class="line">&#123;</span><br><span class="line">  return _massage//有返回值</span><br><span class="line">&#125;</span><br><span class="line">举例2</span><br><span class="line">public async Task InsertAsync() =&gt;</span><br><span class="line">    await _poetryStorage.InsertAsync( new Poetry &#123; Name = &quot;Name&quot; + new Random().Next() &#125;);</span><br><span class="line">等价于</span><br><span class="line">public async Task InsertAsync()</span><br><span class="line">&#123;</span><br><span class="line">var  =  new Poetry();</span><br><span class="line">poetry.Name=&quot;Name&quot; + new Random().Next();</span><br><span class="line">    await _poetryStorage.InsertAsync(poetry);//无返回值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>10.服务定位</strong></p><p><a href="https://blog.csdn.net/weixin_47896156/article/details/129719053">https://blog.csdn.net/weixin_47896156/article/details/129719053</a></p><p>当你已经手动创建并初始化好了某个对象，希望将其放入 DI 容器中，<strong>让整个应用共享该实例</strong>（例如：预配置的第三方客户端、<strong>全局配置对象</strong>）。</p><p>使用<code>ServiceCollection</code>的<code>AddSingleton&lt;T&gt;(T instance)</code>方法，直接将现成实例注册为单例</p><p>第二种方法</p><p><img src="/2026/01/29/Avalonia/assets/image-20260118133248119.png" alt="image-20260118133248119"></p><p>**11.**x:DataType&#x3D;”vm:MainWindowViewModel”是用来检测是否能够进行绑定的。</p><p><strong>12.通过反射获取项目中的资源文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DbName=“文件名”</span><br><span class="line">typeof(类名).Assembly.GetName().Name.ToString()+&quot;.&quot;+DbName)</span><br></pre></td></tr></table></figure><p><strong>13.文件中改类名或者变量名</strong>，使用ctrl+R统一修改</p><p><strong>14.某个方法中调用了异步方法，则该方法也必须被声明为异步方法。</strong></p><p><strong>15.json转类</strong>，在菜单栏选择 <strong>编辑 → 选择性粘贴 → 将 JSON 粘贴为类</strong></p><p><strong>16.遇事不决先编译</strong></p><p>**17.**引入nuget包之后发现无法使用，可能是因为nuget包与avalonia版本不匹配，需要更改nuget包版本</p><p><strong>18</strong>.avalonia创建UserControl页面时，建立的默认的命名空间是错误的，需要手动修改（属于bug）</p><p>**19.程序运行流程：**program.cs -&gt; app.xaml.cs-&gt;mainwindow-&gt;……各种导航了</p><p><strong>20.is与as的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">is 用于判断一个对象是否是指定的类型，返回一个 bool 布尔值，它只做判断，不做转换。新版本中is可以进行转换</span><br><span class="line">value is int count  可以拆解为两层逻辑：</span><br><span class="line">判断：检查 value 是否是 int 类型；</span><br><span class="line">赋值：如果判断为 true，则将 value 转换为 int 类型，并赋值给变量 count；如果为 false，count 变量不会被赋值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">as 用于安全的类型转换，它会尝试将对象转换为指定类型：</span><br><span class="line">如果转换成功，返回转换后的对象；</span><br><span class="line">如果转换失败，返回 null（而非抛出异常）；</span><br><span class="line">value as int   </span><br></pre></td></tr></table></figure><p>2**1：省略if，else的方法。**使用is ，as等等，使用&#x3D;&gt;等等</p><p><strong>22：wpf、avalonia中事件与命令的关系。</strong></p><p>在button中，可以使用view中的command命令绑定到viewmodel对应的方法，其默认执行的事件是click事件，但是在其他控件中没有对应的默认关系，所以需要使用行为（behavior）去关联事件与command之间的关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListBox Grid.Row=&quot;1&quot;</span><br><span class="line">             ItemsSource=&quot;&#123;Binding Source=&#123;x:Static lvm:MenuItem.MenuItems&#125;&#125;&quot;</span><br><span class="line">             SelectedItem=&quot;&#123;Binding SelectedMenuItem, Mode=TwoWay&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 使用Interaction.Triggers将SelectionChanged事件转为命令 --&gt;</span><br><span class="line">        &lt;i:Interaction.Triggers&gt;</span><br><span class="line">            &lt;i:EventTrigger EventName=&quot;SelectionChanged&quot;&gt;</span><br><span class="line">                &lt;i:InvokeCommandAction Command=&quot;&#123;Binding MenuTappedCommand&#125;&quot;</span><br><span class="line">                                       CommandParameter=&quot;&#123;Binding SelectedItem, RelativeSource=&#123;RelativeSource AncestorType=ListBox&#125;&#125;&quot;/&gt;</span><br><span class="line">            &lt;/i:EventTrigger&gt;</span><br><span class="line">        &lt;/i:Interaction.Triggers&gt;</span><br><span class="line">    &lt;/ListBox&gt;</span><br></pre></td></tr></table></figure><p><strong>23.设计某一个功能时</strong>，按照serviceice层，viewmodel层和View层的方式进行设计，因为View层仅仅是显示界面，其调用Viewmodel层，而Viewmodel层是调用Service层</p><p>**24.解决xaml回车后属性不对齐的问题：**工具-》 选项-》格式化-》在单独的行上对齐</p><p><img src="/2026/01/29/Avalonia/assets/image-20260124104144777.png" alt="image-20260124104144777"></p><p><strong>25.按钮乱码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">更改字体后重启vs</span><br><span class="line">&lt;Button Content=&quot;中文按钮&quot; FontFamily=&quot;Microsoft YaHei&quot;/&gt;</span><br></pre></td></tr></table></figure><p>**26.函数什么时候加async？**调用其他异步函数的时候</p><p><strong>27.ItemsControl和ListBox的区别</strong></p><p>ItemsControl用来展示多组控件(没有selecteditem选中功能)，而listbox用来展示多组数据（有selecteditem选中功能）</p><p>28.this关键字：this关键字在哪个类中就属于哪个类，与该方法在哪个类中被调用无关。</p><p><strong>29.x:static 和binding的区别：</strong></p><p><code>x:Static</code>适合固定不变的静态数据（如枚举、常量列表），<code>Binding</code>适合运行时可能变化的业务数据。</p><p><strong><code>x:Static</code></strong>：本质是<strong>静态值引用</strong>，它直接获取程序中一个<strong>静态字段 &#x2F; 属性 &#x2F; 常量</strong>的值，是一种<strong>一次性的、静态的取值方式</strong>，在 XAML 解析阶段就确定了最终值，运行时不会自动更新。</p><p><strong><code>Binding</code></strong>：本质是<strong>动态数据绑定</strong>，它建立的是 “数据源” 和 “UI 控件” 之间的<strong>双向 &#x2F; 单向动态关联</strong>，当数据源的属性值发生变化时，UI 会自动更新；反之（双向绑定）UI 变化也会同步到数据源。<code>Binding</code>也可以绑定静态属性，但需要用<code>{Binding Source={x:Static lvm:XXX}, Path=静态属性名}</code>的形式。</p><p><strong>30.xmlns与binding的区别：</strong></p><p><code>xmlns</code> (XML Namespace)命名空间声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以  </span><br><span class="line">（1）xmlns:lvm=&quot;using:PoetryPro.Library.ViewModels&quot; </span><br><span class="line">（2）DataContext=&quot;&#123;Binding QueryViewModel, Source=&#123;StaticResource ServiceLocator&#125;&#125;&quot;为例</span><br><span class="line">解释：</span><br><span class="line">（1）中前缀lvm对应的是PoetryPro.Library.ViewModels这个代码命名空间，XAML 中通过lvm:就能找到该命名空间下的所有类，解决 “XAML 认识哪个类” 的问题。</span><br><span class="line">使用场景：仅引用静态成员，不需要数据进行动态更新</span><br><span class="line">（2）DataContext中解决 “UI 控件的 Binding 该从哪个对象拿数据” 的问题。</span><br><span class="line">使用场景：需要数据进行动态更新</span><br></pre></td></tr></table></figure><p>31.前端向后端传递数据</p><p><img src="/2026/01/29/Avalonia/assets/image-20260125120112776.png" alt="image-20260125120112776"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（1）向后端传递一个参数</span><br><span class="line">前端</span><br><span class="line">&lt;TextBox x:Name=&quot;SearchTextBox&quot; PlaceholderText=&quot;请输入关键词&quot;/&gt;</span><br><span class="line">&lt;Button Content=&quot;搜索&quot; </span><br><span class="line">        Command=&quot;&#123;Binding SearchCommand&#125;&quot; &lt;!-- 自动生成的命令属性 --&gt;</span><br><span class="line">        CommandParameter=&quot;&#123;Binding Text, ElementName=SearchTextBox&#125;&quot;/&gt; </span><br><span class="line"> </span><br><span class="line"> 后端：</span><br><span class="line"> [RelayCommand]</span><br><span class="line">private void Search(string keyword)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;搜索关键词：&#123;keyword&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">（2）向后端传递两个参数</span><br><span class="line">步骤 1：定义参数实体类</span><br><span class="line">// 封装需要传递的多个参数</span><br><span class="line">public class LoginParams</span><br><span class="line">&#123;</span><br><span class="line">    public string Username &#123; get; set; &#125;  // 第一个参数：用户名</span><br><span class="line">    public string Password &#123; get; set; &#125;  // 第二个参数：密码</span><br><span class="line">&#125;</span><br><span class="line">步骤 2：ViewModel 中定义带参数的命令</span><br><span class="line">public partial class LoginViewModel : ObservableObject</span><br><span class="line">&#123;</span><br><span class="line">    // 用于展示结果</span><br><span class="line">    [ObservableProperty]</span><br><span class="line">    private string loginResult = &quot;未登录&quot;;</span><br><span class="line"></span><br><span class="line">    // 定义接收封装对象的命令</span><br><span class="line">    [RelayCommand]</span><br><span class="line">    private void Login(LoginParams loginParams)</span><br><span class="line">    &#123;</span><br><span class="line">        // 解构获取两个参数</span><br><span class="line">        string username = loginParams.Username;</span><br><span class="line">        string password = loginParams.Password;</span><br><span class="line"> </span><br><span class="line"> 步骤3：xaml中实现传递对象</span><br><span class="line"> &lt;TextBox x:Name=&quot;TxtUsername&quot; Width=&quot;200&quot; PlaceholderText=&quot;请输入用户名&quot;/&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 第二个参数：密码输入框 --&gt;</span><br><span class="line">        &lt;PasswordBox x:Name=&quot;PwdPassword&quot; Width=&quot;200&quot; PlaceholderText=&quot;请输入密码&quot;/&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- 登录按钮：传递封装后的对象参数 --&gt;</span><br><span class="line">        &lt;Button Content=&quot;登录&quot; </span><br><span class="line">                Command=&quot;&#123;Binding LoginCommand&#125;&quot;&gt;</span><br><span class="line">            &lt;Button.CommandParameter&gt;</span><br><span class="line">                &lt;!-- 封装两个参数为LoginParams对象 --&gt;</span><br><span class="line">                &lt;local:LoginParams </span><br><span class="line">                    Username=&quot;&#123;Binding Text, ElementName=TxtUsername&#125;&quot;</span><br><span class="line">                    Password=&quot;&#123;Binding Password, ElementName=PwdPassword&#125;&quot;/&gt;</span><br><span class="line">            &lt;/Button.CommandParameter&gt;</span><br><span class="line">        &lt;/Button&gt;</span><br></pre></td></tr></table></figure><p>32：导航过程中，尽量不要使用传递对象进行导航，而是使用传递字符串进行导航，最终再将字符串转换为View类型</p><p>33.程序如果使用多项目构建的方式，例如View和Library项目，应将View项目中的ViewModelBase删掉，在Library中新建一个ViewModelBase类</p><p>同时，需要修改ViewLocator中的name值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name = param.GetType().FullName!.Replace(&quot;ViewModel&quot;, &quot;View&quot;, StringComparison.Ordinal).Replace(&quot;PoetryPro.Library&quot;, &quot;PoetryPro&quot;);</span><br></pre></td></tr></table></figure><p>34.Service层获取ViewModel层的对象：（下层调用上层）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceLocator.Current.MainViewModel</span><br><span class="line"></span><br><span class="line">View层的axaml获取ViewModel对象</span><br><span class="line"> DataContext=&quot;&#123;Binding MainViewModel, Source=&#123;StaticResource ServiceLocator&#125;&#125;&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 为什么会出现Service层调用ViewModel层的情况：</span><br><span class="line"> 因为需要该ViewModel层的一些参数或者属性，例如PoetryPro项目中的MainViewModel中的SetMenuAndContent()方法就被MenuNavigationService调用。</span><br></pre></td></tr></table></figure><p>35.静态绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlns:lvm = &quot;using:PoetryPro.Library.ViewModels&quot;</span><br><span class="line"></span><br><span class="line">&lt;ListBox Grid.Row=&quot;1&quot;</span><br><span class="line"> ItemsSource=&quot;&#123;Binding Source=&#123;x:Static lvm:MenuItem.MenuItems&#125;&#125;&quot;</span><br><span class="line"> SelectedItem=&quot;&#123;Binding SelectedMenuItem, Mode=TwoWay&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="报错解决方案"><a href="#报错解决方案" class="headerlink" title="报错解决方案"></a>报错解决方案</h2><p>1.Cannot parse a compiled binding without an explicit x:DataType directive to give a starting data type for bindings</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解决办法：项目属性里面 AvaloniaUseCompiledBindingsByDefault 修改为 fasle, &lt;AvaloniaUseCompiledBindingsByDefault&gt;false&lt;/AvaloniaUseCompiledBindingsByDefault&gt;</span><br></pre></td></tr></table></figure><p>2.针对使用ObservableProperty时出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">针对使用ObservableProperty时出现错误</span><br><span class="line">[ObservableProperty] </span><br><span class="line">public string Message; </span><br><span class="line">The field AvaloniaZhangYinProject.ViewModels.MainWindowViewModel.Message cannot be used to generate an observable property, as its name would collide with the field name (instance fields should use the &quot;lowerCamel&quot;, &quot;_lowerCamel&quot; or &quot;m_lowerCamel&quot; pattern)</span><br><span class="line">解决办法，将Message的首字母小写message，或者使用_message,但是在xaml文件中使用的仍然是Message，因为ObservableProperty底层自动会将message解析为Message</span><br><span class="line">注意2：使用[ObservableProperty]注释的属性必须是私有字段，不是public</span><br><span class="line">注意3：其他函数在使用ObservableProperty标注的属性时，必须使用的首字母大写的Message，不能使用小写的message</span><br><span class="line">即正确的写法如下：</span><br><span class="line">[ObservableProperty]</span><br><span class="line">private string _message = &quot;before update&quot;;</span><br><span class="line"></span><br><span class="line">[RelayCommand]</span><br><span class="line">public async Task void SayHelloAsync()</span><br><span class="line">&#123;</span><br><span class="line">    // 2. 赋值给自动生成的公共属性Message，而非原始字段_message</span><br><span class="line">    Message = &quot;Say Hello Avalonia&quot;;</span><br><span class="line">&#125;</span><br><span class="line">注意4：使用异步函数绑定时，前端绑定应写为SayHelloCommand进行绑定，而不是SayHelloAsyncCommand</span><br></pre></td></tr></table></figure><p>3.前端显示值不发生变化。</p><p>参考2中的注意3</p><p>参考2中的主要4</p><p>函数命名时，不能以On或者以In开头，容易与MVVM.toolkit重名，导致前端与后端的函数绑定不上</p><p>avalonia创建UserControl页面时，建立的默认的命名空间是错误的，需要手动修改（属于bug）</p><ol start="4"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.InvalidOperationException:“Unable to resolve service for type &#x27;PoetryPro.Library.Services.IPoetryStorage&#x27; while attempting to activate &#x27;PoetryPro.Library.ViewModels.ResultViewModel&#x27;.”</span><br><span class="line">属于依赖注入错误</span><br><span class="line">解决方法：</span><br><span class="line"> ServiceLocator 中只通过 serviceCollection.AddSingleton&lt;ResultViewModel&gt;() 注册了 ResultViewModel，但ResultViewModel 的构造函数中明确依赖了 IPoetryStorage 接口（类似如下代码），却没有将 IPoetryStorage 及其对应的具体实现类注册到依赖注入容器中，容器无法知晓该如何创建 IPoetryStorage 实例，因此抛出解析失败异常。因此需将接口及其实现类进行依赖注入。</span><br><span class="line"> serviceCollection.AddSingleton&lt;IPoetryStorage, PoetryStorage&gt;();</span><br></pre></td></tr></table></figure><ol start="5"><li><p>按钮默认不可用的情况</p><p>说明前端这块绑定错误</p><p>ServiceLocator未创建实例，导致前端的datacontext与后端的对应的viewmodel绑定不上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：public ResultViewModel ResultViewModel =&gt;</span><br><span class="line">   _serviceProvider.GetRequiredService&lt;ResultViewModel&gt;();</span><br></pre></td></tr></table></figure></li><li><p>Unable to resolve type FilterType from namespace using:PoetryPro.Library.ViewModels 第 41 行，位置 35。</p><p>解决：是因为在后台的类文件中少了一个大括号，导致类不能被识别出来</p></li></ol><h2 id="项目1（PoetryPro）"><a href="#项目1（PoetryPro）" class="headerlink" title="项目1（PoetryPro）"></a>项目1（PoetryPro）</h2><p>导航共包含三级。（1）MainWindowView   (2)MainView   （3）ContentView</p><p>（1）整个项目的View之间关系<img src="/2026/01/29/Avalonia/assets/%E5%B9%BB%E7%81%AF%E7%89%871.PNG" alt="幻灯片1"></p><p>（2）ContentView</p><p><img src="/2026/01/29/Avalonia/assets/%E5%B9%BB%E7%81%AF%E7%89%872.PNG" alt="幻灯片2"></p><p>（3）ViewModel中的方法及其对应的导航实现关系</p><p><img src="/2026/01/29/Avalonia/assets/%E5%B9%BB%E7%81%AF%E7%89%873.PNG" alt="幻灯片3"></p><p><img src="/2026/01/29/Avalonia/assets/%E5%B9%BB%E7%81%AF%E7%89%874.PNG" alt="幻灯片4"></p><p>项目结构：PoetryPro是View项目，PoetryPro.Library是第二个项目，View项目和Library中都包含Services层，View项目的Service层主要因为需要引入ServiceLocator中的对象，所以将其写在View项目中，其他的service及其所有接口都是写在Library的项目中</p><p><img src="/2026/01/29/Avalonia/assets/image-20260127193918656.png" alt="image-20260127193918656"><img src="/2026/01/29/Avalonia/assets/image-20260127200148294.png" alt="image-20260127200148294"><img src="/2026/01/29/Avalonia/assets/image-20260127195750969.png" alt="image-20260127195750969"> </p><p>项目思路：</p><p>（1）构建两个项目：包括View项目和Library项目，建立数据库字段和实体类之间的关系(Models层)。</p><p>（2）建立Service层，实现包括数据库，导航，警告的业务逻辑。使用服务定位器模式进行DI注入。</p><p>删掉view项目中的ViewModels，以及需要修改ViewLocator中的name</p><p>（3）构建ViewModel层：实现ViewModel之间的导航</p><p>（4）建立View层，显示界面。</p><p>注意事项：</p><p>（1）ViewLocator中根据反射获取ViewModel的名字，然后处理字符串获取对应的View，所以，其Match方法在xaml中的ContentCtrol的Content属性或者DataContext发生变化是会被自动调用，接下来调用Build方法。</p><p>（2）写view层只关注viewmodel层，写viewmodel层只关注service层</p><p>（3）viewModel之间导航并进行传参：</p><p>例如想要实现todayviewmodel(发送者)向todaydetailviewmodel（接收者）导航的同时完成传递参数应该怎么办？</p><p>todayviewmodel获得todaydetailviewmodel对象后，要想传参，可以在todaydetailviewmodel中添加一个传参方法，然后在todayviewmodel中调用该传参方法<br>&#x2F;&#x2F;如果任意viewmodel之间传参，就都需要每一个发送的viewmodel都写一个传参方法，在每个接收的viewmodel中调用。为了简化干脆直接写一个通用传参方法（位于接口或者抽象类中），<br>&#x2F;&#x2F;让所有的viewmodel都继承者该接口或者抽象类，这个类就是ViewModelIBase，在里面添加<br>&#x2F;&#x2F;方法，这样每一个继承ViewModelIBase的发送端的viewmodel默认就有个一个传参方法，<br>&#x2F;&#x2F;而发送方法直接写在ContentNavigationService中即可完成在导航的同时完成传参，接收参数那一端直接重写SetParameter方法即可。</p><p>（4）下层调用上层（service层调用ViewModel）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServiceLocator.Current.MainViewModel</span><br><span class="line"></span><br><span class="line">View层的axaml获取ViewModel对象</span><br><span class="line"> DataContext=&quot;&#123;Binding MainViewModel, Source=&#123;StaticResource ServiceLocator&#125;&#125;&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 为什么会出现Service层调用ViewModel层的情况：</span><br><span class="line"> 因为需要该ViewModel层的一些参数或者属性，例如PoetryPro项目中的MainViewModel中的SetMenuAndContent()方法就被MenuNavigationService调用。</span><br><span class="line"> </span><br><span class="line"> ViewModel层调用ViewModel层方法</span><br><span class="line"> 直接构造参数注入即可。</span><br></pre></td></tr></table></figure><h2 id="优质博客（博客园：simonoct）"><a href="#优质博客（博客园：simonoct）" class="headerlink" title="优质博客（博客园：simonoct）"></a>优质博客（博客园：simonoct）</h2><h2 id="（1）Avalonia-学习笔记01-Images-Buttons（图片与按钮）"><a href="#（1）Avalonia-学习笔记01-Images-Buttons（图片与按钮）" class="headerlink" title="（1）Avalonia 学习笔记01. Images &amp; Buttons（图片与按钮）"></a>（1）<a href="https://www.cnblogs.com/simonoct/p/18973395">Avalonia 学习笔记01. Images &amp; Buttons（图片与按钮）</a></h2><p>我对软件的图形化界面很感兴趣，查看了很多框架我最后选定C#的Avalonia作为我第一个学习的框架，不过我发现这个UI框架教程貌似很缺乏。<br>后面到YouTube上搜，看到一个作者制作了一系列教程，虽然是英文，但是我通过语音转文字+AI翻译学习，感觉还是挺不错的。<br>视频地址：<a href="https://youtu.be/ort9IqKAnL4?si=uTEjZ88osw1BLcyk">https://youtu.be/ort9IqKAnL4?si=uTEjZ88osw1BLcyk</a><br>资源下载地址：<a href="https://github.com/angelsix/youtube/tree/develop/Avalonia">https://github.com/angelsix/youtube/tree/develop/Avalonia</a> BatchProcess</p><h3 id="1-1-App-axaml"><a href="#1-1-App-axaml" class="headerlink" title="1.1 App.axaml"></a>1.1 App.axaml</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.App&quot;</span><br><span class="line">             RequestedThemeVariant=&quot;Default&quot;&gt;</span><br><span class="line">             &lt;!-- &quot;Default&quot; ThemeVariant follows system theme variant. &quot;Dark&quot; or &quot;Light&quot; are other available options. --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Application.Styles&gt;</span><br><span class="line">        &lt;FluentTheme /&gt;</span><br><span class="line">        &lt;StyleInclude Source=&quot;Styles/AppDefaultStyles.axaml&quot;&gt;&lt;/StyleInclude&gt;</span><br><span class="line">    &lt;/Application.Styles&gt;</span><br><span class="line">    </span><br><span class="line">     &lt;Application.Resources&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryForeground&quot;&gt;#CFCFCF&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryBackground&quot;&gt;#14172D&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;LinearGradientBrush x:Key=&quot;PrimaryBackgroundGradient&quot; StartPoint=&quot;0%, 0%&quot; EndPoint=&quot;100%, 0%&quot;&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;0&quot; Color=&quot;#111214&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#151E3E&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">         &lt;/LinearGradientBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverBackground&quot;&gt;#333B5A&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverForeground&quot;&gt;White&lt;/SolidColorBrush&gt;</span><br><span class="line">     &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;Application …&gt;: 这是根标签，代表你的整个应用程序。<ul><li><code>xmlns=&quot;...&quot;</code>: 这些是“命名空间”，可以理解为代码的“地址簿”。它告诉编译器 <code>&lt;Button&gt;</code>、<code>&lt;Grid&gt;</code>这些标签应该去哪里找它们的定义。初学时不用太关心，知道是必须的就行。</li><li><code>RequestedThemeVariant=&quot;Default&quot;</code>: 设置应用的主题。Default 会跟随你的操作系统是亮色模式还是暗色模式。你也可以强制设为 Dark 或 Light。</li></ul></li><li><code>&lt;Application.Styles&gt;</code>: <strong>应用的“样式规则手册”</strong>。这里面定义了整个应用的外观规则。<ul><li><code>&lt;FluentTheme /&gt;</code>: 引入 Avalonia 官方提供的 <strong>Fluent UI 主题</strong>。它给了所有控件（按钮、文本框等）一个现代化的、符合 Windows 11 风格的默认外观。</li><li><code>&lt;StyleInclude Source=&quot;Styles/AppDefaultStyles.axaml&quot; /&gt;</code>: <strong>包含我们自己的样式文件</strong>。这行代码告诉“大管家”：“除了官方的 Fluent 主题，再把我们自己写的那个 AppDefaultStyles.axaml 文件里的样式规则也加载进来。” Source 就是文件的路径。使用自定义样式文件可以统一覆盖控件的默认样式，例如直接使用<code>&lt;Button&gt;</code>创建的按钮颜色、鼠标悬停颜色等等，如果一个个button指定颜色不仅混乱，如果遇到修改主题也会变得血雨腥风。</li></ul></li><li><code>&lt;Application.Resources&gt;</code>: <strong>应用的“公共资源仓库”</strong>。这里存放着可以在整个应用中反复使用的“材料”，比如颜色、画刷、图标等。这样做的好处是，如果要改一个颜色，只需要改这里一处，所有用到它的地方都会自动更新。例如AppDefaultStyles.axaml里面就引用了默认的背景颜色、前景颜色，想要变更直接修改颜色即可。<ul><li><code>&lt;SolidColorBrush x:Key=&quot;PrimaryForeground&quot;&gt;#CFCFCF&lt;/SolidColorBrush&gt;</code>:<ul><li><code>SolidColorBrush</code>: 定义一个<strong>纯色画刷</strong>。你可以把它想象成一支只能画一种颜色的油漆刷。</li><li><code>x:Key=&quot;PrimaryForeground&quot;</code>: 给这支油漆刷贴上一个<strong>标签（唯一的钥匙）</strong>，名字叫 PrimaryForeground。之后我们就可以通过这个名字来使用它。</li><li>#CFCFCF: 这是颜色的十六进制代码。</li></ul></li><li><code>&lt;LinearGradientBrush x:Key=&quot;PrimaryBackgroundGradient&quot; ...&gt;</code>: 定义一个<strong>线性渐变画刷</strong>。<ul><li><code>StartPoint=&quot;0%, 0%&quot;</code>: 渐变从<strong>左上角</strong>开始。</li><li><code>EndPoint=&quot;100%, 0%&quot;</code>: 渐变到<strong>右上角</strong>结束。所以这是一个<strong>从左到右的水平渐变</strong>。</li><li><code>&lt;GradientStop Offset=&quot;0&quot; Color=&quot;...&quot; /&gt;</code>: 在渐变轴的<strong>起点 (0%)</strong> 放置这个颜色。</li><li><code>&lt;GradientStop Offset=&quot;1&quot; Color=&quot;...&quot; /&gt;</code>: 在渐变轴的<strong>终点 (100%)</strong> 放置这个颜色。</li></ul></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设StartPoint=<span class="string">&quot;0%, 0%&quot;</span>，EndPoint=<span class="string">&quot;100%, 100%&quot;</span>，那么渐变轴就是右下角方向了。</span><br><span class="line">  </span><br><span class="line">  (0%, 0%)  &lt;-- 起点 (StartPoint)</span><br><span class="line">  +-------------------------+ (100%, 0%)</span><br><span class="line">  | \                       |</span><br><span class="line">  |   \  &lt;-- 渐变轴 (Gradient Axis)</span><br><span class="line">  |     \                   |</span><br><span class="line">  |       \                 |</span><br><span class="line">  +-------------------------+</span><br><span class="line">  (0%, 100%)           (100%, 100%) &lt;-- 终点 (EndPoint)</span><br></pre></td></tr></table></figure><hr><h3 id="1-2-Styles-AppDefaultStyles-axaml"><a href="#1-2-Styles-AppDefaultStyles-axaml" class="headerlink" title="1.2 Styles&#x2F;AppDefaultStyles.axaml"></a>1.2 Styles&#x2F;AppDefaultStyles.axaml</h3><p>新建一个名为Styles的文件夹，然后模板文件可以用Rider新建的时候选择Avalonia Styles，命名为<strong>AppDefaultStyles.axaml</strong>即可。</p><p>这个文件专门用来写我们自定义的样式规则，让应用看起来更个性化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Styles xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Design.PreviewWith&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot; Width=&quot;200&quot;&gt;</span><br><span class="line">            &lt;!-- Add Controls for Previewer Here --&gt;</span><br><span class="line">            &lt;Button Foreground=&quot;White&quot; Content=&quot;Hello World&quot;&gt;&lt;/Button&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Design.PreviewWith&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Add Styles Here --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryHoverForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryHoverBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Styles&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;Styles ...&gt;</code>: 这是一个专门存放样式规则的容器。</p></li><li><p><code>&lt;Design.PreviewWith&gt;</code>: <strong>“设计师预览区”</strong>。这部分代码<strong>非常特别</strong>，它只在 IDE 的预览窗口里显示，<strong>不会被编译到最终的应用里</strong>。它的作用是给你提供一个“画板”，让你在设计样式的时候能立刻看到效果，不然就只能靠重新编译或者脑子想象。</p></li><li><p><code>&lt;Style Selector=&quot;Button&quot;&gt;</code>: <strong>定义一条样式规则</strong>。</p><ul><li><p><code>Selector=&quot;Button&quot;</code>: 这个是“选择器”，意思是“<strong>这条规则将应用到我项目里所有的<code>&lt;Button&gt;</code>控件上</strong>”。</p></li><li><pre><code>&lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot; /&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    :</span><br><span class="line"></span><br><span class="line">    - `Setter`: “设置器”，表示要在这里设置一个属性。</span><br><span class="line">    - `Property=&quot;FontSize&quot;`: 要设置的**属性**是“字体大小”。</span><br><span class="line">    - `Value=&quot;20&quot;`: 把字体大小的**值**设为 20。</span><br><span class="line"></span><br><span class="line">  - `&lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot; /&gt;`: 把文字颜色（Foreground）设置为我们之前在 App.axaml 里定义的、名叫 PrimaryForeground 的那个颜色资源。&#123;DynamicResource ...&#125; 的意思就是“去公共仓库按名字找资源”。</span><br><span class="line"></span><br><span class="line">- `&lt;Style Selector=&quot;Button:pointerover /template/ ContentPresenter&quot;&gt;`: **定义一条更特殊的规则**。</span><br><span class="line"></span><br><span class="line">  - `Selector=&quot;Button:pointerover&quot;`: 这个选择器更具体，它说：“这条规则**只在鼠标指针悬停在按钮上时**才生效”。:pointerover 就是“鼠标悬停”这个特殊状态。</span><br><span class="line">  - `/template/ ContentPresenter`: 这是个固定写法。它的意思是，为了可靠地改变按钮在悬停时的背景和前景，我们需要更深入地指定到按钮内部一个叫 ContentPresenter 的部件。</span><br><span class="line">  - 里面的两个`&lt;Setter&gt;`就定义了当鼠标悬停时，按钮的文字颜色和背景色应该变成我们定义的“Hover”颜色。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### 1.3 MainWindow.axaml</span><br><span class="line"></span><br><span class="line">这是用户能看到的、实际的主窗口。它负责把各种控件（按钮、图片等）组合、摆放起来，形成最终的界面。</span><br><span class="line"></span><br><span class="line">```xaml</span><br><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1024&quot; d:DesignHeight=&quot;600&quot;</span><br><span class="line">        Width=&quot;1024&quot; Height=&quot;600&quot;</span><br><span class="line">        x:Class=&quot;AvaloniaApplication2.MainWindow&quot;</span><br><span class="line">        Title=&quot;AvaloniaApplication2&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Grid Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot; ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot;&gt;</span><br><span class="line">            &lt;Grid RowDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;200&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Button Content=&quot;Home&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    &lt;Button Content=&quot;Process&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    &lt;Button Content=&quot;Actions&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    &lt;Button Content=&quot;Macros&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    &lt;Button Content=&quot;Reporter&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    &lt;Button Content=&quot;History&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;Button Grid.Row=&quot;1&quot; Content=&quot;Setting&quot;&gt;&lt;/Button&gt;</span><br><span class="line">            &lt;/Grid&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window ...&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>窗口</p><p>。这是所有内容的根容器。</p><ul><li><code>d:DesignWidth/Height</code>: <strong>仅在设计预览时</strong>的窗口宽高，方便你设计。</li><li><code>Width/Height</code>: <strong>程序真正运行时</strong>的窗口宽高。</li><li><code>Title</code>: 显示在窗口左上角的标题。</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid ...&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>网格</p><p>。这是布局控件，就像一个看不见的 Excel 表格。</p><ul><li><p><code>Background=&quot;{...}&quot;</code>: 把窗口的背景设置为我们定义的 PrimaryBackground 颜色。</p></li><li><pre><code>ColumnDefinitions=&quot;Auto, *&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    :</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    定义网格的列</span><br><span class="line"></span><br><span class="line">    。这行代码把网格分成了两列：</span><br><span class="line"></span><br><span class="line">    - `Auto`: 第一列的宽度由**其内部最宽的内容自动决定**。</span><br><span class="line">    - `*`: 第二列将**占据所有剩余的可用空间**。这是创建“侧边栏 + 主内容区”布局的经典手法。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;Border ...&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>:</p><p>边框容器</p><p>。它像一个可以设置背景、边框和内边距的盒子。这里它被放在了 Grid 的第一列（Auto 列），用来创建侧边栏。</p><ul><li><code>Padding=&quot;20&quot;</code>: 在这个盒子的<strong>四边都留出 20 个单位的内部空白</strong>，让内容不会紧贴着边缘。</li><li><code>Background=&quot;{...}&quot;</code>: 把这个侧边栏的背景设置为我们定义的那个<strong>渐变色画刷</strong>。</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid RowDefinitions=&quot;*, Auto&quot;&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>在侧边栏内部又放了一个网格</p><p>。这个网格用来做垂直布局。</p><ul><li><pre><code>RowDefinitions=&quot;*, Auto&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    : 把这个内部网格分成了两行：</span><br><span class="line"></span><br><span class="line">    - `*`: 第一行占据**所有剩余的垂直空间**。</span><br><span class="line">    - `Auto`: 第二行的高度由其内容（设置按钮）**自动决定**。</span><br><span class="line">    - **效果**：这会把“设置”按钮“钉”在侧边栏的底部，而上面的部分则会填满剩余空间。</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>:</p><p>堆叠面板</p><p>。它是一个简单的布局控件，会把里面的东西一个接一个地堆起来（默认是垂直方向）。</p><ul><li><code>Spacing=&quot;12&quot;</code>: 在每个被堆起来的控件之间，<strong>增加 12 个单位的间距</strong>。类似于word的行间距。</li><li>这个 StackPanel 被放在了内部 Grid 的第一行 (* 行)。</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Image ...&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>图片</p><p>。</p><ul><li><code>Source=&quot;{SvgImage /Assets/Images/logo.svg}&quot;</code>: 设置图片的来源。<code>{SvgImage ...}</code> 是用来加载 SVG 格式矢量图的特殊语法，路径是相对于项目根目录的。<strong>注意在Rider里面编辑图片属性，将Bulid Action修改为：AvaloniaResource，不然在构建程序的时候这些资源是不会构建的。</strong></li><li><code>Width=&quot;200&quot;</code>: 设置图片显示的宽度为 200。</li><li>注意需要安装一个名为<strong>Svg.Controls.Skia.Avalonia</strong>的包，教程展示用的是过时版本。</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button ...&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>按钮</p><p>。</p><ul><li><code>Content=&quot;Home&quot;</code>: 按钮上显示的文字。</li><li><code>HorizontalAlignment=&quot;Stretch&quot;</code>: <strong>水平对齐方式</strong>。Stretch 意味着让按钮的宽度<strong>拉伸</strong>，以填满其父容器（StackPanel）分配给它的所有水平空间。</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Grid.Row=&quot;1&quot; Content=&quot;Setting&quot; /&gt;</span><br></pre></td></tr></table></figure><p>:</p><p>放在底部的设置按钮</p><p>。</p><ul><li><code>Grid.Row=&quot;1&quot;</code>: 这是一个<strong>附加属性</strong>。它是在告诉<strong>父级的<code>&lt;Grid RowDefinitions=&quot;\*, Auto&quot;&gt;</code></strong>：“请把我这个按钮放在你的第二行（索引从0开始，所以1是第二行）！”，这是实现Setting图标“钉”在底部的关键。</li><li><strong>父级的<code>&lt;Grid RowDefinitions=&quot;\*, Auto&quot;&gt;</code></strong>：第一行 (Row&#x3D;”0”)** 的高度是 <code>*</code>。意思是：“<strong>请占据所有可用的、剩余的垂直空间</strong>”，<strong>第二行 (Row&#x3D;”1”)</strong> 的高度是 <code>Auto</code>。意思是：“我的高度刚刚好能包住我的内容就行”。<code>Row=&quot;1&quot;</code>就是Auto部分，实现setting在侧边栏的底部。</li><li>setting会在左侧的原因貌似有些复杂，根据<a href="https://docs.avaloniaui.net/zh-Hans/docs/basics/user-interface/building-layouts/alignment-margins-and-padding#horizontalalignment-property">文档</a>所说：HorizontalAlignment和VerticalAlignment默认值都是Stretch，也就是拉伸。但是这里表现却是和显式指定<code>Left</code>一致。一个可能的解释是：因为父 Grid 列是 Auto。Auto 列的宽度由子控件的“理想尺寸”决定。虽然按钮的 HorizontalAlignment 默认是 Stretch，但它必须先报告一个尺寸给 Auto 列。这个尺寸就是它包裹其内容（HorizontalContentAlignment 为 Left）所需的最小尺寸。因此，Grid 列和按钮本身都收缩了，Stretch 没有机会发挥作用。</li><li>显式指定 <code>HorizontalAlignment=&quot;Stretch&quot;</code>时，默认保守策略会被覆盖，找一个最大且具体（非无限宽）的宽度，然后拉伸。这里因为<code>&lt;Image ... Width=200&gt;</code>，所以最大宽度就是200。如果想让图标也居中，则需要额外指定<code>HorizontalContentAlignment=&quot;Center&quot;</code></li></ul></li></ul><hr><h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4 &lt;Grid"></a>1.4 &lt;Grid</h3><p>Grid 的核心在于<strong>先定义网格，再放置内容</strong>。</p><h3 id="1-4-1-定义行和列"><a href="#1-4-1-定义行和列" class="headerlink" title="1.4.1 定义行和列"></a>1.4.1 定义行和列</h3><p>用 <code>&lt;Grid.ColumnDefinitions&gt;</code>和<code>&lt;Grid.RowDefinitions&gt;</code>来定义网格的结构。每一列或每一行的大小有三种定义方式：</p><ol><li><strong>Auto (按需分配)</strong>：列宽或行高由其<strong>内部最宽&#x2F;最高的内容</strong>决定。它会“收缩&#x2F;撑开”以正好包裹住内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">    &lt;Button Grid.Column=&quot;0&quot;&gt;短内容&lt;/Button&gt;</span><br><span class="line">    &lt;Button Grid.Column=&quot;1&quot;&gt;这里是很长很长的内容&lt;/Button&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">|-- 由“短内容”决定 --|---------- 占据所有剩余空间 -----------|</span><br><span class="line">|  [ 短内容 ]       |  [ 这里是很长很长的内容 ]              |</span><br><span class="line">|      (Auto)      |                  (*)               |</span><br></pre></td></tr></table></figure><ol><li>*** (星号&#x2F;比例分配)<strong>：这是最强大的方式。它会贪婪地</strong>抢占所有“剩余”的空间**。如果多个列&#x2F;行都是 *，它们会按比例瓜分。</li></ol><ul><li><code>*, *</code>：两个都分 1 份，所以是 1:1，即对半分。</li><li><code>*, 2*</code>：一个分 1 份，一个分 2 份，总共 3 份，所以是 1:2 的比例。</li></ul><p>假设宽度是900px</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|----------- 300px (1份) -----------|----------------- 600px (2份) -----------------|</span><br><span class="line">|                                   |                                              |</span><br><span class="line">|                (*)                |                     (2*)                     |</span><br></pre></td></tr></table></figure><ol><li><strong>固定值 (Fixed Value)</strong>：直接指定一个固定的数字，单位是设备无关像素。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid ColumnDefinitions=&quot;100, *&quot;&gt;</span><br><span class="line">    &lt;Button Grid.Column=&quot;0&quot;&gt;固定100宽&lt;/Button&gt;</span><br><span class="line">    &lt;Button Grid.Column=&quot;1&quot;&gt;剩余所有&lt;/Button&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">|---- 100px ----|------------------ 占据所有剩余空间 ------------------|</span><br><span class="line">| [ 固定100宽 ]  |  [ 剩余所有 ]                                       |</span><br><span class="line">|   (Fixed)     |                         (*)                        |</span><br></pre></td></tr></table></figure><h3 id="1-4-2-放置控件"><a href="#1-4-2-放置控件" class="headerlink" title="1.4.2 放置控件"></a>1.4.2 放置控件</h3><p>使用 Grid.Row 和 Grid.Column 附加属性，告诉每个控件应该去哪个“房间”（单元格）。索引从 0 开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 一个 2x2 的网格 --&gt;</span><br><span class="line">&lt;Grid ColumnDefinitions=&quot;*,*&quot; RowDefinitions=&quot;*,*&quot;&gt;</span><br><span class="line">    &lt;!-- 左上角 (0,0) --&gt;</span><br><span class="line">    &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; Content=&quot;A&quot;/&gt;</span><br><span class="line">    &lt;!-- 右上角 (0,1) --&gt;</span><br><span class="line">    &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; Content=&quot;B&quot;/&gt;</span><br><span class="line">    &lt;!-- 左下角 (1,0) --&gt;</span><br><span class="line">    &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Content=&quot;C&quot;/&gt;</span><br><span class="line">    &lt;!-- 右下角 (1,1) --&gt;</span><br><span class="line">    &lt;Button Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Content=&quot;D&quot;/&gt;</span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">      Column 0 (*)      Column 1 (*)</span><br><span class="line">    +-----------------+-----------------+</span><br><span class="line">    |                 |                 |  Row 0 (*)</span><br><span class="line">    |    [   A   ]    |    [   B   ]    |</span><br><span class="line">    |     (0,0)       |     (0,1)       |</span><br><span class="line">    |                 |                 |</span><br><span class="line">    +-----------------+-----------------+</span><br><span class="line">    |                 |                 |  Row 1 (*)</span><br><span class="line">    |    [   C   ]    |    [   D   ]    |</span><br><span class="line">    |     (1,0)       |     (1,1)       |</span><br><span class="line">    |                 |                 |</span><br><span class="line">    +-----------------+-----------------+</span><br></pre></td></tr></table></figure><h3 id="1-4-3-Grid-可以包含StackPanel吗？"><a href="#1-4-3-Grid-可以包含StackPanel吗？" class="headerlink" title="1.4.3 Grid 可以包含StackPanel吗？"></a>1.4.3 Grid 可以包含StackPanel吗？</h3><p>正如上方教程展示的代码，Grid可以包含StackPanel，后续视频教程可能会深入这里我就简单找一例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;Grid ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Grid的第0列: 放置一个StackPanel来管理一堆按钮 --&gt;</span><br><span class="line">    &lt;StackPanel Grid.Column=&quot;0&quot; Margin=&quot;10&quot; Spacing=&quot;8&quot;&gt;</span><br><span class="line">        &lt;Button&gt;首页&lt;/Button&gt;</span><br><span class="line">        &lt;Button&gt;产品&lt;/Button&gt;</span><br><span class="line">        &lt;Button&gt;设置&lt;/Button&gt;</span><br><span class="line">        &lt;Button&gt;关于&lt;/Button&gt;</span><br><span class="line">    &lt;/StackPanel&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Grid的第1列: 放置主内容 --&gt;</span><br><span class="line">    &lt;Border Grid.Column=&quot;1&quot; Background=&quot;LightGray&quot;&gt;</span><br><span class="line">        &lt;TextBlock VerticalAlignment=&quot;Center&quot; HorizontalAlignment=&quot;Center&quot;&gt;</span><br><span class="line">            主内容区域</span><br><span class="line">        &lt;/TextBlock&gt;</span><br><span class="line">    &lt;/Border&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Grid&gt;</span><br><span class="line">&lt;---------------------------------- Grid (整体框架) -----------------------------------&gt;</span><br><span class="line">+---------------------------------+---------------------------------------------------+</span><br><span class="line">| &lt;-- StackPanel (在第0列) ------&gt; |                                                   |</span><br><span class="line">|                                 |                                                   |</span><br><span class="line">|   +-------------------------+   |                                                   |</span><br><span class="line">|   |       [ 首页 ]           |   |                                                   |</span><br><span class="line">|   +-------------------------+   |                                                   |</span><br><span class="line">|   |       [ 产品 ]           |   |                                                   |</span><br><span class="line">|   +-------------------------+   |                   主内容区域                        |</span><br><span class="line">|   |       [ 设置 ]           |   |                     (第1列)                       |</span><br><span class="line">|   +-------------------------+   |                                                   |</span><br><span class="line">|   |       [ 关于 ]           |   |                                                  |</span><br><span class="line">|   +-------------------------+   |                                                   |</span><br><span class="line">|                                 |                                                   |</span><br><span class="line">+---------------------------------+---------------------------------------------------+</span><br><span class="line">| &lt;------- Col 0 (Auto) --------&gt; | &lt;-------------------- Col 1 (*) -----------------&gt; |</span><br></pre></td></tr></table></figure><h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5 &lt;StackPanel"></a>1.5 &lt;StackPanel</h3><p>StackPanel 的核心是<strong>按顺序线性排列</strong>。它只有两个关键属性你需要关心。</p><h3 id="1-5-1-Orientation-方向"><a href="#1-5-1-Orientation-方向" class="headerlink" title="1.5.1 Orientation (方向)"></a>1.5.1 Orientation (方向)</h3><ul><li>Vertical (默认值): 从上到下堆叠。</li><li>Horizontal: 从左到右排列。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 垂直方向 (默认) --&gt;</span><br><span class="line">&lt;StackPanel&gt;</span><br><span class="line">    &lt;Button&gt;A&lt;/Button&gt;</span><br><span class="line">    &lt;Button&gt;B&lt;/Button&gt;</span><br><span class="line">    &lt;Button&gt;C&lt;/Button&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">+-----------+</span><br><span class="line">| [   A   ] |</span><br><span class="line">+-----------+</span><br><span class="line">| [   B   ] |</span><br><span class="line">+-----------+</span><br><span class="line">| [   C   ] |</span><br><span class="line">+-----------+</span><br><span class="line">&lt;!-- 水平方向 --&gt;</span><br><span class="line">&lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">    &lt;Button&gt;A&lt;/Button&gt;</span><br><span class="line">    &lt;Button&gt;B&lt;/Button&gt;</span><br><span class="line">    &lt;Button&gt;C&lt;/Button&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">+---------+---------+---------+</span><br><span class="line">| [  A  ] | [  B  ] | [  C  ] |</span><br><span class="line">+---------+---------+---------+</span><br></pre></td></tr></table></figure><h3 id="1-5-2-Spacing-间距"><a href="#1-5-2-Spacing-间距" class="headerlink" title="1.5.2 Spacing (间距)"></a>1.5.2 Spacing (间距)</h3><p>在每个子控件之间添加固定的空白。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;StackPanel Spacing=&quot;10&quot;&gt;</span><br><span class="line">    &lt;Button&gt;A&lt;/Button&gt;</span><br><span class="line">    &lt;Button&gt;B&lt;/Button&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">+-----------+</span><br><span class="line">| [   A   ] |</span><br><span class="line">+-----------+</span><br><span class="line">|-- 10px空隙--|  &lt;-- Spacing</span><br><span class="line">+-----------+</span><br><span class="line">| [   B   ] |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h3 id="1-5-3-StackPanel-可以包含-Grid-吗？"><a href="#1-5-3-StackPanel-可以包含-Grid-吗？" class="headerlink" title="1.5.3 StackPanel 可以包含 Grid 吗？"></a>1.5.3 StackPanel 可以包含 Grid 吗？</h3><p><strong>可以</strong></p><p>可能的场景：当你需要构建一个<strong>列表</strong>，而列表中的<strong>每一项本身又是一个复杂的布局</strong>时。例如，一个显示用户信息的垂直列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;StackPanel Spacing=&quot;10&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第一张用户卡片 (一个 Grid) --&gt;</span><br><span class="line">    &lt;Grid ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;Image Grid.Column=&quot;0&quot; Source=&quot;avatar1.png&quot; Width=&quot;50&quot;/&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;1&quot; Margin=&quot;10,0,0,0&quot;&gt;</span><br><span class="line">            &lt;TextBlock&gt;张三&lt;/TextBlock&gt;</span><br><span class="line">            &lt;TextBlock&gt;软件工程师&lt;/TextBlock&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 第二张用户卡片 (另一个 Grid) --&gt;</span><br><span class="line">    &lt;Grid ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;Image Grid.Column=&quot;0&quot; Source=&quot;avatar2.png&quot; Width=&quot;50&quot;/&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;1&quot; Margin=&quot;10,0,0,0&quot;&gt;</span><br><span class="line">            &lt;TextBlock&gt;李四&lt;/TextBlock&gt;</span><br><span class="line">            &lt;TextBlock&gt;UI 设计师&lt;/TextBlock&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line"></span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">+---------------------------------------------+  &lt;-- StackPanel 开始</span><br><span class="line">|                                             |</span><br><span class="line">| +-----------------------------------------+ |  &lt;-- 第一个 Grid 开始</span><br><span class="line">| |          |                              | |</span><br><span class="line">| | [头像1]   |  张三                         | |</span><br><span class="line">| |  (Auto)  |  软件工程师                    | |</span><br><span class="line">| |          |         (*)                  | |</span><br><span class="line">| +-----------------------------------------+ |  &lt;-- 第一个 Grid 结束</span><br><span class="line">|                                             |</span><br><span class="line">|----------------- 10px 间距 -----------------|</span><br><span class="line">|                                             |</span><br><span class="line">| +-----------------------------------------+ |  &lt;-- 第二个 Grid 开始</span><br><span class="line">| |          |                              | |</span><br><span class="line">| | [头像2]  |  李四                         | |</span><br><span class="line">| |  (Auto)  |  UI 设计师                    | |</span><br><span class="line">| |          |         (*)                  | |</span><br><span class="line">| +-----------------------------------------+ |  &lt;-- 第二个 Grid 结束</span><br><span class="line">|                                             |</span><br><span class="line">+---------------------------------------------+  &lt;-- StackPanel 结束</span><br></pre></td></tr></table></figure><h2 id="（2）Avalonia-学习笔记02-Fonts-and-Animations（字体和动画）"><a href="#（2）Avalonia-学习笔记02-Fonts-and-Animations（字体和动画）" class="headerlink" title="（2）Avalonia 学习笔记02. Fonts and Animations（字体和动画）"></a>（2）<a href="https://www.cnblogs.com/simonoct/p/18976469">Avalonia 学习笔记02. Fonts and Animations（字体和动画）</a></h2><p>视频地址：<a href="https://youtu.be/hAyeGWozi90?si=wio3G6GXImgymaUz">https://youtu.be/hAyeGWozi90?si=wio3G6GXImgymaUz</a></p><h3 id="2-1-App-axaml"><a href="#2-1-App-axaml" class="headerlink" title="2.1 App.axaml"></a>2.1 App.axaml</h3><p>引入自定义字体，这些字体如Phosphor还包含emoji，直接通过unicode调用而避免多个svg下载调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.App&quot;</span><br><span class="line">             RequestedThemeVariant=&quot;Default&quot;&gt;</span><br><span class="line">             &lt;!-- &quot;Default&quot; ThemeVariant follows system theme variant. &quot;Dark&quot; or &quot;Light&quot; are other available options. --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Application.Styles&gt;</span><br><span class="line">        &lt;FluentTheme /&gt;</span><br><span class="line">        &lt;StyleInclude Source=&quot;Styles/AppDefaultStyles.axaml&quot;&gt;&lt;/StyleInclude&gt;</span><br><span class="line">    &lt;/Application.Styles&gt;</span><br><span class="line">     &lt;Application.Resources&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryForeground&quot;&gt;#CFCFCF&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryBackground&quot;&gt;#14172D&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;LinearGradientBrush x:Key=&quot;PrimaryBackgroundGradient&quot; StartPoint=&quot;0%, 0%&quot; EndPoint=&quot;100%, 0%&quot;&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;0&quot; Color=&quot;#111214&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#151E3E&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">         &lt;/LinearGradientBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverBackground&quot;&gt;#333B5A&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverForeground&quot;&gt;White&lt;/SolidColorBrush&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoPro&quot;&gt;/Assets/Fonts/AkkoPro-Regular.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoProBold&quot;&gt;/Assets/Fonts/AkkoPro-Bold.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor&quot;&gt;/Assets/Fonts/Phosphor.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor-Fill&quot;&gt;/Assets/Fonts/Phosphor-Fill.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure><ul><li><p>新增<code>&lt;FontFamily ...&gt;</code>(字体家族)</p><p>: 让程序展示时可以选择某个特定的字体风格，但需要先下载、存放，然后将Bulid Action修改为：AvaloniaResource。</p><ul><li><p><code>x:Key=&quot;AkkoPro&quot;</code>: 我们给这个字体起了个<strong>昵称（Key）</strong>，叫做 AkkoPro。之后在应用的其他地方，我们就可以通过这个昵称来使用它。</p></li><li><p>路径语法 (最关键的部分！)</p><p>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Assets/Fonts/AkkoPro-Regular.ttf#Akko Pro</span><br></pre></td></tr></table></figure><ul><li>这串字符分为两部分，由一个 # 分隔，<strong>两部分都非常重要</strong>。</li><li><strong># 前面的部分</strong>: <code>/Assets/Fonts/AkkoPro-Regular.ttf</code>是字体文件在项目中的<strong>物理路径</strong>。它告诉 Avalonia 去哪里找这个 .ttf 文件。</li><li><strong># 后面的部分</strong>: <code>Akko Pro</code> 是这个字体文件内部定义的<strong>真正的“字体家族名称”</strong>。你可以在 Windows 或 macOS 中双击字体文件，在预览窗口看到的那个名字。</li><li><strong>为什么要这样写？</strong> 因为一个字体家族（比如 “微软雅黑”）可能包含多个文件（常规体、粗体、细体）。通过指定相同的 #字体家族名称，Avalonia 才能把这些不同的文件识别为“一家人”，从而正确地应用粗体、斜体等样式。<strong>必须严格匹配。</strong></li></ul></li></ul></li></ul><hr><h3 id="2-2-Styles-AppDefaultStyles-axaml"><a href="#2-2-Styles-AppDefaultStyles-axaml" class="headerlink" title="2.2 Styles&#x2F;AppDefaultStyles.axaml"></a>2.2 Styles&#x2F;AppDefaultStyles.axaml</h3><p>定义按钮的样式，还要为图标、带图标的按钮、动画效果等制定规则。</p><p>这里的代码顺序和视频的不完全一样，方便记录笔记，能正常用。教程展示时用了不少margin修复字体不在button中心线上的BUG，但是新版本Avalonia(11.3.2)已经修复，所以相关的修复样式不包含在下方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;Styles xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Design.PreviewWith&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot; Width=&quot;200&quot;&gt;</span><br><span class="line">            &lt;!-- Add Controls for Previewer Here --&gt;</span><br><span class="line">            &lt;!-- 这是一个预览区，包含了我们所有类型的按钮，让我们在编写样式时能立刻看到所有变化 --&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;200&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2C2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE346;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE7F2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE3EE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEB7A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE03A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Design.PreviewWith&gt;</span><br><span class="line">&lt;!-- ======== 核心样式规则 ======== --&gt;</span><br><span class="line">    &lt;!-- Add Styles Here --&gt;</span><br><span class="line">    &lt;!-- 1. 全局字体设定 (可选) --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Window&quot;&gt;</span><br><span class="line">        &lt;!-- &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt; --&gt;</span><br><span class="line">        &lt;!-- 这行被注释掉了，但它的作用是让整个应用的所有文字默认都使用 AkkoPro 字体。</span><br><span class="line">             这是一种高效的全局样式设置方法，利用了“属性继承”的特性。 --&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 2. 图标的基础样式 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon, Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor-Fill&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0 2 5 0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;19&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 3. “仅图标”样式的覆盖规则 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">     &lt;!-- 4. 文本部分的字体样式 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button, Label.akko&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 5. 所有按钮的基础外观 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;CornerRadius&quot; Value=&quot;10&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 6. 动画的核心：为所有按钮定义“过渡”效果 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">            &lt;Transitions&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Foreground&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Background&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;TransformOperationsTransition Property=&quot;RenderTransform&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/TransformOperationsTransition&gt;</span><br><span class="line">            &lt;/Transitions&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 7. 标准按钮的“鼠标悬停”效果 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryHoverForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryHoverBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- ======== 特殊按钮：“透明按钮”的系列规则 ======== --&gt;</span><br><span class="line">    &lt;!-- 8. 透明按钮的基础样式 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 9. 透明按钮的图标样式（从“填充”变为“轮廓”） --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 10. 透明按钮的悬停效果：图标放大 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent:pointerover Label&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1.2)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;!-- 11. 透明按钮的悬停效果：保持背景透明 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Styles&gt;</span><br></pre></td></tr></table></figure><ol><li><p>全局字体设定 (<code>Style Selector=&quot;Window&quot;</code>)</p><ul><li>这行被注释掉了，但它的作用是让整个应用的所有文字默认都使用 AkkoPro 字体。这是一种高效的全局样式设置方法，利用了“属性继承”的特性。</li></ul></li><li><p>图标的基础样式 (<code>Label.icon, Label.icon-only</code>)</p><ul><li><p><strong>目标</strong>: 定义所有图标的通用外观。</p></li><li><p><strong>选择器</strong>: Label.icon, Label.icon-only 同时选中了带 icon 类的和带 icon-only 类的 Label。</p></li><li><p>作用</p><p>:</p><ul><li><code>FontFamily</code>: 将字体设置为 Phosphor-Fill（填充样式的图标字体）。</li><li><code>Margin=&quot;0 2 5 0&quot;</code>: 这是一个微调。上边距为2可以修正垂直对齐，右边距为5是为了在图标和文字之间创造一个舒适的间距。</li><li><code>FontSize</code>: 设置图标的大小。</li></ul></li></ul></li><li><p>“仅图标”样式的覆盖规则 (<code>Label.icon-only</code>)</p><ul><li><strong>目标</strong>: 修正只有一个图标时的边距。</li><li><strong>选择器</strong>: <code>Label.icon-only</code> 比上面的选择器更具体且在下方（一样具体的规则，下方规则会覆盖上方规则）。</li><li><strong>核心概念：样式覆盖 (Override)</strong>。当一个控件同时匹配多个样式规则时，<strong>更具体</strong>的规则会<strong>覆盖</strong>掉宽泛的规则。</li><li><strong>作用</strong>: <code>Margin=&quot;0&quot;</code>。因为这个 Label 是单独存在的，旁边没有文字，所以我们不再需要右边的 5 个间距。这条规则会覆盖掉上一条规则中的 Margin 设置，将所有外边距重置为0，让这个单独的图标能在按钮里完美居中。</li></ul></li><li><p>文本部分的字体样式 (<code>Button, Label.akko</code>)</p><ul><li>为所有按钮和带 akko 类的 Label 设置了文字字体。</li></ul></li><li><p>所有按钮的基础外观 (<code>Button</code>)</p><ul><li>为所有按钮设置了统一的字体大小、圆角和默认的前景色&#x2F;背景色。</li></ul></li><li><p>动画的核心：过渡效果 (<code>Button /template/ ContentPresenter</code>)</p><ul><li><strong>目标</strong>: 让所有按钮的颜色和大小变化都变得平滑。</li><li><code>RenderTransform=&quot;scale(1)&quot;</code>: 设置一个“动画前”的初始状态，即原始大小。</li><li><code>Transitions</code>: <strong>这是实现动画的核心。<strong>Avalonia接收这个参数后：“对于任何按钮，当它的背景、前景或大小（Transform）要改变时，花 0.1 秒来平滑过渡。” 这是一个</strong>一次性声明</strong>，之后的所有相关变化都会自动应用此动画。</li></ul></li><li><p>标准按钮的“鼠标悬停”效果 (<code>Button:pointerover ...</code>)</p><ul><li><strong>目标</strong>: 定义鼠标放在<strong>普通按钮</strong>上时，它应该变成什么样子。</li><li><strong>作用</strong>: 改变 <code>Foreground</code> 和 <code>Background</code> 的值为我们预设的悬停颜色。</li><li><strong>它如何与动画配合？</strong> 当鼠标移上去时，这条规则被激活，Avalonia 准备将背景色从 <code>PrimaryBackground</code> 改为 <code>PrimaryHoverBackground</code>。这时，第6条规则里的 <code>Transitions</code> 就会介入：“不立刻改，花0.1秒慢慢变过去”。 于是，实现了平滑的渐变效果。</li></ul></li><li><p>透明按钮的基础样式 (<code>Button.transparent</code>)</p><ul><li><strong>目标</strong>: 创建一种新的按钮变体——透明按钮。</li><li><strong>选择器</strong>: <code>Button.transparent</code> 只会选中那些在 XAML 中被我们写上 <code>Classes=&quot;transparent&quot;</code> 的按钮。</li><li><strong>作用</strong>: 简单地将背景设置为透明。</li></ul></li><li><p>透明按钮的图标样式 (<code>Button.transparent Label.icon-only</code>)</p><ul><li><strong>目标</strong>: 让透明按钮里的图标看起来不一样（例如，更精致）。</li><li><strong>选择器</strong>: 这个选择器非常具体：“找到一个带 <code>transparent</code> 类的按钮，然后再找到它<strong>里面</strong>的那个带 <code>icon-only</code> 类的 <code>Label</code>”。</li><li><strong>作用</strong>: <code>FontFamily=&quot;{DynamicResource Phosphor}&quot;</code>。它将这个特定图标的字体从默认的 <code>Phosphor-Fill (填充)</code> <strong>覆盖</strong>为了 Phosphor (轮廓)。</li></ul></li><li><p>透明按钮的悬停效果：图标放大 (<code>Button.transparent:pointerover Label</code>)</p><ul><li><strong>目标</strong>: 给透明按钮一个独特的悬停反馈。</li><li><strong>选择器</strong>: “当鼠标悬停在一个 <code>transparent</code> 按钮上时，找到它里面的任何 <code>Label</code>”。</li><li><strong>作用</strong>: <code>RenderTransform=&quot;scale(1.2)&quot;</code>。让图标放大到1.2倍。同样，这个变化也会被第6条规则里的 <code>Transitions</code> 捕捉到，从而产生平滑的放大动画。</li></ul></li><li><p>透明按钮的悬停效果：保持背景透明 (<code>Button.transparent:pointerover ...</code>)</p><ul><li><strong>目标</strong>: 阻止透明按钮在悬停时出现标准按钮的背景色。</li><li><strong>核心概念：再次覆盖！</strong> 如果没有这条规则，当鼠标悬停在透明按钮上时，它会同时匹配第7条规则（<code>Button:pointerover</code>）和第8条规则（<code>Button.transparent</code>）。通常颜色会覆盖透明，导致出现不想要的背景。</li><li><strong>作用</strong>: <code>Background=&quot;Transparent&quot;</code>。这条规则更具体，它强行规定：“即使是在悬停状态，透明按钮的背景也<strong>必须是透明的</strong>”，从而覆盖了第7条规则中设置悬停背景色的行为。</li></ul></li></ol><hr><h3 id="2-3-MainWindow-axaml"><a href="#2-3-MainWindow-axaml" class="headerlink" title="2.3 MainWindow.axaml"></a>2.3 MainWindow.axaml</h3><p>以前的按钮里只有一个简单的文本，现在我们要把“图标”和“文字”两个东西都放进去，图标使用unicode指定Phosphor内的emoji。<code>&amp;#x</code>是unicode开头，以<code>;</code>结尾，中间的就是Unicode值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1024&quot; d:DesignHeight=&quot;600&quot;</span><br><span class="line">        Width=&quot;1024&quot; Height=&quot;600&quot;</span><br><span class="line">        x:Class=&quot;AvaloniaApplication2.MainWindow&quot;</span><br><span class="line">        Title=&quot;AvaloniaApplication2&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Grid Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot; ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot;&gt;</span><br><span class="line">            &lt;Grid RowDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;200&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2C2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE346;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE7F2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE3EE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEB7A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE03A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">                    &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/Grid&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><ul><li><p>按钮内部的 <code>StackPanel</code></p><p>:</p><ul><li>一个 <code>&lt;Button&gt;</code>的 <code>Content</code> (内容) 属性很灵活，它不只能放文字，可以放<strong>任何单个控件</strong>。</li><li>为了在按钮里并排显示图标和文字，我们先放一个<code>&lt;StackPanel&gt;</code>作为唯一的“容器”。</li><li><code>Orientation=&quot;Horizontal&quot;</code>: 让这个 <code>StackPanel</code>里的东西<strong>从左到右</strong>排列。</li><li>然后，我们在这个水平的 <code>StackPanel</code> 里放入一个用于显示图标的 <code>Label</code> 和一个用于显示文字的 <code>Label</code>。</li></ul></li><li><p><code>Classes=&quot;icon&quot;</code> (贴上标签&#x2F;类)</p><p>:</p><ul><li>这就是我们之前在样式文件中定义的“类选择器”的应用之处。</li><li><code>&lt;Label Classes=&quot;icon&quot; ...&gt;</code>: 我们给这个 <code>Label</code> 贴上了 <code>icon</code> 的标签。于是，AppDefaultStyles.axaml 中那条 <code>Selector=&quot;Label.icon&quot;</code> 的规则就会自动找到它，并把它变成 <code>Phosphor</code> 图标字体、调整它的边距。</li><li><code>&lt;Label Classes=&quot;akko&quot; ...&gt;</code>: 同理，这个 <code>Label</code> 被应用了 <code>akko</code> 字体样式。</li><li><strong>这就是分离的威力</strong>：MainWindow.axaml 只负责<strong>结构和内容</strong>（一个图标挨着一个文字），而 AppDefaultStyles.axaml 负责<strong>外观</strong>（它应该长什么样）。</li></ul></li><li><p><code>Content=&quot;\&amp;\#xE03A;&quot;</code>(Unicode 图标，因为没有字体库通常是无法正常显示)</p><p>:</p><ul><li><strong>图标字体</strong>的原理是，它把一些特殊的 <strong>Unicode 编码</strong>“画”成了图标。</li><li><code>&amp;#x...;</code>是在 XAML 中输入一个十六进制 Unicode 码的标准写法。</li><li>E2C2 就是我们在 Phosphor Icons 网站上查到的“房子”图标对应的编码。</li><li><strong>你不需要记这些编码</strong>，只需要从网站上复制，然后粘贴到 Content 属性里，并用 &amp;#x 和 ; 包起来即可。</li></ul></li><li><p><code>Button Classes=&quot;transparent&quot;</code></p><p>:</p><ul><li>对于底部的设置按钮，我们给它贴上了<code>transparent</code>的标签。</li><li>这样，我们为<code>.transparent</code>类定义的所有样式（背景透明、悬停时图标放大等）就都会自动应用到这个按钮上。</li></ul></li></ul><h3 id="2-4-样式优先级"><a href="#2-4-样式优先级" class="headerlink" title="2.4 样式优先级"></a>2.4 样式优先级</h3><p>AppDefaultStyles.axaml内的样式代码是有顺序的，如果随意调整效果可能不尽如人意，因为样式是由优先级之分！</p><p>后面有一集教程专门讲样式优先级，这里就简单复制一些网上内容。</p><p>最简单来说：<strong>样式选择器越具体，其优先级越高！</strong></p><h3 id="2-4-1-定义-Definition"><a href="#2-4-1-定义-Definition" class="headerlink" title="2.4.1 定义 (Definition)"></a>2.4.1 定义 (Definition)</h3><p><strong>样式优先级</strong>是 Avalonia 用来解决样式冲突的一套确定性规则。当一个控件的同一个属性（如 Background）被多个不同的样式规则同时设置时，Avalonia 会根据这套优先级规则，决定最终应用哪一个样式的值。</p><p>理解这套规则对于调试样式问题和编写可维护的、可预测的 UI至关重要。</p><h3 id="2-4-2-优先级判定规则-The-Rules-of-Priority-Determination"><a href="#2-4-2-优先级判定规则-The-Rules-of-Priority-Determination" class="headerlink" title="2.4.2 优先级判定规则 (The Rules of Priority Determination)"></a>2.4.2 优先级判定规则 (The Rules of Priority Determination)</h3><p>Avalonia 判定优先级遵循一个严格的顺序。以下规则按<strong>从高到低</strong>的优先级排列：</p><p>直接在控件的 XAML 标签上设置的属性值。这是最高优先级，它会覆盖任何来自样式文件的规则。</p><ul><li>用法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Background=&quot;Red&quot; Content=&quot;This will be red&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><p>注意事项</p><p>:</p><ul><li>优先级最高，难以被外部样式覆盖。</li><li>不利于样式复用和统一维护，应尽量避免在大型项目中使用，主要用于快速原型或特定的一次性覆盖。</li></ul></li></ul><p>这是最核心的规则。Avalonia 会评估一个选择器的“具体程度”。选择器的构成越复杂、限制条件越精确，其优先级就越高。</p><ul><li><strong>定义</strong>: 一个选择器的具体性由其构成的组件（如类型、类、伪类）决定。</li><li><strong>用法</strong>: 通过组合不同的选择器来精确地定位目标控件。例如，Button.transparent:pointerover 比 Button:pointerover 更具体。</li><li><strong>详细说明</strong>: 见第3节。</li></ul><p>当两个或多个样式规则的<strong>具体性完全相同时</strong>，在 .axaml 文件中<strong>定义在后面的规则会覆盖定义在前面的规则</strong>。</p><ul><li><strong>用法</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 规则 A --&gt;</span><br><span class="line">&lt;Style Selector=&quot;Button&quot;&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Background&quot; Value=&quot;Blue&quot;/&gt;</span><br><span class="line">&lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 规则 B，具体性与A相同，但定义在后 --&gt;</span><br><span class="line">&lt;Style Selector=&quot;Button&quot;&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Background&quot; Value=&quot;Green&quot;/&gt;</span><br><span class="line">&lt;/Style&gt;</span><br><span class="line">&lt;!-- 结果: 按钮背景为绿色 --&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>注意事项</strong>:<ul><li>这是组织样式文件结构的重要依据。通常将通用的、基础的样式放在文件前面，将特殊的、覆盖性的样式放在后面。</li></ul></li></ul><p>这是优先级最低的样式，由引入的主题（如 ）提供。我们编写的任何自定义样式，只要能匹配到控件，其优先级都高于主题默认样式。</p><h3 id="2-4-3-选择器具体性-Selector-Specificity-详解"><a href="#2-4-3-选择器具体性-Selector-Specificity-详解" class="headerlink" title="2.4.3 选择器具体性 (Selector Specificity) 详解"></a>2.4.3 选择器具体性 (Selector Specificity) 详解</h3><p>一个选择器的具体性由构成它的所有组件共同决定，可以理解为一个加权计分系统。分数越高的选择器，优先级越高。</p><p>以下是各组件的大致权重参考，注意这里计分系统是<strong>教学模型</strong>，帮助理解，官方文档没有这种具体数值：</p><table><thead><tr><th>组件类型</th><th>示例</th><th>权重 (参考值)</th></tr></thead><tbody><tr><td><strong>名称选择器 (Name)</strong></td><td>#MyUniqueButton</td><td><strong>100</strong></td></tr><tr><td><strong>类选择器 (Class)</strong></td><td>.transparent</td><td><strong>10</strong></td></tr><tr><td><strong>伪类 (PseudoClass)</strong></td><td>:pointerover, :disabled</td><td><strong>10</strong></td></tr><tr><td><strong>类型选择器 (Type)</strong></td><td>Button, Label</td><td><strong>1</strong></td></tr></tbody></table><p>让我们用这个权重系统来分析您笔记中的代码：</p><p><strong>场景A: Label.icon-only 的 Margin 覆盖问题</strong></p><ul><li><p>规则 1</p><p>: Style Selector&#x3D;”Label.icon, Label.icon-only”</p><ul><li>对于 Label.icon-only 部分，其具体性 &#x3D; 1 (Label) + 10 (.icon-only) &#x3D; <strong>11</strong>。</li></ul></li><li><p>规则 2</p><p>: Style Selector&#x3D;”Label.icon-only”</p><ul><li>具体性 &#x3D; 1 (Label) + 10 (.icon-only) &#x3D; <strong>11</strong>。</li></ul></li></ul><p>两个规则的具体性分数完全相同。根据 <strong>规则 2.3 (定义顺序)</strong>，写在后面的规则 2 会覆盖规则 1。因此，Margin&#x3D;”0” 生效。</p><p><strong>场景B: Button.transparent:pointerover 的 Background 覆盖问题</strong></p><ul><li><p>规则 1 (标准悬停)</p><p>: Style Selector&#x3D;”Button:pointerover …”</p><ul><li>具体性 &#x3D; 1 (Button) + 10 (:pointerover) &#x3D; <strong>11</strong>。</li></ul></li><li><p>规则 2 (透明悬停)</p><p>: Style Selector&#x3D;”Button.transparent:pointerover …”</p><ul><li>具体性 &#x3D; 1 (Button) + 10 (.transparent) + 10 (:pointerover) &#x3D; <strong>21</strong>。</li></ul></li></ul><p>规则 2 的具体性分数 (21) 高于规则 1 (11)。因此，无论它们的定义顺序如何，Avalonia 都会应用规则 2 的值，Background 被设置为 Transparent。</p><h3 id="2-4-4-特殊修饰符：-important"><a href="#2-4-4-特殊修饰符：-important" class="headerlink" title="2.4.4 特殊修饰符：!important"></a>2.4.4 特殊修饰符：<code>!important</code></h3><p>这是一个可以打破正常优先级规则的特殊工具。</p><p>在 <code>Setter</code> 的<code>Value</code> 字符串末尾添加<code>!important</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Setter Property=&quot;Background&quot; Value=&quot;Red !important&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>极高优先级</strong>: !important 会使该条设置的优先级高于几乎所有其他样式，包括内联样式。</li><li><strong>破坏可维护性</strong>: 滥用 !important 会使样式层级变得混乱，后续调试和覆盖会变得极其困难。</li><li><strong>使用时机</strong>: 仅在万不得已的情况下使用，例如需要覆盖一个第三方控件库中你不便修改的、且优先级很高的样式时。<strong>在自己的项目中应极力避免。</strong></li></ul><h3 id="2-4-5-最佳实践与使用建议-Best-Practices"><a href="#2-4-5-最佳实践与使用建议-Best-Practices" class="headerlink" title="2.4.5 最佳实践与使用建议 (Best Practices)"></a>2.4.5 最佳实践与使用建议 (Best Practices)</h3><ol><li><strong>优先使用类选择器</strong>: 通过为控件添加 Classes 来定义不同的变体，这是管理和覆盖样式的首选方式，清晰且可控。</li><li><strong>合理组织文件</strong>: 将通用样式放在样式文件的顶部，将更具体的或派生的样式放在下面，利用定义顺序规则。</li><li><strong>避免内联样式</strong>: 将样式集中在 .axaml 样式文件中，以实现关注点分离和便于维护。</li><li><strong>谨慎使用 !important</strong>: 将其视为解决棘手问题的最后手段，而不是常规工具。</li></ol><h2 id="（3）Avalonia-学习笔记03-View-Model-Basics（视图模型基础）"><a href="#（3）Avalonia-学习笔记03-View-Model-Basics（视图模型基础）" class="headerlink" title="（3）Avalonia 学习笔记03. View Model Basics（视图模型基础）"></a>（3）<a href="https://www.cnblogs.com/simonoct/p/18976499">Avalonia 学习笔记03. View Model Basics（视图模型基础）</a></h2><p>视频链接：<a href="https://youtu.be/kOLGAUPvRwY?si=idUPT34tn9L9C58j">https://youtu.be/kOLGAUPvRwY?si=idUPT34tn9L9C58j</a></p><p><strong>前置准备</strong>：在开始前，请确保已经通过 NuGet 包管理器为你的项目添加了 CommunityToolkit.Mvvm 包。</p><p>这一节的核心目标是引入 <strong>MVVM</strong> 设计模式中的 <strong>ViewModel</strong>（视图模型）层，实现UI（视图）与数据和逻辑（视图模型）的分离，并通过**数据绑定（Data Binding）**将它们连接起来。</p><p><strong>核心概念：什么是 MVVM？</strong></p><p>MVVM 是一种软件架构模式，旨在将用户界面（View）的开发与业务逻辑和数据（Model）的开发分离开来。</p><ul><li><strong>View (视图)</strong>：用户所看到的界面。在 Avalonia 中，这通常是 .axaml 文件。它只负责“显示”数据和将用户的操作（如点击）传递出去，自身不包含任何业务逻辑。</li><li><strong>Model (模型)</strong>：应用程序的核心数据和业务逻辑。</li><li><strong>ViewModel (视图模型)</strong>：作为 View 和 Model 之间的桥梁。它从 Model 中获取数据，并将其转换为 View 可以直接显示的格式。同时，它包含 View 所需的命令（Commands），用于响应用户的操作。<strong>View “绑定” 到 ViewModel 的属性和命令上</strong>。</li></ul><p>这种模式最大的好处是<strong>数据驱动UI</strong>。我们只需要在 ViewModel 中改变数据，UI 就会自动更新，反之亦然。这使得代码更易于维护、测试和扩展。</p><h3 id="3-1-创建基础-ViewModel"><a href="#3-1-创建基础-ViewModel" class="headerlink" title="3.1 创建基础 ViewModel"></a>3.1 创建基础 ViewModel</h3><p>为了代码的整洁和复用，我们首先创建一个所有 ViewModel 的基类。</p><ol><li>在项目中创建一个名为 ViewModels 的新文件夹。</li><li>在该文件夹下，创建一个名为 ViewModelBase.cs 的类。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ViewModels/ViewModelBase.cs</span><br><span class="line">using CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"></span><br><span class="line">namespace AvaloniaApplication2.ViewModels;</span><br><span class="line"></span><br><span class="line">// 这个类将作为项目中所有 ViewModel 的基类</span><br><span class="line">public class ViewModelBase : ObservableObject</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ObservableObject 是 CommunityToolkit.Mvvm 包提供的一个核心类。</li><li>任何继承自 ObservableObject 的类，都自动获得了“通知”能力。当它的某个属性发生变化时，它能够主动发出通知。UI界面上绑定了该属性的元素在收到通知后，就会自动更新其显示内容。</li><li>这背后实现的是一个叫做 INotifyPropertyChanged 的接口，但 ObservableObject 已经为我们处理了所有复杂的细节。</li></ul><hr><h3 id="3-2-创建主窗口的-ViewModel"><a href="#3-2-创建主窗口的-ViewModel" class="headerlink" title="3.2 创建主窗口的 ViewModel"></a>3.2 创建主窗口的 ViewModel</h3><p>接下来，我们为 MainView 创建一个专属的 ViewModel。</p><ol><li>在 ViewModels 文件夹下，创建一个名为 MainViewModel.cs 的类。<br><em>(注意：您的笔记框架中文件名为 ViewModelModel.cs，根据类名 MainViewModel，这里应该是 MainViewModel.cs)</em></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ViewModels/MainViewModel.cs</span><br><span class="line">using CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line">using CommunityToolkit.Mvvm.Input;</span><br><span class="line"></span><br><span class="line">namespace AvaloniaApplication2.ViewModels;</span><br><span class="line"></span><br><span class="line">// &#x27;partial&#x27; 关键字是必须的，它允许源代码生成器在编译时为这个类添加代码</span><br><span class="line">public partial class MainViewModel : ViewModelBase</span><br><span class="line">&#123;</span><br><span class="line">    // [ObservableProperty] 是一个“特性”，它会自动为一个私有字段生成一个公共属性</span><br><span class="line">    // 在这里，它会为 _sideMenuExpanded 字段生成一个名为 SideMenuExpanded 的公共属性</span><br><span class="line">    // 当 SideMenuExpanded 属性的值被改变时，它会自动发出通知</span><br><span class="line">    [ObservableProperty]</span><br><span class="line">    private bool _sideMenuExpanded = true;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // [RelayCommand] 特性将一个方法包装成一个可以被UI绑定的命令</span><br><span class="line">    // 在这里，它会创建一个名为 SideMenuResizeCommand 的命令</span><br><span class="line">    [RelayCommand]</span><br><span class="line">    private void SideMenuResize()</span><br><span class="line">    &#123;</span><br><span class="line">        // 这行代码会切换布尔值的状态（true -&gt; false, false -&gt; true）</span><br><span class="line">        SideMenuExpanded = !SideMenuExpanded;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>partial class</strong>: 这个关键字允许一个类的定义被分割到多个文件中。在这里，它允许 CommunityToolkit 的**源代码生成器（Source Generator）**在编译过程中“注入”代码到 MainViewModel 类中，比如自动生成 SideMenuExpanded 属性和 SideMenuResizeCommand 命令的完整实现。</li><li><strong>[ObservableProperty]</strong>: 这是一个极其方便的特性。你只需在私有字段（如 _sideMenuExpanded）上标记它，它就会自动生成一个公共属性（首字母大写，即 SideMenuExpanded），并包含所有必要的通知逻辑。我们不再需要手动编写 get 和 set 以及调用通知事件。</li><li><strong>[RelayCommand]</strong>: 这个特性将一个普通方法（如 SideMenuResize）转换成一个实现了 ICommand 接口的命令对象（SideMenuResizeCommand）。在 MVVM 中，我们倾向于使用命令而不是事件来处理用户交互，因为这能让 ViewModel 与 View 完全解耦（ViewModel 不知道也不关心是哪个按钮触发了这个命令）。</li></ul><hr><h3 id="3-3-将-View-与-ViewModel-连接起来"><a href="#3-3-将-View-与-ViewModel-连接起来" class="headerlink" title="3.3 将 View 与 ViewModel 连接起来"></a>3.3 将 View 与 ViewModel 连接起来</h3><p>现在我们有了 View 和 ViewModel，需要将它们“绑定”在一起。</p><h3 id="3-3-1-在应用启动时设置-DataContext"><a href="#3-3-1-在应用启动时设置-DataContext" class="headerlink" title="3.3.1 在应用启动时设置 DataContext"></a>3.3.1 在应用启动时设置 DataContext</h3><p>我们在应用启动时，将 MainViewModel 的一个实例指定为 MainView 的“数据上下文”（DataContext）。DataContext 就像是为这个 View 指定了一个专属的“数据管家”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">App.axaml.cs</span><br><span class="line">using Avalonia;</span><br><span class="line">using Avalonia.Controls.ApplicationLifetimes;</span><br><span class="line">using Avalonia.Markup.Xaml;</span><br><span class="line">// 引入 ViewModels 命名空间</span><br><span class="line">using AvaloniaApplication2.ViewModels;</span><br><span class="line"></span><br><span class="line">namespace AvaloniaApplication2;</span><br><span class="line"></span><br><span class="line">public partial class App : Application</span><br><span class="line">&#123;</span><br><span class="line">    public override void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        AvaloniaXamlLoader.Load(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnFrameworkInitializationCompleted()</span><br><span class="line">    &#123;</span><br><span class="line">        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)</span><br><span class="line">        &#123;</span><br><span class="line">            desktop.MainWindow = new MainView</span><br><span class="line">            &#123;</span><br><span class="line">                // 为主窗口(MainView)设置数据上下文(DataContext)</span><br><span class="line">                // 这样 MainView 及其所有子控件都能访问到 MainViewModel 里的数据</span><br><span class="line">                DataContext = new MainViewModel()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        base.OnFrameworkInitializationCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-在-XAML-中进行数据绑定"><a href="#3-3-2-在-XAML-中进行数据绑定" class="headerlink" title="3.3.2 在 XAML 中进行数据绑定"></a>3.3.2 在 XAML 中进行数据绑定</h3><p>设置好 DataContext后，我们就可以在 MainView.axaml 中使用 {Binding} 语法来访问 MainViewModel 中的属性和命令了。</p><p><code>MainView.axaml</code>,由<code>MainWindow.axaml</code>改名而来。</p><p>按照惯例，你通常可以把视图模型命名为 MainWindowViewModel，或者你也可以把 MainWindow 重命名为 MainView（通常不带 “Window” 后缀）。这个教程作者习惯叫<code>MainViewModel</code>，所以把MainWindow.axaml改名为<code>MainView.axaml</code>实现命名上统一。</p><p>首先，我们需要在 Window 标签中声明 ViewModel 的命名空间和数据类型，这能为我们提供更好的智能提示和编译时类型检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window ...</span><br><span class="line">        xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainViewModel&quot;</span><br><span class="line">        ...&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 这个 DataContext 只在设计器（预览窗口）中生效，让我们可以在不运行程序的情况下看到绑定效果 --&gt;</span><br><span class="line">    &lt;Design.DataContext&gt;</span><br><span class="line">        &lt;vm:MainViewModel&gt;&lt;/vm:MainViewModel&gt;</span><br><span class="line">    &lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- ... 省略部分代码 ... --&gt;</span><br><span class="line">&lt;!-- ... --&gt;</span><br><span class="line">&lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">    &lt;!-- 将 PointerPressed 事件连接到代码隐藏文件中的处理方法 --&gt;</span><br><span class="line">    &lt;!-- IsVisible 属性绑定到 SideMenuExpanded。当其为 true 时，图片可见 --&gt;</span><br><span class="line">    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage Assets/Images/logo.svg&#125;&quot; Width=&quot;220&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- IsVisible 属性绑定到 SideMenuExpanded 的反值(!)。当其为 false 时，图片可见 --&gt;</span><br><span class="line">    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage Assets/Images/icon.svg&#125;&quot; Width=&quot;22&quot; IsVisible=&quot;&#123;Binding !SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">            &lt;Label Classes=&quot;icon&quot; Content=&quot;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;!-- 这个 Label 的可见性同样由 SideMenuExpanded 控制 --&gt;</span><br><span class="line">            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Button&gt;</span><br><span class="line">    &lt;!-- ... 其他按钮的 Label 也做同样绑定 ... --&gt;</span><br><span class="line">&lt;/StackPanel&gt;</span><br><span class="line">&lt;!-- ... --&gt;</span><br></pre></td></tr></table></figure><ul><li>xmlns:vm&#x3D;”…”: 定义一个XML命名空间别名 vm，指向我们的 ViewModels 文件夹。</li><li>x:DataType&#x3D;”vm:MainViewModel”: 明确告诉编译器和设计器，这个 View 的 DataContext 是 MainViewModel 类型的。</li><li>d:DataContext: d: 代表 design-time（设计时）。这个设置仅用于 IDE 的预览窗口，它让预览器也创建一个 MainViewModel 实例，这样我们就能实时看到绑定后的UI效果。</li><li>{Binding SideMenuExpanded}: 这是核心的数据绑定语法。它将 IsVisible 属性与 MainViewModel 中的 SideMenuExpanded 公共属性连接起来。</li><li>{Binding !SideMenuExpanded}: Avalonia 的绑定引擎支持简单的逻辑运算，! 表示取反。所以这个图片会在 SideMenuExpanded 为 false 时显示。</li></ul><h3 id="3-3-3-连接用户操作与-ViewModel-命令"><a href="#3-3-3-连接用户操作与-ViewModel-命令" class="headerlink" title="3.3.3 连接用户操作与 ViewModel 命令"></a>3.3.3 连接用户操作与 ViewModel 命令</h3><p>最后，我们需要将用户的双击操作，连接到 MainViewModel 中的 SideMenuResizeCommand 命令。这是在 MainView.axaml.cs（代码隐藏文件）中完成的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MainView.axaml.cs</span><br><span class="line">using Avalonia.Controls;</span><br><span class="line">using Avalonia.Input;</span><br><span class="line">using AvaloniaApplication2.ViewModels;</span><br><span class="line"></span><br><span class="line">namespace AvaloniaApplication2;</span><br><span class="line"></span><br><span class="line">public partial class MainView : Window</span><br><span class="line">&#123;</span><br><span class="line">    public MainView()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这个方法在 XAML 中通过 PointerPressed=&quot;InputElement_OnPointerPressed&quot; 绑定</span><br><span class="line">    private void InputElement_OnPointerPressed(object? sender, PointerPressedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        // e.ClickCount 可以获取鼠标点击次数，我们只关心双击</span><br><span class="line">        if (e.ClickCount != 2)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        // (DataContext as MainViewModel) 尝试将 DataContext 转换成 MainViewModel 类型</span><br><span class="line">        // ?. 是空条件运算符，如果转换失败（DataContext不是MainViewModel），则不执行后面的代码，避免程序崩溃</span><br><span class="line">        // .Execute(null) 执行 ViewModel 中的命令</span><br><span class="line">        (DataContext as MainViewModel)?.SideMenuResizeCommand.Execute(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们尽量避免在代码隐藏文件中写逻辑，但这种将 View 的特定事件（如 PointerPressed）“翻译”成调用 ViewModel 命令的代码是完全可以接受的。它充当了一个干净的“粘合剂”，并且没有将任何业务逻辑耦合到 View 中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，我们完成了一个完整的 <strong>View -&gt; ViewModel -&gt; View</strong> 的数据流动闭环：</p><ol><li><strong>用户操作</strong>: 用户双击图片 (View)。</li><li><strong>事件触发</strong>: PointerPressed 事件在 MainView.axaml.cs 中被捕获。</li><li><strong>命令执行</strong>: 代码调用 DataContext (即 MainViewModel) 的 SideMenuResizeCommand。</li><li><strong>数据更新</strong>: MainViewModel 中的 SideMenuResize 方法被执行，SideMenuExpanded 属性的值发生改变。</li><li><strong>变更通知</strong>: 因为 SideMenuExpanded 是一个 ObservableProperty，它会自动发出“我变了”的通知。</li><li><strong>UI 自动更新</strong>: MainView.axaml 中所有绑定到 SideMenuExpanded 的UI元素（图片和文字）收到通知，并自动更新它们的 IsVisible 状态，从而实现了菜单的折叠&#x2F;展开效果。</li></ol><h2 id="（4）Avalonia-学习笔记04-Page-Navigation（页面导航）"><a href="#（4）Avalonia-学习笔记04-Page-Navigation（页面导航）" class="headerlink" title="（4）Avalonia 学习笔记04. Page Navigation（页面导航）"></a>（4）<a href="https://www.cnblogs.com/simonoct/p/18976504">Avalonia 学习笔记04. Page Navigation（页面导航）</a></h2><p>视频链接：<a href="https://youtu.be/RW4fvs8qnjE?si=PXlszBf4pdB-x3mU">https://youtu.be/RW4fvs8qnjE?si=PXlszBf4pdB-x3mU</a></p><p>本节课的目标是实现应用内的页面切换功能。我们将创建一个核心的 ViewLocator 类，它能根据当前需要显示的 ViewModel 自动查找并加载对应的 View。同时，我们会为侧边栏的按钮添加命令绑定，实现点击按钮切换页面的功能，并为当前选中的页面按钮添加高亮样式，以提供清晰的视觉反馈。</p><h3 id="4-1-ViewLocator-cs"><a href="#4-1-ViewLocator-cs" class="headerlink" title="4.1 ViewLocator.cs"></a>4.1 ViewLocator.cs</h3><p>在项目根目录下新建一个 ViewLocator.cs 文件。这个类是本节课实现页面导航的核心。</p><p>它的作用是充当一个“视图定位器”。当你告诉应用“显示这个 ViewModel”时，ViewLocator 会自动找到并实例化与之对应的 View，并将两者关联起来。</p><p>这遵循了 MVVM 模式中一个重要的思想：“<strong>约定优于配置</strong>”(Convention over Configuration)。我们只需要遵循 HomePageViewModel &#x2F; HomePageView 这样的命名约定，ViewLocator 就能自动完成工作，而无需我们手动编写大量的 if-else 或 switch 语句来指定哪个 ViewModel 对应哪个 View。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Controls;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Controls.Templates;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.ViewModels; <span class="comment">// 确保 using 了 ViewModels 命名空间</span></span><br><span class="line"><span class="comment">// using AvaloniaApplication2.Views; // 这个 using 在当前代码中不是必需的，但保留也无妨</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IDataTemplate 是一个接口，它定义了一种根据数据（Data）创建 UI 元素（控件）的规范。</span></span><br><span class="line"><span class="comment">// 我们的 ViewLocator 实现了这个接口，意味着它能将一个数据对象（在这里是 ViewModel）转换成一个视图控件（View）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ViewLocator</span> : <span class="title">IDataTemplate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Build 方法是 IDataTemplate 接口的核心。</span></span><br><span class="line">    <span class="comment">// 当 Match 方法返回 true 时，Avalonia 框架会调用 Build 方法，</span></span><br><span class="line">    <span class="comment">// 并将数据对象（data）传递进来，期望返回一个可以显示的控件（Control）。</span></span><br><span class="line">    <span class="keyword">public</span> Control? Build(<span class="built_in">object</span>? data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果传入的数据是 null，直接返回 null，不做任何处理。</span></span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这是 ViewLocator 的核心魔法：</span></span><br><span class="line">        <span class="comment">// 1. data.GetType().FullName! 获取 ViewModel 的完整类名，例如 &quot;AvaloniaApplication2.ViewModels.HomePageViewModel&quot;。</span></span><br><span class="line">        <span class="comment">// 2. .Replace(&quot;ViewModel&quot;, &quot;View&quot;, ...) 将类名中的 &quot;ViewModel&quot; 替换为 &quot;View&quot;。</span></span><br><span class="line">        <span class="comment">//    结果就变成了 &quot;AvaloniaApplication2.Views.HomePageView&quot;。</span></span><br><span class="line">        <span class="comment">//    这就是我们的“约定”：View 和 ViewModel 的命名必须遵循这个模式。</span></span><br><span class="line">        <span class="keyword">var</span> viewName = data.GetType().FullName!.Replace(<span class="string">&quot;ViewModel&quot;</span>, <span class="string">&quot;View&quot;</span>, StringComparison.InvariantCulture);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 C# 的反射（Reflection）功能，根据上面生成的字符串类名，查找对应的实际类型（Type）。</span></span><br><span class="line">        <span class="keyword">var</span> type = Type.GetType(viewName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到对应的 View 类型（可能你忘了创建 View 文件或者命名不匹配），就返回 null。</span></span><br><span class="line">        <span class="comment">// 在视频中，作者返回了一个 TextBlock 来显示错误，返回 null 也是一种处理方式。</span></span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果找到了类型，就使用 Activator.CreateInstance(type) 创建该 View 的一个新实例。</span></span><br><span class="line">        <span class="comment">// 这行代码的效果等同于 new HomePageView()，但是它是动态执行的。</span></span><br><span class="line">        <span class="keyword">var</span> control = (Control)Activator.CreateInstance(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这是非常关键的一步：将新创建的 View 的 DataContext（数据上下文）设置为传入的 ViewModel (data)。</span></span><br><span class="line">        <span class="comment">// 这样，View 和 ViewModel 就被绑定在了一起，View 内部的 &#123;Binding ...&#125; 才能正确地找到 ViewModel 中的属性。</span></span><br><span class="line">        control.DataContext = data;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回创建并设置好数据上下文的 View 控件。</span></span><br><span class="line">        <span class="keyword">return</span> control;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match 方法用于判断此 DataTemplate 是否适用于给定的数据（data）。</span></span><br><span class="line">    <span class="comment">// 在这里，我们判断传入的数据是否是一个 ViewModelBase 或其派生类的实例。</span></span><br><span class="line">    <span class="comment">// 如果是，就返回 true，告诉 Avalonia：“这个数据我能处理，请调用我的 Build 方法吧！”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Match</span>(<span class="params"><span class="built_in">object</span>? data</span>)</span> =&gt; data <span class="keyword">is</span> ViewModelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-ViewModels-MainViewModel-cs"><a href="#4-2-ViewModels-MainViewModel-cs" class="headerlink" title="4.2 ViewModels\MainViewModel.cs"></a>4.2 ViewModels\MainViewModel.cs</h3><p>修改 MainViewModel.cs，为它添加页面状态管理和导航的逻辑。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Avalonia.Svg.Skia;</span><br><span class="line"><span class="comment">// using AvaloniaApplication2.Views; // 这个 using 在 ViewModel 中通常是不需要的，因为 ViewModel 不应该直接了解 View。</span></span><br><span class="line"><span class="comment">// 这是 MVVM 模式的一个核心原则：ViewModel 负责提供数据和逻辑，它不应该“知道”任何关于 View（视图/UI）的具体实现细节。</span></span><br><span class="line"><span class="comment">// View 和 ViewModel 之间的解耦是由 ViewLocator 和数据绑定机制来完成的。</span></span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.Input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这个常量在视频中被定义，但后来切换到了另一种实现方式，所以它没有被使用。</span></span><br><span class="line">    <span class="comment">// 但后来采用了 Avalonia 更优雅的 `Classes.active=&quot;&#123;Binding ...&#125;&quot;` 绑定布尔值的方式，</span></span><br><span class="line">    <span class="comment">// 我们可以安全地忽略或删除它。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> buttonActiveClass = <span class="string">&quot;active&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _sideMenuExpanded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个属性来持有当前正在显示的页面的 ViewModel。</span></span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="comment">// 这是 MVVM Toolkit 的一个强大功能。它告诉编译器：</span></span><br><span class="line">    <span class="comment">// 当 _currentPage 属性发生变化时，也需要发出 HomePageIsActive 和 ProcessPageIsActive 属性已更改的通知。</span></span><br><span class="line">    <span class="comment">// 这样，UI 就会自动更新绑定到这几个属性的任何元素。</span></span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HomePageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ProcessPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ActionsPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(MacrosPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ReporterPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HistoryPageIsActive))</span>]</span><br><span class="line">    <span class="keyword">private</span> ViewModelBase _currentPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这几个是只读的计算属性，用于判断当前页面是否是主页或流程页。</span></span><br><span class="line">    <span class="comment">// UI 上的按钮会绑定到这些属性，以决定是否应用 &quot;active&quot; 样式。</span></span><br><span class="line">    <span class="comment">// =&gt; 是 &quot;lambda&quot; 表达式的简写，表示这个属性的值是通过后面的表达式计算得出的。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HomePageIsActive =&gt; CurrentPage == _homePage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ProcessPageIsActive =&gt; CurrentPage == _processPage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ActionsPageIsActive =&gt; CurrentPage == _actionsPage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> MacrosPageIsActive =&gt; CurrentPage == _macrosPage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ReporterPageIsActive =&gt; CurrentPage == _reporterPage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HistoryPageIsActive =&gt; CurrentPage == _historyPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每个页面创建一个私有的、只读的 ViewModel 实例。</span></span><br><span class="line">    <span class="comment">// 在应用的生命周期内，我们只使用这几个实例，而不是每次切换页面都创建新的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HomePageViewModel _homePage = <span class="keyword">new</span> HomePageViewModel();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ProcessPageViewModel _processPage = <span class="keyword">new</span> ProcessPageViewModel();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ActionsPageViewModel _actionsPage = <span class="keyword">new</span> ActionsPageViewModel();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> MacrosPageViewModel _macrosPage = <span class="keyword">new</span> MacrosPageViewModel();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ReporterPageViewModel _reporterPage = <span class="keyword">new</span> ReporterPageViewModel();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> HistoryPageViewModel _historyPage = <span class="keyword">new</span> HistoryPageViewModel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MainViewModel 的构造函数。</span></span><br><span class="line">    <span class="comment">// 当 MainViewModel 被创建时（通常是应用启动时），这个方法会被调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在这里设置应用的默认显示页面。视频中设置的是 ProcessPage。</span></span><br><span class="line">        CurrentPage = _homePage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SideMenuResize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SideMenuExpanded = !SideMenuExpanded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个命令，用于导航到主页。</span></span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHome</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当命令被执行时（例如，点击了主页按钮），将当前页面设置为 _homePage 实例。</span></span><br><span class="line">        <span class="comment">// 因为 CurrentPage 属性的 set 访问器会触发属性变更通知，UI 会自动更新。</span></span><br><span class="line">        CurrentPage = _homePage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个命令，用于导航到流程页。</span></span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToProcess</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _processPage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToMacros</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _macrosPage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToActions</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _actionsPage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToReporter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _reporterPage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHistory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _historyPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-ObservableProperty-、-RelayCommand-和-NotifyPropertyChangedFor"><a href="#4-3-ObservableProperty-、-RelayCommand-和-NotifyPropertyChangedFor" class="headerlink" title="4.3 [ObservableProperty]、[RelayCommand]和[NotifyPropertyChangedFor]"></a>4.3 [ObservableProperty]、[RelayCommand]和[NotifyPropertyChangedFor]</h3><p>突然发现第三章的MVVM又记得不太清晰，还是在这里重复加强记忆。</p><p><strong>CommunityToolkit.Mvvm</strong> (也常被称为 MVVM Toolkit) 库，这个库的核心功能之一就是利用 C# 的 <strong>Source Generator (源代码生成器)</strong> 技术，来自动写那些繁琐又重复的代码。</p><p><strong>写一个简单的“指令”，编译器就会在后台帮你生成完整的、符合 MVVM 规范的代码。</strong></p><h3 id="4-3-1-ObservableProperty"><a href="#4-3-1-ObservableProperty" class="headerlink" title="4.3.1 [ObservableProperty]"></a>4.3.1 [ObservableProperty]</h3><p>属性的“自动生成器”，这个是最基础，也是最常用的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ObservableProperty</span>] </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> _sideMenuExpanded;</span><br></pre></td></tr></table></figure><p>你只写了一行私有字段<code>_sideMenuExpanded</code>。当你给它贴上<code>[ObservableProperty]</code> 这个标签后，MVVM Toolkit 在编译时会自动在后台为你生成一个完整的、公开的、带有通知功能的属性 <code>SideMenuExpanded</code>。</p><p><strong>它在后台帮你生成的代码，大致是这个样子：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> SideMenuExpanded</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> =&gt; _sideMenuExpanded;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// SetProperty 是一个核心方法，它会做两件事：</span></span><br><span class="line">        <span class="comment">// 1. 检查新传入的 value 和旧的值 _sideMenuExpanded 是否真的不同。</span></span><br><span class="line">        <span class="comment">// 2. 如果真的不同，它会更新 _sideMenuExpanded 的值，然后发出一个“通知”，告诉UI：“嘿，SideMenuExpanded这个属性的值变了，所有绑定了它的地方都快来更新一下！”</span></span><br><span class="line">        SetProperty(<span class="keyword">ref</span> _sideMenuExpanded, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[ObservableProperty] 帮你把一个简单的私有字段，<strong>包装</strong>成一个能和UI顺畅沟通的公开属性，让你不用每次都手动去写 get、set 和那一长串的通知逻辑。</p><ul><li>必须用 <code>[ObservableProperty]</code> 标记<strong>字段</strong>（带<code>_</code>的变量）</li><li>自动生成的<strong>属性</strong>名 &#x3D; 去掉下划线 + 首字母大写（<code>_sideMenu</code> → <code>SideMenu</code>）</li><li>自动实现 <code>INotifyPropertyChanged</code>，修改属性值会触发UI更新</li></ul><h3 id="4-3-2-RelayCommand"><a href="#4-3-2-RelayCommand" class="headerlink" title="4.3.2 [RelayCommand]"></a>4.3.2 [RelayCommand]</h3><p>方法的“命令转换器”，在MVVM模式里，界面上的按钮点击不能直接调用ViewModel里的一个方法，而是需要通过一个叫“命令（Command）”的东西来做中间人。<code>[RelayCommand]</code>就是帮你创建这个中间人的工具。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">RelayCommand</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToProcess</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    CurrentPage = _processPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只写了一个普通、私有的方法 GoToProcess。当你给它贴上<code>[RelayCommand]</code>这个标签后，MVVM Toolkit 会自动在后台为你创建一个公开的、符合WPF&#x2F;Avalonia绑定规范的命令属性。这个新属性的名字默认是在你的方法名后面加上 Command。</p><p><strong>它在后台帮你生成的代码，大致是这个样子：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它创建了一个公开的、只读的命令属性</span></span><br><span class="line"><span class="keyword">public</span> IRelayCommand GoToProcessCommand &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时，它在构造函数里初始化了这个命令，</span></span><br><span class="line"><span class="comment">// 告诉这个命令：“当UI执行你的时候，你就去调用那个私有的 GoToProcess 方法。”</span></span><br><span class="line"><span class="comment">// new RelayCommand(GoToProcess);</span></span><br></pre></td></tr></table></figure><p>[RelayCommand] 帮你把一个普通的业务逻辑方法，<strong>包装</strong>成一个可以被XAML里按钮的 Command&#x3D;”{Binding …}” 语法所识别和绑定的“命令对象”。</p><ul><li><p>方法必须标记 <code>[RelayCommand]</code></p></li><li><p>生成的命令名 &#x3D; 方法名 + <code>Command</code></p></li><li><p>在XAML中绑定时要使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button Command=&quot;&#123;Binding GoToProcessCommand&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-3-NotifyPropertyChangedFor"><a href="#4-3-3-NotifyPropertyChangedFor" class="headerlink" title="4.3.3 [NotifyPropertyChangedFor]"></a>4.3.3 [NotifyPropertyChangedFor]</h3><p>属性之间的“关联通知器”，在上面的代码里，有好几个用于判断按钮是否高亮的属性，比如：<br><code>public bool HomePageIsActive =&gt; CurrentPage == _homePage;</code></p><p>这个 <code>HomePageIsActive</code> 属性的值，完全<strong>依赖于</strong> <code>CurrentPage</code> 属性。当 <code>CurrentPage</code> 改变时，<code>HomePageIsActive</code> 的值也应该随之改变。</p><p><strong>但是，计算机没那么智能。</strong> 当你执行<code>CurrentPage = _homePage;</code> 这句代码时，系统只知道<code>CurrentPage</code>变了，它会去通知UI更新绑定了<code>CurrentPage</code>的地方（比如那个 <code>ContentControl</code>）。但它<strong>不知道</strong> <code>HomePageIsActive</code>、<code>ProcessPageIsActive</code> 这些依赖它的属性也需要更新。所以，按钮的高亮状态不会自动变化。</p><p><strong>[NotifyPropertyChangedFor] 的作用：</strong><br>它就像一个“信使”或者“传话筒”。你把它贴在“源头”属性上，告诉它：“当你自己变化的时候，请顺便帮我通知一下其他几个相关的属性也变化了。”</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ObservableProperty</span>]</span><br><span class="line"><span class="comment">// 当 CurrentPage 变化时，请顺便通知 HomePageIsActive 也变了</span></span><br><span class="line">[<span class="meta">NotifyPropertyChangedFor(nameof(HomePageIsActive))</span>] </span><br><span class="line"><span class="comment">// 当 CurrentPage 变化时，也请通知 ProcessPageIsActive 也变了</span></span><br><span class="line">[<span class="meta">NotifyPropertyChangedFor(nameof(ProcessPageIsActive))</span>] </span><br><span class="line"><span class="comment">// ... 其他按钮的IsActive属性也一样</span></span><br><span class="line"><span class="keyword">private</span> ViewModelBase _currentPage;</span><br></pre></td></tr></table></figure><p><strong>它的工作流程：</strong></p><ol><li>你点击了“Process”按钮，触发 <code>GoToProcessCommand</code> 命令。</li><li>命令执行 <code>GoToProcess()</code>方法，这句代码<code>CurrentPage = _processPage;</code>被调用。</li><li><code>[ObservableProperty]</code>的底层机制检测到<code>_currentPage</code> 的值变了，于是它准备发出<code>CurrentPage</code>属性已更改的通知。</li><li>在发出通知前，它看到了你贴的<code>[NotifyPropertyChangedFor]</code> 标签。</li><li>于是，它不仅发出了<code>CurrentPage</code>的通知，还<strong>一并发出</strong>了<code>HomePageIsActive</code>、<code>ProcessPageIsActive</code>等所有你在标签里指定的属性的“已更改”通知。</li><li>UI收到了这些通知，于是它去重新获取<code>HomePageIsActive</code>的值（此时是false），也去获取 <code>ProcessPageIsActive</code>的值（此时是true），然后正确地更新了所有按钮的高亮样式。</li></ol><p><code>[NotifyPropertyChangedFor]</code>解决了<strong>一个属性的变化</strong>如何触发<strong>其他依赖它的属性</strong>进行UI更新的问题，它在多个属性之间建立了一条“通知链”。</p><h3 id="4-3-4-三者的关系图示："><a href="#4-3-4-三者的关系图示：" class="headerlink" title="4.3.4 三者的关系图示："></a>4.3.4 三者的关系图示：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ObservableProperty</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> _sideMenuExpanded;</span><br><span class="line">│</span><br><span class="line">└─► 自动生成公共属性 SideMenuExpanded</span><br><span class="line">    │</span><br><span class="line">    └─► 当值变化时自动通知UI</span><br><span class="line"></span><br><span class="line">[<span class="meta">RelayCommand</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToProcess</span>()</span> &#123; ... &#125;</span><br><span class="line">│</span><br><span class="line">└─► 自动生成 GoToProcessCommand</span><br><span class="line"></span><br><span class="line">[<span class="meta">NotifyPropertyChangedFor</span>]</span><br><span class="line">│</span><br><span class="line">└─► 当前属性变化时，强制刷新其他依赖属性</span><br></pre></td></tr></table></figure><h3 id="4-4-ViewModels-ProcessPageViewModel-cs和ViewModels-HomePageViewModel-cs"><a href="#4-4-ViewModels-ProcessPageViewModel-cs和ViewModels-HomePageViewModel-cs" class="headerlink" title="4.4 ViewModels\ProcessPageViewModel.cs和ViewModels\HomePageViewModel.cs"></a>4.4 ViewModels\ProcessPageViewModel.cs和ViewModels\HomePageViewModel.cs</h3><p>新建ProcessPageViewModel.cs、HomePageViewModel.cs。<br>其他的ActionsPageViewModel.cs、HistoryPageViewModel.cs、MacrosPageViewModel.cs、ReporterPageViewModel.cs、SettingsPageViewModel.cs则仿造下面两个自行创建，由于内容雷同就不重复展示了。</p><p>ProcessPageViewModel.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ProcessPageViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个简单的字符串属性，用于在页面上显示，以验证数据绑定是否成功。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Test &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;Process&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HomePageViewModel.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">HomePageViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Test &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">&quot;Home&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-Views-MainView-axaml"><a href="#4-5-Views-MainView-axaml" class="headerlink" title="4.5 Views\MainView.axaml"></a>4.5 Views\MainView.axaml</h3><p>在项目下新建一个 Views 文件夹，然后把 MainView.axaml 移动到 Views 内。修改其 XAML 代码以支持页面导航。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1024&quot; d:DesignHeight=&quot;600&quot;</span><br><span class="line">        Width=&quot;1024&quot; Height=&quot;600&quot;</span><br><span class="line">        x:Class=&quot;AvaloniaApplication2.MainView&quot;</span><br><span class="line">        xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">        xmlns:view=&quot;clr-namespace:AvaloniaApplication2.Views&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainViewModel&quot;</span><br><span class="line">        Title=&quot;AvaloniaApplication2&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:MainViewModel&gt;&lt;/vm:MainViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;Grid Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot; ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;!-- 这是显示页面的关键控件。 --&gt;</span><br><span class="line">        &lt;!-- ContentControl 是一个占位符，可以显示任何内容。 --&gt;</span><br><span class="line">        &lt;!-- 我们将其 Content 属性绑定到 ViewModel 中的 CurrentPage 属性。 --&gt;</span><br><span class="line">        &lt;!-- 当 CurrentPage 的值是一个 ViewModel 实例时，我们注册的 ViewLocator 就会介入， --&gt;</span><br><span class="line">        &lt;!-- 找到对应的 View，并将其显示在这里。 --&gt;</span><br><span class="line">        &lt;ContentControl Grid.Column=&quot;1&quot; Content=&quot;&#123;Binding CurrentPage&#125;&quot; /&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot;&gt;</span><br><span class="line">            &lt;Grid RowDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;220&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage /Assets/Images/icon.svg&#125;&quot; Width=&quot;22&quot; IsVisible=&quot;&#123;Binding !SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;!-- 主页按钮 --&gt;</span><br><span class="line">                    &lt;!-- Command=&quot;&#123;Binding GoToHomeCommand&#125;&quot; 将按钮的点击操作绑定到 ViewModel 中的 GoToHomeCommand。 --&gt;</span><br><span class="line">                    &lt;!-- MVVM Toolkit 会自动将 GoToHome 方法生成为 GoToHomeCommand。 --&gt;</span><br><span class="line">                    &lt;!-- Classes.active=&quot;&#123;Binding HomePageIsActive&#125;&quot; 是 Avalonia 的一个特性。 --&gt;</span><br><span class="line">                    &lt;!-- 当 HomePageIsActive 属性为 true 时，此按钮会获得一个名为 &quot;active&quot; 的样式类。 --&gt;</span><br><span class="line">                    &lt;!-- Classes.active=&quot;&#123;Binding HomePageIsActive&#125;&quot; 是 Avalonia 的一个强大特性，非常类似于网页开发中的 CSS 类绑定。 --&gt;</span><br><span class="line">                    &lt;!-- 当 ViewModel 中的 HomePageIsActive 属性为 true 时，此按钮会自动获得一个名为 &quot;active&quot; 的样式类。 --&gt;</span><br><span class="line">                    &lt;!-- 当它变为 false 时，这个类会被自动移除。我们可以在样式文件中定义 .active 类的外观。 --&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding HomePageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToHomeCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2C2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ProcessPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToProcessCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE346;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ActionsPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToActionsCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE7F2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding MacrosPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToMacrosCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE3EE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ReporterPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToReporterCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEB7A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding HistoryPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToHistoryCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE03A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">                    &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/Grid&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><h3 id="4-6-Views-HomePageView-axaml和Views-ProcessPageView-axaml"><a href="#4-6-Views-HomePageView-axaml和Views-ProcessPageView-axaml" class="headerlink" title="4.6 Views\HomePageView.axaml和Views\ProcessPageView.axaml"></a>4.6 Views\HomePageView.axaml和Views\ProcessPageView.axaml</h3><p>在Rider里，add里面选择<strong>Avalonia User Control</strong>功能新建HomePageView.axaml、ProcessPageView.axaml。这些是构成页面的用户控件。<br>其他的ActionsPageView.axaml、HistoryPageView.axaml、MacrosPageView.axaml、ReporterPageView.axaml、SettingsPageView.axaml则仿造下面两个自行创建，由于内容雷同就不重复展示了。</p><p>HomePageView.axaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">             mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.Views.HomePageView&quot;&gt;</span><br><span class="line">    &lt;!-- 为了在设计器中获得更好的预览体验和编译时类型检查， --&gt;</span><br><span class="line">    &lt;!-- 建议像 ProcessPageView 一样，也为 HomePageView 添加 x:DataType 和 Design.DataContext。 --&gt;</span><br><span class="line">    &lt;!-- 不过这里为了和视频教程的代码保持一致，方便接下来的学习，就不修改了。 --&gt;</span><br><span class="line">    &lt;!-- 为了演示，这里只放了一段纯文本。 --&gt;</span><br><span class="line">    &lt;!-- 之后可以像 ProcessPageView 一样添加绑定和更复杂的布局。 --&gt;</span><br><span class="line">    Welcome to HomePage!</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure><p>ProcessPageView.axaml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">             mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">             Foreground=&quot;White&quot;</span><br><span class="line">             xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">             x:DataType=&quot;vm:ProcessPageViewModel&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.Views.ProcessPageView&quot;&gt;</span><br><span class="line">    &lt;!-- Design.DataContext 用于在设计器（预览窗口）中提供一个数据样本， --&gt;</span><br><span class="line">    &lt;!-- 这样预览器就能正确显示绑定的数据。它在程序运行时不起作用。 --&gt;</span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:ProcessPageViewModel&gt;&lt;/vm:ProcessPageViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    &lt;!-- 将 Label 的内容绑定到 ViewModel 的 Test 属性。 --&gt;</span><br><span class="line">    &lt;!-- 因为 ViewLocator 已经将此 View 的 DataContext 设置为了 ProcessPageViewModel 的实例， --&gt;</span><br><span class="line">    &lt;!-- 所以这里的绑定能够成功。 --&gt;</span><br><span class="line">    &lt;Label Content=&quot;&#123;Binding Test&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure><h3 id="4-7-App-axaml"><a href="#4-7-App-axaml" class="headerlink" title="4.7 App.axaml"></a>4.7 App.axaml</h3><p>修改App.axaml，在整个应用程序层面注册我们的 ViewLocator 并添加高亮样式所需的颜色资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.App&quot;</span><br><span class="line">             xmlns:local=&quot;clr-namespace:AvaloniaApplication2&quot;</span><br><span class="line">             RequestedThemeVariant=&quot;Default&quot;&gt;</span><br><span class="line">             &lt;!-- &quot;Default&quot; ThemeVariant follows system theme variant. &quot;Dark&quot; or &quot;Light&quot; are other available options. --&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- Application.DataTemplates 是一个全局的数据模板集合。 --&gt;</span><br><span class="line">     &lt;Application.DataTemplates&gt;</span><br><span class="line">         &lt;!-- 在这里实例化并注册我们的 ViewLocator。 --&gt;</span><br><span class="line">         &lt;!-- 这使得它对整个应用程序都生效。任何地方只要把一个 ViewModel 赋给 Content 属性， --&gt;</span><br><span class="line">         &lt;!-- ViewLocator 就会尝试去匹配和构建对应的 View。 --&gt;</span><br><span class="line">         &lt;local:ViewLocator&gt;&lt;/local:ViewLocator&gt;</span><br><span class="line">     &lt;/Application.DataTemplates&gt;</span><br><span class="line">             </span><br><span class="line">    &lt;Application.Styles&gt;</span><br><span class="line">        &lt;FluentTheme /&gt;</span><br><span class="line">        &lt;StyleInclude Source=&quot;Styles/AppDefaultStyles.axaml&quot;&gt;&lt;/StyleInclude&gt;</span><br><span class="line">    &lt;/Application.Styles&gt;</span><br><span class="line">     &lt;Application.Resources&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryForeground&quot;&gt;#CFCFCF&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryBackground&quot;&gt;#14172D&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;LinearGradientBrush x:Key=&quot;PrimaryBackgroundGradient&quot; StartPoint=&quot;0%, 0%&quot; EndPoint=&quot;100%, 0%&quot;&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;0&quot; Color=&quot;#111214&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#151E3E&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">         &lt;/LinearGradientBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverBackground&quot;&gt;#333B5A&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;!-- 新增的颜色资源，用于激活状态按钮的背景色。 --&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryActiveBackground&quot;&gt;#6633dd&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverForeground&quot;&gt;White&lt;/SolidColorBrush&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoPro&quot;&gt;/Assets/Fonts/AkkoPro-Regular.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoProBold&quot;&gt;/Assets/Fonts/AkkoPro-Bold.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor&quot;&gt;/Assets/Fonts/Phosphor.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor-Fill&quot;&gt;/Assets/Fonts/Phosphor-Fill.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure><h3 id="4-8-Styles-AppDefaultStyles-axaml"><a href="#4-8-Styles-AppDefaultStyles-axaml" class="headerlink" title="4.8 Styles\AppDefaultStyles.axaml"></a>4.8 Styles\AppDefaultStyles.axaml</h3><p>修改AppDefaultStyles.axaml，添加当按钮拥有 active 类时的样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&lt;Styles xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Design.PreviewWith&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot; Width=&quot;200&quot;&gt;</span><br><span class="line">            &lt;!-- Add Controls for Previewer Here --&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;200&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2C2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE346;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE7F2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE3EE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEB7A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE03A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Design.PreviewWith&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Add Styles Here --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Window&quot;&gt;</span><br><span class="line">        &lt;!-- &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt; --&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Border&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">            &lt;Transitions&gt;</span><br><span class="line">                &lt;DoubleTransition Property=&quot;Width&quot; Duration=&quot;0:0:1&quot;&gt;&lt;/DoubleTransition&gt;</span><br><span class="line">            &lt;/Transitions&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon, Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor-Fill&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0 2 5 0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;19&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button, Label.akko&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;CornerRadius&quot; Value=&quot;10&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">            &lt;Transitions&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Foreground&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Background&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;TransformOperationsTransition Property=&quot;RenderTransform&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/TransformOperationsTransition&gt;</span><br><span class="line">            &lt;/Transitions&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent:pointerover Label&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1.2)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryHoverForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryHoverBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 这是为激活按钮新增的样式。 --&gt;</span><br><span class="line">    &lt;!-- 选择器 &quot;Button.active&quot; 意味着它会应用在同时是 Button 并且拥有 &quot;active&quot; 类的控件上。 --&gt;</span><br><span class="line">    &lt;!-- `/template/ ContentPresenter` 这个语法是 Avalonia 样式系统的一部分，它的意思是“深入到按钮的控件模板（template）内部，找到名为 ContentPresenter 的部分并对它应用样式”。 --&gt;</span><br><span class="line">    &lt;!-- 这允许我们修改控件的内部视觉元素，而不仅仅是控件本身。 --&gt;</span><br><span class="line">    &lt;!-- 视频中提到，为了让 active 状态的样式优先级高于 pointerover (鼠标悬浮) 状态，--&gt;</span><br><span class="line">    &lt;!-- 需要将 active 样式的定义放在 pointerover 样式的后面。 --&gt;</span><br><span class="line">    &lt;!-- 所以当一个按钮是 active 状态时， --&gt;</span><br><span class="line">    &lt;!-- 鼠标再悬浮上去，背景色不会再变为悬浮的颜色，这符合预期。 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.active /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryActiveBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;Button.transparent:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Styles&gt;</span><br></pre></td></tr></table></figure><h3 id="4-9-当前目录结构"><a href="#4-9-当前目录结构" class="headerlink" title="4.9 当前目录结构"></a>4.9 当前目录结构</h3><p>去除&#x2F;bin、&#x2F;obj，让显示简洁。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">│  App.axaml</span><br><span class="line">│  App.axaml.cs</span><br><span class="line">│  app.manifest</span><br><span class="line">│  AvaloniaApplication2.csproj</span><br><span class="line">│  Program.cs</span><br><span class="line">│  ViewLocator.cs</span><br><span class="line">│</span><br><span class="line">├─Assets</span><br><span class="line">│  ├─Fonts</span><br><span class="line">│  │      AkkoPro<span class="literal">-Bold</span>.ttf</span><br><span class="line">│  │      AkkoPro<span class="literal">-Regular</span>.ttf</span><br><span class="line">│  │      Phosphor<span class="literal">-Fill</span>.ttf</span><br><span class="line">│  │      Phosphor.ttf</span><br><span class="line">│  │</span><br><span class="line">│  └─Images</span><br><span class="line">│          icon.svg</span><br><span class="line">│          logo.svg</span><br><span class="line">│</span><br><span class="line">├─Styles</span><br><span class="line">│      AppDefaultStyles.axaml</span><br><span class="line">│</span><br><span class="line">├─ViewModels</span><br><span class="line">│      ActionsPageViewModel.cs</span><br><span class="line">│      HistoryPageViewModel.cs</span><br><span class="line">│      HomePageViewModel.cs</span><br><span class="line">│      MacrosPageViewModel.cs</span><br><span class="line">│      MainViewModel.cs</span><br><span class="line">│      ProcessPageViewModel.cs</span><br><span class="line">│      ReporterPageViewModel.cs</span><br><span class="line">│      ViewModelBase.cs</span><br><span class="line">│</span><br><span class="line">└─Views</span><br><span class="line">        ActionsPageView.axaml</span><br><span class="line">        ActionsPageView.axaml.cs</span><br><span class="line">        HistoryPageView.axaml</span><br><span class="line">        HistoryPageView.axaml.cs</span><br><span class="line">        HomePageView.axaml</span><br><span class="line">        HomePageView.axaml.cs</span><br><span class="line">        MacrosPageView.axaml</span><br><span class="line">        MacrosPageView.axaml.cs</span><br><span class="line">        MainView.axaml</span><br><span class="line">        MainView.axaml.cs</span><br><span class="line">        ProcessPageView.axaml</span><br><span class="line">        ProcessPageView.axaml.cs</span><br><span class="line">        ReporterPageView.axaml</span><br><span class="line">        ReporterPageView.axaml.cs</span><br><span class="line">        SettingsPageView.axaml</span><br><span class="line">        SettingsPageView.axaml.cs</span><br></pre></td></tr></table></figure><h2 id="Avalonia-学习笔记05-Dependency-Injection-Factory-Pattern（依赖注入与工厂模式）"><a href="#Avalonia-学习笔记05-Dependency-Injection-Factory-Pattern（依赖注入与工厂模式）" class="headerlink" title="Avalonia 学习笔记05. Dependency Injection Factory Pattern（依赖注入与工厂模式）"></a><a href="https://www.cnblogs.com/simonoct/p/18980757">Avalonia 学习笔记05. Dependency Injection Factory Pattern（依赖注入与工厂模式）</a></h2><p>视频链接：<a href="https://youtu.be/22Rj_sMyv88?si=czG5YX_6tDsWMMp8">https://youtu.be/22Rj_sMyv88?si=czG5YX_6tDsWMMp8</a></p><p><strong>本节课核心目标：</strong></p><ol><li>引入<strong>依赖注入 (Dependency Injection, DI)</strong> 来管理项目中各个类（特别是ViewModel）的创建和生命周期，避免在代码中到处使用 <code>new</code> 关键字，实现<strong>解耦</strong>。</li><li>解决一个常见问题：我们不希望在程序一启动时就创建所有页面的ViewModel并一直保存在内存中，而是希望在用户<strong>导航到某个页面时才创建它</strong>。</li><li>为了解决上述问题，引入<strong>工厂模式 (Factory Pattern)</strong>，创建一个专门负责“按需生产”页面ViewModel的工厂。</li></ol><p>视频作者说了，依赖注入和工厂模式会让人很困惑，但是为了接下来的课程还是要引入，并且会慢慢得到回报。<br>我现在也不太懂，不过还是要慢慢学习这些额外的知识。</p><h3 id="5-0-核心概念深入讲解"><a href="#5-0-核心概念深入讲解" class="headerlink" title="5.0 核心概念深入讲解"></a>5.0 核心概念深入讲解</h3><p>在分析具体代码修改之前，需要先理解本节课所应用的几个核心编程概念。这些概念是构建大型、可维护软件的工程基础。</p><h3 id="5-0-1-依赖注入-Dependency-Injection-DI"><a href="#5-0-1-依赖注入-Dependency-Injection-DI" class="headerlink" title="5.0.1 依赖注入 (Dependency Injection, DI)"></a>5.0.1 依赖注入 (Dependency Injection, DI)</h3><ul><li><strong>比喻：</strong> 厨师需要番茄来做菜。如果厨师需要自己去种番茄，那么他的工作就和“种番茄”这个具体行为绑定了。DI 相当于建立了一个完善的采购和物流系统，厨师只需要在菜谱上写明“需要5个番茄”，采购员（DI容器）就会自动把番茄送到他手上。</li><li><strong>描述：</strong><br>依赖注入是一种软件设计模式，其核心思想是<strong>控制反转（Inversion of Control, IoC）</strong>。一个对象（客户端）不应负责创建它所依赖的对象（服务），而是通过外部来提供（注入）这些依赖。DI 是实现 IoC 的一种具体技术。</li><li>图示</li><li>没有DI**(紧密耦合):**</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+      创建        +-------------------+</span><br><span class="line">| MainViewModel     | *-------------&gt; | HomePageViewModel |</span><br><span class="line">|-------------------|                 +-------------------+</span><br><span class="line">| <span class="keyword">new</span> HomePageVM()  |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><p> *MainViewModel 直接依赖并创建 HomePageViewModel，关系固定。</p><ul><li><strong>使用 DI (松散耦合):</strong></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+      请求依赖       +-------------------+</span><br><span class="line">| MainViewModel     | &lt;----------------- | DI容器            |</span><br><span class="line">|-------------------|      注入依赖       | (ServiceProvider) |</span><br><span class="line">| Ctor(HomePageVM)  | -----------------&gt; |-------------------|</span><br><span class="line">+-------------------+                    | 知道如何创建        |</span><br><span class="line">                                         | HomePageViewModel |</span><br><span class="line">                                         +-------------------+</span><br></pre></td></tr></table></figure><p> *MainViewModel 只声明需要什么，DI容器 负责创建并提供。</p><ul><li><strong>基本用法（三步曲）：</strong></li></ul><ol><li><p><strong>注册服务 (Register):</strong> 在应用程序的启动入口（如<code>App.axaml.cs</code>），使用 <code>ServiceCollection</code> 来“注册”服务和它们的<strong>生命周期</strong>。</p><ul><li><strong><code>AddSingleton&lt;T&gt;()</code></strong>: 单例模式。服务在第一次被请求时创建，之后所有请求都返回<strong>同一个实例</strong>。适用于全局配置、主视图模型等。</li><li><strong><code>AddTransient&lt;T&gt;()</code></strong>: 瞬态模式。<strong>每次</strong>请求服务时，都会创建一个<strong>全新的实例</strong>。适用于轻量级、无状态的服务，如本课中的页面ViewModel。</li><li><strong><code>AddScoped&lt;T&gt;()</code></strong>: 作用域模式。在同一个作用域（如一次Web请求）内，所有请求返回同一个实例。在桌面应用中不常用。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">var</span> services = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">services.AddSingleton&lt;IMainWindowViewModel, MainWindowViewModel&gt;(); <span class="comment">// 注册单例</span></span><br><span class="line">services.AddTransient&lt;IPageViewModel, HomePageViewModel&gt;();     <span class="comment">// 注册瞬态</span></span><br></pre></td></tr></table></figure></li><li><p><strong>声明依赖 (Declare):</strong> 在需要使用服务的类中，通过构造函数参数来声明依赖。这是最推荐的方式，称为“构造函数注入”。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MainWindowViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IPageViewModel _initialPage;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过构造函数声明，我需要一个 IPageViewModel</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindowViewModel</span>(<span class="params">IPageViewModel initialPage</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        _initialPage = initialPage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>解析服务 (Resolve):</strong> DI容器会自动处理服务的创建和注入。我们通常只在程序的“根”部（Composition Root，如<code>App.axaml.cs</code>）手动解析一次服务来启动整个应用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> provider = services.BuildServiceProvider();</span><br><span class="line"><span class="keyword">var</span> mainViewModel = provider.GetRequiredService&lt;IMainWindowViewModel&gt;();</span><br></pre></td></tr></table></figure></li></ol><ul><li>本章节用法详解：<ul><li>在 <code>App.axaml.cs</code> 中，我们注册了 <code>MainViewModel</code> 为 <code>Singleton</code>，因为它代表了整个主窗口的状态，全局唯一。</li><li>所有页面ViewModel（如<code>HomePageViewModel</code>）被注册为 <code>Transient</code>，因为我们希望每次导航到一个页面时，都得到一个全新的、干净的实例，并且在离开页面后，旧的实例可以被垃圾回收，从而节省内存。</li><li>由于页面 ViewModel 被注册为 Transient（瞬态），并且 MainViewModel 中只持有对 <code>_currentPage</code> 的引用，当用户导航到新页面时，_currentPage 会被赋予一个新的 ViewModel 实例。旧的那个实例如果没有其他地方引用它，就会在下一次垃圾回收（GC）时被自动清理，从而实现了内存的有效管理。</li></ul></li></ul><h3 id="5-0-2-工厂模式-Factory-Pattern"><a href="#5-0-2-工厂模式-Factory-Pattern" class="headerlink" title="5.0.2 工厂模式 (Factory Pattern)"></a>5.0.2 工厂模式 (Factory Pattern)</h3><ul><li><strong>比喻：</strong> 去快餐店点餐。顾客（客户端）不需要知道汉堡（产品）的具体制作流程，只需要到柜台（工厂）说出自己想要的汉堡名称即可。</li><li><strong>描述：</strong><br>工厂模式是一种创造型设计模式，它提供了一种封装对象创建过程的方法。客户端与具体的产品创建过程解耦，只与工厂接口交互。</li><li>图示：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+       请求页面   +---------------+       请求创建       +-------------------+</span><br><span class="line">| MainViewModel | *-------------&gt; |  PageFactory  | *-----------------&gt; |     DI容器        |</span><br><span class="line">+---------------+                 +---------------+                     +-------------------+</span><br><span class="line">                                          |                                       | 创建</span><br><span class="line">                                          | 使用注入的 <span class="string">&quot;Func&quot;</span> 委托                  |</span><br><span class="line">                                          |                                       v</span><br><span class="line">                                          +---------------------------------&gt; +-------------------+</span><br><span class="line">                                                                              | HomePageViewModel |</span><br><span class="line">                                                                              +-------------------+</span><br></pre></td></tr></table></figure><p> *MainViewModel 向 PageFactory “点餐”。</p><p> *PageFactory 不自己“做菜”，而是使用DI容器给它的一个特殊工具(Func委托)，让DI容器这个“中央厨房”来制作。</p><ul><li><p><strong>基本用法：</strong><br>通常会创建一个工厂类，其中包含一个或多个根据输入参数创建不同类型产品的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的工厂示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplePageFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPageViewModel <span class="title">CreatePage</span>(<span class="params"><span class="built_in">string</span> pageName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (pageName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Home&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> HomePageViewModel();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Settings&quot;</span>: <span class="keyword">return</span> <span class="keyword">new</span> SettingsPageViewModel();</span><br><span class="line">            <span class="literal">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Invalid page name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    这个简单工厂的问题在于，它内部使用了 `<span class="keyword">new</span>`，与我们DI的目标相悖。</span><br></pre></td></tr></table></figure></li><li><p><strong>本章节用法详解：</strong><br>我们创建了 <code>PageFactory</code> 类，但它自身并不使用 <code>new</code> 来创建ViewModel。相反，它依赖于DI容器注入的一个“生产方法”（即 <code>Func&lt;&gt;</code> 委托）。这使得 <code>PageFactory</code> 成为了一个<strong>连接客户端（<code>MainViewModel</code>）和DI容器（<code>ServiceProvider</code>）的桥梁</strong>。<code>MainViewModel</code> 通过工厂实现了“按需创建”，而工厂通过注入的委托，利用了DI容器的能力来完成实际的创建工作，保证了所有ViewModel的创建依然在DI的掌控之中。</p></li></ul><h3 id="5-0-3-委托-Delegate-、Func-和-Action"><a href="#5-0-3-委托-Delegate-、Func-和-Action" class="headerlink" title="5.0.3 委托 (Delegate)、Func&lt;&gt; 和 Action&lt;&gt;"></a>5.0.3 委托 (Delegate)、Func&lt;&gt; 和 Action&lt;&gt;</h3><ul><li><strong>比喻：</strong> 一个指向“紧急联系人电话号码”的便签。便签本身不是人，但它记录了如何联系到那个人。这个便签的格式是固定的（只能写电话号码）。</li><li><strong>描述：</strong><br>委托是C#中的一种引用类型，它封装了对具有特定方法签名（即返回值类型和参数列表）的方法的引用。它允许将方法作为参数传递，是实现回调机制和事件处理的基础。</li><li>图示：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------------------+      指向          +----------------------+</span><br><span class="line">|  委托对象         | *----------------&gt; |       方法()         |</span><br><span class="line">| (例如 <span class="string">&quot;op&quot;</span>)      |                    |----------------------|</span><br><span class="line">+------------------+                   |  ...一些逻辑...        |</span><br><span class="line">      |                                +----------------------+</span><br><span class="line">      |</span><br><span class="line">      | 可作为参数传递</span><br><span class="line">      v</span><br><span class="line">+-------------------------+</span><br><span class="line">| 另一个方法(Delegate d)  |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><ul><li><p><strong>Func&lt;&gt; 和 Action&lt;&gt;:</strong></p><p>Func&lt;&gt; 和 Action&lt;&gt; 是.NET提供的内置泛型委托，让我们无需为每种签名都手动声明委托类型。</p><ul><li><strong>Action&lt;&gt;</strong>: 封装了<strong>没有返回值 (void)</strong> 的方法。</li><li><strong>Func&lt;&gt;</strong>: 封装了<strong>有返回值</strong>的方法，<strong>最后一个泛型参数始终代表返回值类型</strong>。</li></ul></li><li><p><strong>基本用法：</strong></p><ol><li><p>声明委托类型：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MathOperation</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建委托实例并指向方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> =&gt; x + y;</span><br><span class="line">MathOperation op = Add;</span><br></pre></td></tr></table></figure></li><li><p>调用委托：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> result = op(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// result is 8</span></span><br><span class="line"><span class="comment">// 或使用Invoke()</span></span><br><span class="line"><span class="built_in">int</span> result2 = op.Invoke(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong><code>Func&lt;&gt;</code> 和 <code>Action&lt;&gt;</code>:</strong><br><code>Func&lt;&gt;</code> 和 <code>Action&lt;&gt;</code> 是.NET提供的内置泛型委托，让我们无需为每种签名都手动声明委托类型。</p><ul><li><strong><code>Action&lt;&gt;</code></strong>: 封装了<strong>没有返回值 (<code>void</code>)</strong> 的方法。</li><li><strong><code>Func&lt;&gt;</code></strong>: 封装了<strong>有返回值</strong>的方法，<strong>最后一个泛型参数始终代表返回值类型</strong>。</li></ul></li><li><p><strong>本章节用法详解：</strong><br>我们使用了 <code>Func&lt;ApplicationPageNames, PageViewModel&gt;</code>。这个委托精确地描述了我们工厂需要的能力：一个接收 <code>ApplicationPageNames</code> 枚举作为输入，并能返回一个 <code>PageViewModel</code> 对象作为输出的方法。通过在DI容器中注册这个 <code>Func</code>，我们实际上是注册了一个“符合该描述的生产方法”，并让 <code>PageFactory</code> 来使用它。</p></li></ul><h3 id="5-0-4-Lambda表达式和闭包-Closure"><a href="#5-0-4-Lambda表达式和闭包-Closure" class="headerlink" title="5.0.4 Lambda表达式和闭包 (Closure)"></a>5.0.4 Lambda表达式和闭包 (Closure)</h3><ul><li><p><strong>Lambda表达式 (<code>=&gt;</code>):</strong></p><ul><li><p><strong>描述：</strong> Lambda表达式是一种用于创建匿名函数的简洁语法。它使得我们可以直接在需要委托实例的地方以内联的方式编写函数体。</p></li><li><p>基本用法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (input-parameters) =&gt; &#123;statement-or-expression-body&#125;</span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; square = x =&gt; x * x;         <span class="comment">// 表达式体</span></span><br><span class="line">Action&lt;<span class="built_in">string</span>&gt; print = message =&gt;          <span class="comment">// 语句体</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>闭包 (Closure):</strong></p><ul><li><p><strong>比喻：</strong> 一个带着“魔法背包”的旅行者。旅行者是一个函数，背包是他的创建环境。背包里装着他家乡的物品（<strong>外部变量</strong>）。即使他离家远行，依然能使用背包里的东西。</p></li><li><p><strong>描述：</strong> 闭包是一个函数以及其创建时所在的**词法作用域（Lexical Scope）**的组合。该函数可以“捕获”（Capture）并访问其外部作用域中的变量，即使外部作用域的生命周期已经结束。</p></li><li><p>基本用法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Func&lt;<span class="built_in">int</span>&gt; <span class="title">CreateCounter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>; <span class="comment">// 这个变量将被闭包捕获</span></span><br><span class="line">    <span class="keyword">return</span> () =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter1 = CreateCounter();</span><br><span class="line">Console.WriteLine(counter1()); <span class="comment">// 输出 1</span></span><br><span class="line">Console.WriteLine(counter1()); <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter1</span><br></pre></td></tr></table></figure><p>这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func</span><br></pre></td></tr></table></figure><p>实例”记住”了它自己私有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count</span><br></pre></td></tr></table></figure><p>变量。</p></li></ul></li><li><p><strong>本章节用法详解 (<code>x =&gt; name =&gt; name switch</code>)：</strong><br>这是闭包在本章节中的核心应用，也是最复杂的部分。这种方式被称为“委托工厂”（Delegate Factory）。它的一个巨大优势是，PageFactory 类本身对 IServiceProvider (DI 容器) <strong>完全无知</strong>。它只依赖于一个 Func 接口，这使得 PageFactory 的可测试性变得极高，因为它不与任何具体的 DI 容器实现耦合。</p></li><li><p>我们把它分解来看：</p><ol><li><p><strong><code>collection.AddSingleton&lt;...&gt;( x =&gt; ... )</code></strong>: 注册一个单例服务。DI容器在创建这个服务时，会执行括号内的Lambda，并把<strong>容器自身 (<code>IServiceProvider</code>)</strong> 作为参数 <code>x</code> 传进去。</p></li><li><p><code>x =&gt; name =&gt; ...</code></p><p>: 这是一个返回</p><p>另一个函数</p><p>的函数。</p><ul><li><strong>外层函数 <code>x =&gt; ...</code></strong>: 它的任务是接收 <code>IServiceProvider</code> (即 <code>x</code>)，并创建一个内层函数。</li><li><strong>内层函数 <code>name =&gt; ...</code></strong>: 这个函数就是我们最终要注入到工厂里的那个 <code>Func</code> 的实体。</li></ul></li><li><p><strong>闭包的形成</strong>: 内层函数 <code>name =&gt; ...</code> 在被创建时，它所在的“家乡”环境中有变量 <code>x</code>。于是它通过闭包机制，把 <code>x</code> “打包”带走了。</p></li><li><p><strong>最终效果</strong>: 我们成功地创建并注册了一个 <code>Func&lt;ApplicationPageNames, PageViewModel&gt;</code> 委托实例。这个实例在未来的任何时候被调用时，都能访问到被它捕获的 <code>IServiceProvider</code> (<code>x</code>)，从而可以调用 <code>x.GetRequiredService&lt;T&gt;()</code> 来从DI容器中动态地、按需地创建任何已注册的服务。这完美地解决了工厂需要与DI容器交互的问题，同时又没有让工厂直接依赖于 <code>IServiceProvider</code>。</p></li></ol></li><li><p><strong>图示 (x &#x3D;&gt; name &#x3D;&gt; … 详解):</strong></p></li></ul><p><strong>第一步：定义环境 (在 App.axaml.cs 中)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">| 外部作用域 (AddSingleton 调用)                    |</span><br><span class="line">|                                                 |</span><br><span class="line">|  变量 <span class="string">&#x27;x&#x27;</span> 在此存在 (= IServiceProvider)           |</span><br><span class="line">|                                                 |</span><br><span class="line">|  +-------------------------------------------+  |</span><br><span class="line">|  | 内部函数 (name =&gt; ...) 在此创建              |  |</span><br><span class="line">|  |                                           |  |</span><br><span class="line">|  |  * 它看到并“捕获”了 <span class="string">&#x27;x&#x27;</span>                     |  |</span><br><span class="line">|  |  +---------------------+                  |  |</span><br><span class="line">|  |  | 闭包的“魔法背包”      |                  |  |</span><br><span class="line">|  |  |---------------------|                  |  |</span><br><span class="line">|  |  |  - 对 <span class="string">&#x27;x&#x27;</span> 的引用     |                  |  |</span><br><span class="line">|  |  +---------------------+                  |  |</span><br><span class="line">|  +-------------------------------------------+  |</span><br><span class="line">+-------------------------------------------------+</span><br></pre></td></tr></table></figure><p><strong>第二步：函数被传递和调用 (在 PageFactory 中)</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">| PageFactory (一个完全不同的作用域)                 |</span><br><span class="line">|                                                 |</span><br><span class="line">|  注入的 Func&lt;&gt; (我们的内部函数) 在此                |</span><br><span class="line">|                                                 |</span><br><span class="line">|  当被调用时:                                      |</span><br><span class="line">|  <span class="number">1.</span> 它打开它的“魔法背包”(闭包)                      |</span><br><span class="line">|  <span class="number">2.</span> 它找到并使用对 <span class="string">&#x27;x&#x27;</span> 的引用                      |</span><br><span class="line">|  <span class="number">3.</span> 它调用 x.GetRequiredService&lt;T&gt;()             |</span><br><span class="line">|                                                 |</span><br><span class="line">+-------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="5-1-App-axaml-cs"><a href="#5-1-App-axaml-cs" class="headerlink" title="5.1 App.axaml.cs"></a>5.1 App.axaml.cs</h3><p>修改。</p><p>这是本节课最核心的修改。App.axaml.cs 是整个应用程序的入口点，因此我们将在这里配置我们的“依赖注入容器”。可以把它想象成一个中央“服务台”，我们在这里注册所有程序需要的“服务”（在这里主要是各种ViewModel），并定义如何创建它们。当程序其他地方需要某个服务时，就向这个服务台申请，而不是自己动手创建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Avalonia;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Controls.ApplicationLifetimes;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Markup.Xaml;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Factories;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.ViewModels;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AvaloniaXamlLoader.Load(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFrameworkInitializationCompleted</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. 初始化服务集合 (ServiceCollection)</span></span><br><span class="line">        <span class="comment">// ServiceCollection 是一个DI容器的配置清单，用于注册服务及其生命周期。</span></span><br><span class="line">        <span class="keyword">var</span> collection = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">        <span class="comment">// 2. 注册服务</span></span><br><span class="line">        <span class="comment">// AddSingleton: 注册为单例生命周期。该服务在第一次被请求时创建，后续所有请求都返回同一个实例。</span></span><br><span class="line">        collection.AddSingleton&lt;MainViewModel&gt;();</span><br><span class="line">        <span class="comment">// AddTransient: 注册为瞬态生命周期。每次请求该服务时，都会创建一个全新的实例。</span></span><br><span class="line">        collection.AddTransient&lt;ActionsPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;HomePageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;MacrosPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;ProcessPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;ReporterPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;HistoryPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;SettingsPageViewModel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 注册工厂函数</span></span><br><span class="line">        <span class="comment">// 这里注册了一个Func委托，用于按需创建PageViewModel。这是一个典型的闭包应用。</span></span><br><span class="line">        <span class="comment">// - 外层 x =&gt; ...: 参数&#x27;x&#x27;是DI容器在构建此委托时自动注入的IServiceProvider实例。</span></span><br><span class="line">        <span class="comment">// - 内层 name =&gt; ...: 这是返回的实际函数，它捕获了变量&#x27;x&#x27;。</span></span><br><span class="line">        <span class="comment">// - name switch: C# 8.0的switch表达式，根据传入的&#x27;name&#x27;，使用捕获的&#x27;x&#x27;来解析并返回对应的ViewModel服务。</span></span><br><span class="line">        collection.AddSingleton&lt;Func&lt;ApplicationPageNames, PageViewModel&gt;&gt;(x =&gt; name =&gt; name <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ApplicationPageNames.Home =&gt; x.GetRequiredService&lt;HomePageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Process =&gt; x.GetRequiredService&lt;ProcessPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Macros =&gt; x.GetRequiredService&lt;MacrosPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Actions =&gt; x.GetRequiredService&lt;ActionsPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Reporter =&gt; x.GetRequiredService&lt;ReporterPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.History =&gt; x.GetRequiredService&lt;HistoryPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Settings =&gt; x.GetRequiredService&lt;SettingsPageViewModel&gt;(),</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException()</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 注册PageFactory</span></span><br><span class="line">        <span class="comment">// PageFactory本身也被注册为单例。DI容器在创建它时，会自动解析并注入其构造函数所需的Func&lt;&gt;委托。</span></span><br><span class="line">        collection.AddSingleton&lt;PageFactory&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 构建服务提供程序 (ServiceProvider)</span></span><br><span class="line">        <span class="comment">// 调用BuildServiceProvider()方法，根据ServiceCollection中的配置，创建一个ServiceProvider实例。</span></span><br><span class="line">        <span class="comment">// ServiceProvider是实际用于解析和提供服务的对象。</span></span><br><span class="line">        <span class="keyword">var</span> services = collection.BuildServiceProvider();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 启动主窗口并注入DataContext</span></span><br><span class="line">        <span class="keyword">if</span> (ApplicationLifetime <span class="keyword">is</span> IClassicDesktopStyleApplicationLifetime desktop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">              通常在 Avalonia 项目中，MainView.axaml.cs 的构造函数里会有一行 InitializeComponent()。当 MainView 被创建时，它的 DataContext 还没有被设置。</span></span><br><span class="line"><span class="comment">              如果 MainView.axaml 中有任何控件试图在 InitializeComponent() 期间绑定到DataContext 的属性，可能会产生绑定错误（虽然通常程序不会崩溃）。</span></span><br><span class="line"><span class="comment">              更稳妥的做法是先创建 MainView，再设置 DataContext，也就是下面正在做的事情。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            desktop.MainWindow = <span class="keyword">new</span> MainView</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 从DI容器中获取MainViewModel实例，并设置为MainWindow的数据上下文。</span></span><br><span class="line">                <span class="comment">// 此处不再使用`new MainViewModel()`，实现了控制反转。</span></span><br><span class="line">                DataContext = services.GetService&lt;MainViewModel&gt;()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">base</span>.OnFrameworkInitializationCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-ViewModels-HomePageViewModel-cs和ViewModels-ProcessPageViewModel-cs等"><a href="#5-2-ViewModels-HomePageViewModel-cs和ViewModels-ProcessPageViewModel-cs等" class="headerlink" title="5.2 ViewModels\HomePageViewModel.cs和ViewModels\ProcessPageViewModel.cs等"></a>5.2 ViewModels\HomePageViewModel.cs和ViewModels\ProcessPageViewModel.cs等</h3><p>修改，其他的MacrosPageViewMode.cs、HistoryPageViewModel.cs、ActionsPageViewModel.cs、ReporterPageViewModel.cs、SettingsPageViewModel.cs参照下面的修改即可，这里就不重复了。</p><p>之前，我们无法从一个ViewModel实例得知它对应的是哪个页面。为了解决这个问题，我们创建了一个新的基类<code>PageViewModel</code>（见5.7节），它有一个<code>PageName</code>属性。 现在，我们让所有的页面ViewModel都继承自<code>PageViewModel</code>，并在各自的构造函数中，明确地设置自己的<code>PageName</code>。这就像给每个ViewModel发了一个“身份证”，让我们可以随时识别它。</p><p>HomePageViewModel.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自 PageViewModel，而不是 ViewModelBase</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">HomePageViewModel</span> : <span class="title">PageViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomePageViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在构造函数中，设置自己的身份标识</span></span><br><span class="line">        PageName = ApplicationPageNames.Home;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessPageViewModel.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ProcessPageViewModel</span> : <span class="title">PageViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessPageViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PageName = ApplicationPageNames.Process;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-Views-ProcessPageView-axaml"><a href="#5-3-Views-ProcessPageView-axaml" class="headerlink" title="5.3 Views\ProcessPageView.axaml"></a>5.3 Views\ProcessPageView.axaml</h3><p>修改，这是一个连锁反应。因为我们在ProcessPageViewModel.cs中删除了之前用于测试的Test属性，所以绑定到这个属性的UI元素（比如一个Label）必须被修改或删除，否则程序在编译时会因为找不到绑定的属性而报错。这提醒我们，ViewModel和View是紧密关联的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">             mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;800&quot; d:DesignHeight=&quot;450&quot;</span><br><span class="line">             Foreground=&quot;White&quot;</span><br><span class="line">             xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">             x:DataType=&quot;vm:ProcessPageViewModel&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.Views.ProcessPageView&quot;&gt;</span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:ProcessPageViewModel&gt;&lt;/vm:ProcessPageViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    Welcome to Process!</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure><h3 id="5-4-ViewModels-MainViewModel-cs"><a href="#5-4-ViewModels-MainViewModel-cs" class="headerlink" title="5.4 ViewModels\MainViewModel.cs"></a>5.4 ViewModels\MainViewModel.cs</h3><p>修改。</p><p>MainViewModel是这次重构的最大受益者。它变得更加“干净”和“职责单一”。</p><ol><li>它不再负责创建任何页面的ViewModel。</li><li>它不再持有每个页面的ViewModel实例。</li><li>它只需要知道一个东西：PageFactory。当需要页面时，它就向工厂“下单”。</li><li>通过检查CurrentPage.PageName，它就能知道当前是哪个页面，从而更新侧边栏按钮的选中状态。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Avalonia.Svg.Skia;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Factories;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Views;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.Input;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 之前这里有一大堆各个页面的ViewModel属性，现在全部删除了。</span></span><br><span class="line">    <span class="comment">// 只保留一个对PageFactory的引用。</span></span><br><span class="line">    <span class="keyword">private</span> PageFactory _pageFactory;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _sideMenuExpanded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前页面的类型从 ViewModelBase 变成了 PageViewModel，</span></span><br><span class="line">    <span class="comment">// 这样我们就可以访问到它的 PageName 属性。</span></span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HomePageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ProcessPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ActionsPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(MacrosPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ReporterPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HistoryPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(SettingsPageIsActive))</span>]</span><br><span class="line">    <span class="keyword">private</span> PageViewModel _currentPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断按钮是否选中的逻辑，从比较ViewModel实例，</span></span><br><span class="line">    <span class="comment">// 变成了比较当前页面的PageName枚举值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HomePageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Home;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ProcessPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Process;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ActionsPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Actions;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> MacrosPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Macros;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ReporterPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Reporter;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HistoryPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.History;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SettingsPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Settings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入：</span></span><br><span class="line">    <span class="comment">// MainViewModel不再自己new任何东西，它在构造函数中声明“我需要一个PageFactory”。</span></span><br><span class="line">    <span class="comment">// DI容器在创建MainViewModel时，会自动把之前注册好的PageFactory实例传给它。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainViewModel</span>(<span class="params">PageFactory pageFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _pageFactory = pageFactory;</span><br><span class="line">        GoToHome();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SideMenuResize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SideMenuExpanded = !SideMenuExpanded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导航方法：</span></span><br><span class="line">    <span class="comment">// 不再是 CurrentPage = _homePageViewModel;</span></span><br><span class="line">    <span class="comment">// 而是向工厂请求一个新的页面ViewModel实例。</span></span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHome</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Home);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToProcess</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Process);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToMacros</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Macros);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToActions</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Actions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToReporter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Reporter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHistory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.History);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToSettings</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Settings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-Data-ApplicationPageNames-cs"><a href="#5-5-Data-ApplicationPageNames-cs" class="headerlink" title="5.5 Data\ApplicationPageNames.cs"></a>5.5 Data\ApplicationPageNames.cs</h3><p>新建Data文件夹和ApplicationPageNames.cs文件。</p><p>这是一个新建的**枚举（enum）**类型。它的作用是为我们应用程序中所有的页面定义一组固定的、有意义的名称。</p><p><strong>为什么要用枚举而不是字符串？</strong></p><ul><li><strong>类型安全：</strong> 防止在代码中出现拼写错误。如果你写”Hmoe”，编译器不会报错，但程序会出错。如果你写ApplicationPageNames.Hmoe，编译器会立刻提示你没有这个成员。</li><li><strong>代码清晰：</strong> GoToPage(ApplicationPageNames.Home)比GoToPage(“Home”)意图更明确。</li><li><strong>智能提示：</strong> 在编写代码时，IDE会提示所有可用的页面名称，非常方便。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.Data</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举来表示所有的页面名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ApplicationPageNames</span><br><span class="line">&#123;</span><br><span class="line">    Unknown, <span class="comment">// 一个默认值，用于处理未知状态</span></span><br><span class="line">    Home,</span><br><span class="line">    Process,</span><br><span class="line">    Actions,</span><br><span class="line">    Macros,</span><br><span class="line">    Reporter,</span><br><span class="line">    History,</span><br><span class="line">    Settings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6-ViewModels-PageViewModel-cs"><a href="#5-6-ViewModels-PageViewModel-cs" class="headerlink" title="5.6 ViewModels\PageViewModel.cs"></a>5.6 ViewModels\PageViewModel.cs</h3><p>新建。</p><p>这是一个新建的<strong>基类（Base Class）</strong>。它的目的是为所有“页面级别”的ViewModel提供一个共同的规范。任何继承自PageViewModel的类，都将自动拥有一个PageName属性。</p><p>这使得我们可以在MainViewModel中用一个_currentPage字段来持有任何类型的页面，并且都能安全地访问它的PageName属性来判断它到底是哪个页面。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类继承自ViewModelBase，所以它也具备INotifyPropertyChanged的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PageViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义了一个所有页面ViewModel都将拥有的属性：PageName</span></span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="keyword">private</span> ApplicationPageNames _pageName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-7-Factories-PageFactory-cs"><a href="#5-7-Factories-PageFactory-cs" class="headerlink" title="5.7 Factories\PageFactory.cs"></a>5.7 Factories\PageFactory.cs</h3><p>新建Factories文件夹和PageFactory.cs文件</p><p>这就是我们的<strong>工厂（Factory）</strong>。它的职责非常单一：<strong>根据给定的页面名称，生产出对应的页面ViewModel</strong>。</p><p>它自己并不知道具体如何创建ViewModel，而是通过构造函数注入了一个“生产方法”（也就是我们在App.axaml.cs里注册的那个复杂的Func）。当外部调用GetPageViewModel时，它只是简单地调用（Invoke）这个被注入的方法来完成生产任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.ViewModels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.Factories</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了C# 新版本的主构造函数(Primary Constructor)语法，非常简洁，这是 C# 12 (.NET 8) 中正式引入的语言特性。</span></span><br><span class="line"><span class="comment">// `(Func&lt;ApplicationPageNames, PageViewModel&gt; factory)` 直接定义了构造函数和私有字段。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PageFactory</span>(<span class="params">Func&lt;ApplicationPageNames, PageViewModel&gt; factory</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当调用此方法时，它会执行(Invoke)构造函数传入的factory委托。</span></span><br><span class="line">    <span class="comment">// `factory.Invoke(pageNames)` 最终会执行我们在App.axaml.cs中定义的switch表达式。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageViewModel <span class="title">GetPageViewModel</span>(<span class="params">ApplicationPageNames pageNames</span>)</span> =&gt; factory.Invoke(pageNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的是简洁的写法，和下面等价。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class PageFactory</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    // 这是一个私有只读字段，用来存储“生产方法”</span></span><br><span class="line"><span class="comment">    private readonly Func&lt;ApplicationPageNames, PageViewModel&gt; _pageFactory;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 通过构造函数，DI容器会将那个Func注入进来</span></span><br><span class="line"><span class="comment">    public PageFactory(Func&lt;ApplicationPageNames, PageViewModel&gt; factory)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        _pageFactory = factory;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    // 调用方法，实际上是调用存储的那个Func</span></span><br><span class="line"><span class="comment">    public PageViewModel GetPageViewModel(ApplicationPageNames pageNames)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return _pageFactory.Invoke(pageNames);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="5-8-当前目录结构"><a href="#5-8-当前目录结构" class="headerlink" title="5.8 当前目录结构"></a>5.8 当前目录结构</h3><p>去除&#x2F;bin、&#x2F;obj，让显示简洁。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">│  App.axaml</span><br><span class="line">│  App.axaml.cs</span><br><span class="line">│  app.manifest</span><br><span class="line">│  AvaloniaApplication2.csproj</span><br><span class="line">│  Program.cs</span><br><span class="line">│  ViewLocator.cs</span><br><span class="line">│</span><br><span class="line">├─Assets</span><br><span class="line">│  ├─Fonts</span><br><span class="line">│  │      AkkoPro<span class="literal">-Bold</span>.ttf</span><br><span class="line">│  │      AkkoPro<span class="literal">-Regular</span>.ttf</span><br><span class="line">│  │      Phosphor<span class="literal">-Fill</span>.ttf</span><br><span class="line">│  │      Phosphor.ttf</span><br><span class="line">│  │</span><br><span class="line">│  └─Images</span><br><span class="line">│          icon.svg</span><br><span class="line">│          logo.svg</span><br><span class="line">│</span><br><span class="line">├─<span class="keyword">Data</span></span><br><span class="line">│      ApplicationPageNames.cs</span><br><span class="line">│</span><br><span class="line">├─Factories</span><br><span class="line">│      PageFactory.cs</span><br><span class="line">│</span><br><span class="line">├─Styles</span><br><span class="line">│      AppDefaultStyles.axaml</span><br><span class="line">│</span><br><span class="line">├─ViewModels</span><br><span class="line">│      ActionsPageViewModel.cs</span><br><span class="line">│      HistoryPageViewModel.cs</span><br><span class="line">│      HomePageViewModel.cs</span><br><span class="line">│      MacrosPageViewModel.cs</span><br><span class="line">│      MainViewModel.cs</span><br><span class="line">│      PageViewModel.cs</span><br><span class="line">│      ProcessPageViewModel.cs</span><br><span class="line">│      ReporterPageViewModel.cs</span><br><span class="line">│      SettingsPageViewModel.cs</span><br><span class="line">│      ViewModelBase.cs</span><br><span class="line">│</span><br><span class="line">└─Views</span><br><span class="line">        ActionsPageView.axaml</span><br><span class="line">        ActionsPageView.axaml.cs</span><br><span class="line">        HistoryPageView.axaml</span><br><span class="line">        HistoryPageView.axaml.cs</span><br><span class="line">        HomePageView.axaml</span><br><span class="line">        HomePageView.axaml.cs</span><br><span class="line">        MacrosPageView.axaml</span><br><span class="line">        MacrosPageView.axaml.cs</span><br><span class="line">        MainView.axaml</span><br><span class="line">        MainView.axaml.cs</span><br><span class="line">        ProcessPageView.axaml</span><br><span class="line">        ProcessPageView.axaml.cs</span><br><span class="line">        ReporterPageView.axaml</span><br><span class="line">        ReporterPageView.axaml.cs</span><br><span class="line">        SettingsPageView.axaml</span><br><span class="line">        SettingsPageView.axaml.cs</span><br></pre></td></tr></table></figure><h2 id="Avalonia-学习笔记06-Page-Layout（页面布局）"><a href="#Avalonia-学习笔记06-Page-Layout（页面布局）" class="headerlink" title="Avalonia 学习笔记06. Page Layout（页面布局）"></a><a href="https://www.cnblogs.com/simonoct/p/19027878">Avalonia 学习笔记06. Page Layout（页面布局）</a></h2><p>视频链接：<a href="https://youtu.be/af__jpGGG-0?si=ql1S23F1reakjBG7">https://youtu.be/af__jpGGG-0?si=ql1S23F1reakjBG7</a></p><p>本节课程的目标是根据一个预先设计好的 UI 模型，使用 Avalonia XAML 来构建“设置”页面的<strong>结构</strong>。我们将重点放在如何使用 <code>Grid</code> 和 <code>StackPanel</code> 等布局控件来正确地放置元素，而将具体的<strong>样式</strong>（如颜色、字体、边框等）留到下一节课。这种将“结构”和“样式”分离的思路，是现代 UI 开发中的一个重要实践。</p><h3 id="6-1-ViewModels-MainViewModel-cs"><a href="#6-1-ViewModels-MainViewModel-cs" class="headerlink" title="6.1 ViewModels\MainViewModel.cs"></a>6.1 ViewModels\MainViewModel.cs</h3><p>我们首先对 <code>MainViewModel</code> 做一个小修改，以解决 XAML 设计器中的一个预览问题。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Avalonia.Svg.Skia;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Factories;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Views;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.Input;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="title">ViewModelBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> PageFactory _pageFactory;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _sideMenuExpanded = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HomePageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ProcessPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ActionsPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(MacrosPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(ReporterPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(HistoryPageIsActive))</span>]</span><br><span class="line">    [<span class="meta">NotifyPropertyChangedFor(nameof(SettingsPageIsActive))</span>]</span><br><span class="line">    <span class="keyword">private</span> PageViewModel _currentPage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HomePageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Home;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ProcessPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Process;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ActionsPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Actions;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> MacrosPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Macros;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> ReporterPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Reporter;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> HistoryPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.History;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> SettingsPageIsActive =&gt; CurrentPage.PageName == ApplicationPageNames.Settings;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 仅用于设计时 (Design-Time only constructor)。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这个无参数的构造函数是专门为 XAML 设计器准备的。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 因为我们引入了依赖注入，原来的构造函数需要一个 `PageFactory` 参数，</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这是在程序“运行时”才由 DI 容器提供的。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> XAML 设计器在“设计时”无法提供这个参数，会导致预览失败。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通过添加这个无参数构造函数，并为 `CurrentPage` 设置一个默认页面（这里是 SettingsPageViewModel），</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设计器就能够成功实例化 MainViewModel，从而正常显示 MainView 的预览界面。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = <span class="keyword">new</span> SettingsPageViewModel();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainViewModel</span>(<span class="params">PageFactory pageFactory</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _pageFactory = pageFactory;</span><br><span class="line">        GoToHome();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SideMenuResize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SideMenuExpanded = !SideMenuExpanded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHome</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Home);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToProcess</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Process);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToMacros</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Macros);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToActions</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Actions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToReporter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Reporter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToHistory</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.History);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">RelayCommand</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GoToSettings</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentPage = _pageFactory.GetPageViewModel(ApplicationPageNames.Settings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-ViewModels-SettingsPageViewModel-cs"><a href="#6-2-ViewModels-SettingsPageViewModel-cs" class="headerlink" title="6.2 ViewModels\SettingsPageViewModel.cs"></a>6.2 ViewModels\SettingsPageViewModel.cs</h3><p>这是为“设置”页面创建的新的 ViewModel。我们在这里添加一些临时的示例数据，以便在 UI 上看到列表的显示效果。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> CommunityToolkit.Mvvm.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.ViewModels</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SettingsPageViewModel</span> : <span class="title">PageViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 [ObservableProperty] 特性，CommunityToolkit.Mvvm 会自动为私有字段 `_locationPaths`</span></span><br><span class="line">    <span class="comment">// 生成一个名为 `LocationPaths` 的公共属性。</span></span><br><span class="line">    <span class="comment">// 这个属性会自动实现 INotifyPropertyChanged 接口，当它的值改变时，会通知 UI 更新。</span></span><br><span class="line">    [<span class="meta">ObservableProperty</span>]</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; _locationPaths;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SettingsPageViewModel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PageName = ApplicationPageNames.Settings;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// TEMP: Remove</span></span><br><span class="line">        <span class="comment">// 在构造函数中，我们为 LocationPaths 初始化了一些临时的假数据。</span></span><br><span class="line">        <span class="comment">// 这使得我们在开发 UI 界面时，即使没有后端逻辑，也能看到列表的实际显示效果。</span></span><br><span class="line">        <span class="comment">// 这里使用了 C# 12 的集合表达式 `[...]` 和逐字字符串 `@&quot;&quot;`，使代码更简洁。</span></span><br><span class="line">        LocationPaths =</span><br><span class="line">        [</span><br><span class="line">            <span class="string">@&quot;C:\Users\Luke\Downloads\TestActions&quot;</span>,</span><br><span class="line">            <span class="string">@&quot;C:\Users\Luke\Documents\BatchProcess&quot;</span>,</span><br><span class="line">            <span class="string">@&quot;X:\Shared\BatchProcess\Templates&quot;</span></span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-Views-SettingsPageView-axaml"><a href="#6-3-Views-SettingsPageView-axaml" class="headerlink" title="6.3 Views\SettingsPageView.axaml"></a>6.3 Views\SettingsPageView.axaml</h3><p>这是本节课的核心，即“设置”页面的 XAML 结构代码。我们一步步将设计图分解为 XAML 控件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">             xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">             mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1100&quot; d:DesignHeight=&quot;900&quot;</span><br><span class="line">             Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;</span><br><span class="line">             Foreground=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;</span><br><span class="line">             x:DataType=&quot;vm:SettingsPageViewModel&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.Views.SettingsPageView&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- </span><br><span class="line">    为设计器提供数据上下文(DataContext)。</span><br><span class="line">    这行代码告诉 XAML 设计器在预览时使用 `SettingsPageViewModel` 的一个实例作为数据源。</span><br><span class="line">    这使得在设计器中可以看到数据绑定（如 ItemsSource=&quot;&#123;Binding LocationPaths&#125;&quot;）的效果。</span><br><span class="line">    它只在设计时生效，不影响程序实际运行。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:SettingsPageViewModel&gt;&lt;/vm:SettingsPageViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- </span><br><span class="line">    页面根布局：一个2行2列的 Grid。</span><br><span class="line">    - ColumnDefinitions=&quot;*, *&quot;: 定义两个宽度相等的列，它们会平分所有可用宽度。</span><br><span class="line">    - RowDefinitions=&quot;Auto, *&quot;: 定义两行。第一行（头部）的高度由其内容决定（Auto），第二行（内容区）占据所有剩余的高度（*）。</span><br><span class="line">    这是构建经典“头+体”布局的常用方式。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Grid ColumnDefinitions=&quot;*, *&quot; RowDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;!-- Header: 头部区域 --&gt;</span><br><span class="line">        &lt;!-- Grid.ColumnSpan=&quot;2&quot; 让这个头部的 Grid 横跨两列 --&gt;</span><br><span class="line">        &lt;Grid Name=&quot;HeaderGrid&quot; Grid.ColumnSpan=&quot;2&quot;&gt;</span><br><span class="line">            &lt;!-- </span><br><span class="line">            Grid 是一个很好的堆叠控件。这里我们将 Image 和 StackPanel 放在同一个单元格中，</span><br><span class="line">            它们会重叠在一起，Image 在下，StackPanel 在上。</span><br><span class="line">            - Image 的 Stretch=&quot;UniformToFill&quot; 属性确保图片在保持自身比例的同时，填满整个容器区域，超出部分会被裁剪。</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/background-settings.svg&#125;&quot; Height=&quot;160&quot; Stretch=&quot;UniformToFill&quot;&gt;&lt;/Image&gt;</span><br><span class="line">            &lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Settings&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Version 3.0.0.2 Beta&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Compiled Jul 07 2025&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- Left side content: 左侧内容区 --&gt;</span><br><span class="line">        &lt;!-- </span><br><span class="line">        - Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; 将这个 StackPanel 放置在主 Grid 的第一列、第二行。</span><br><span class="line">        - Spacing=&quot;10&quot; 为 StackPanel 内的直接子元素（如此处的 General 和 Location 两个区域）之间添加 10 个单位的垂直间距。</span><br><span class="line">        - Margin=&quot;15&quot; 在 StackPanel 的四周添加 15 个单位的外边距，起到内边距的效果，让内容不至于贴边。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Spacing=&quot;10&quot; Margin=&quot;15&quot;&gt;</span><br><span class="line">            &lt;!-- General: “常规”设置区域 --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;General&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;!-- </span><br><span class="line">                使用一个嵌套的 Grid 来对齐左侧的描述文本和右侧的控件。</span><br><span class="line">                - ColumnDefinitions=&quot;*, Auto&quot;: 左列占据所有剩余空间，右列宽度由其内容（按钮、复选框）决定。</span><br><span class="line">                --&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, Auto&quot; RowDefinitions=&quot;Auto, Auto, Auto&quot;&gt;</span><br><span class="line">                    &lt;!-- Release license --&gt;</span><br><span class="line">                    &lt;!-- TextBlock 用于显示长文本，因为它支持 TextWrapping=&quot;Wrap&quot; 自动换行。Label 不支持。--&gt;</span><br><span class="line">                    &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;Remove license of BatchProcess from this machine and release the license back to the server ready to be transferred to another machine.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;Button Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;!-- &amp;#xE2FE; 是一个图标字体的 Unicode 编码，用于显示图标 --&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2FE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Release License&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;!-- Skip Files --&gt;</span><br><span class="line">                    &lt;TextBlock Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;Skip files if only Open, Save (Optional) and Close are Valid actions.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;CheckBox Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot;&gt;&lt;/CheckBox&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;!-- Duplicate Entries --&gt;</span><br><span class="line">                    &lt;TextBlock Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;Allow duplicate entries of the same file in project list&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;CheckBox Grid.Row=&quot;2&quot; Grid.Column=&quot;1&quot;&gt;&lt;/CheckBox&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;!-- Location: “位置”设置区域 --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;Location&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                    &lt;StackPanel&gt;</span><br><span class="line">                        &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;Add or remove the locations to search for Reporter Templates, Macros, Actions and other custom files or templates.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                        &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;All sub-directories will be searched automatically&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;/StackPanel&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;+ Folder&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">                &lt;!--</span><br><span class="line">                使用 ListBox 来显示文件夹路径列表。</span><br><span class="line">                - ItemsSource=&quot;&#123;Binding LocationPaths&#125;&quot; 是核心的数据绑定语法，它将此列表的数据源绑定到 ViewModel 中的 `LocationPaths` 属性。</span><br><span class="line">                - 选择 ListBox 而不是更基础的 ItemsControl，是因为 ListBox 自带了选中、悬停等交互效果和基本样式，方便后续功能开发。</span><br><span class="line">                --&gt;</span><br><span class="line">                &lt;ListBox ItemsSource=&quot;&#123;Binding LocationPaths&#125;&quot;&gt;&lt;/ListBox&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- Right Side Content: 右侧内容区 --&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot; Spacing=&quot;10&quot; Margin=&quot;15&quot;&gt;</span><br><span class="line">            &lt;!-- SolidWorks Host --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;SolidWorks Host&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot;&gt;</span><br><span class="line">                    BatchProcess can work locally on the current machine, or on any machine accessible</span><br><span class="line">                    over the network or even internet.&lt;LineBreak /&gt;&lt;LineBreak /&gt;</span><br><span class="line">                    </span><br><span class="line">                    Enter the machines IP address, network name or localhost for this machine.</span><br><span class="line">                &lt;/TextBlock&gt;</span><br><span class="line">                &lt;ComboBox&gt;&lt;/ComboBox&gt;</span><br><span class="line">                &lt;Label Content=&quot;Connection established&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            &lt;!-- PDM Enterprise --&gt;</span><br><span class="line">            &lt;StackPanel Spacing=&quot;15&quot;&gt;</span><br><span class="line">                &lt;Label Content=&quot;PDM Enterprise&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;If you are using PDM Enterprise enter the credentials below and test login. BatchProcess can then automatically handle checking in and out files from PDM Enterprise.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                &lt;!-- </span><br><span class="line">                这里使用三列等宽的 Grid，是为了让三个输入框（ComboBox, TextBox, TextBox）平分横向空间。</span><br><span class="line">                如果使用水平 StackPanel，它们只会各自占据所需宽度，无法实现均分拉伸的效果。</span><br><span class="line">                --&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, *, *&quot;&gt;</span><br><span class="line">                    &lt;ComboBox HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/ComboBox&gt;</span><br><span class="line">                    &lt;TextBox Grid.Column=&quot;1&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">                    &lt;TextBox Grid.Column=&quot;2&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">                &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE23E;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Login&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE094;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Refresh Vault&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;Connection Established&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            &lt;!-- Setting Cache --&gt;</span><br><span class="line">            &lt;StackPanel Spacing=&quot;15&quot;&gt;</span><br><span class="line">                &lt;Label Content=&quot;Setting Cache&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot;&gt;</span><br><span class="line">                    Various settings are stored locally including Processes, Actions, Macros, Reports and History. &lt;LineBreak /&gt;&lt;LineBreak /&gt;</span><br><span class="line">                    If you are experiencing issues you can try clearing the cache (this won&#x27;t remove the license).</span><br><span class="line">                &lt;/TextBlock&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEC54;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Clear Cache&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE5DE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Export Cache&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE20C;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Import Cache&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure><h2 id="Avalonia-学习笔记07-Control-Themes（控件主题）"><a href="#Avalonia-学习笔记07-Control-Themes（控件主题）" class="headerlink" title="Avalonia 学习笔记07. Control Themes（控件主题）"></a><a href="https://www.cnblogs.com/simonoct/p/19027881">Avalonia 学习笔记07. Control Themes（控件主题）</a></h2><p>视频链接：<a href="https://youtu.be/M3CFj0x-tts?si=n3HtIDE9YrcAKqVm">https://youtu.be/M3CFj0x-tts?si=n3HtIDE9YrcAKqVm</a></p><p>在本章节中，我们的目标是创建一个可复用的、带图标的按钮控件，以简化我们在视图（View）中编写的XAML代码。当前，每创建一个带图标的按钮，都需要在 <code>&lt;Button&gt;</code> 内部嵌套一个 <code>&lt;StackPanel&gt;</code> 和两个 <code>&lt;Label&gt;</code>，这非常繁琐。</p><p>我们将创建一个名为 <code>IconButton</code> 的新控件，它天生就包含一个图标区域和一个内容区域，使得我们可以像这样使用它：<code>&lt;IconButton IconText=&quot;...&quot; Content=&quot;...&quot;/&gt;</code>。我们将通过**控件主题（ControlTheme）**来实现这个功能，这是一种深度自定义控件外观的强大方式。</p><h3 id="7-1-Controls-IconButton-axaml"><a href="#7-1-Controls-IconButton-axaml" class="headerlink" title="7.1 Controls\IconButton.axaml"></a>7.1 Controls\IconButton.axaml</h3><p>首先，我们在项目中新建一个名为 <code>Controls</code> 的文件夹。然后右键点击该文件夹，选择“添加” -&gt; “新建项”，在 Avalonia 分类中选择 <strong>Templated Control（模板化控件）</strong>，并将其命名为 <code>IconButton.axaml</code>。</p><p>创建完成后，我们会得到一个 <code>.axaml</code> 文件和一个对应的 <code>.axaml.cs</code> 后台代码文件。</p><p>我们的目标是让 <code>IconButton</code> 拥有标准按钮的所有外观和行为，并在此基础上增加一个图标。最简单的方式就是复制 Avalonia Fluent 主题中 <code>Button</code> 的默认模板，然后进行修改。</p><p>以下代码就是从 Avalonia 源码中复制并修改而来的 <code>Button</code> 的 <code>ControlTheme</code>。</p><p>这个初始的模板可以在这个链接获取：<a href="https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Fluent/Controls/Button.xaml">https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Fluent/Controls/Button.xaml</a></p><p><strong>关键修改点解释：</strong></p><ol><li><strong><code>&lt;ControlTheme x:Key=&quot;{x:Type IconButton}&quot; TargetType=&quot;IconButton&quot;&gt;</code></strong><ul><li><strong>用途</strong>：这行代码声明了我们正在定义一个控件主题。<code>TargetType=&quot;IconButton&quot;</code> 指定了这个主题是为我们自己的 <code>IconButton</code> 控件设计的。它会成为 <code>IconButton</code> 的默认外观。</li></ul></li><li><strong><code>&lt;ContentPresenter.ContentTemplate&gt;</code></strong><ul><li><strong>用途</strong>：我们不再让 <code>ContentPresenter</code> 简单地显示内容，而是为它提供了一个 <code>DataTemplate</code>（数据模板）。这个模板定义了内容的具体结构：一个水平排列的 <code>StackPanel</code>，里面包含一个用于显示图标的 <code>Label</code> 和一个用于显示主要内容的 <code>ContentControl</code>。</li></ul></li><li><strong>图标绑定：<code>Content=&quot;{Binding $parent[IconButton].IconText}&quot;</code></strong><ul><li><strong>用途</strong>：这是 <code>DataTemplate</code> 内部的绑定语法。<code>$parent[IconButton]</code> 的意思是“从当前位置向上查找，找到第一个名为 <code>IconButton</code> 的父控件”，然后 <code>.IconText</code> 表示绑定到该控件的 <code>IconText</code> 属性。这样，我们在XAML中设置的 <code>IconText</code> 就能正确地显示为图标了。</li><li><strong>注意</strong>：<code>Label</code> 的 <code>Classes=&quot;icon&quot;</code> 是为了能让 <code>AppDefaultStyles.axaml</code> 中定义的图标字体样式应用到这个 <code>Label</code> 上。</li></ul></li><li><strong>内容和数据上下文绑定</strong><ul><li><strong>用途</strong>：<code>&lt;ContentControl DataContext=&quot;{...}&quot; Content=&quot;{...}&quot; /&gt;</code> 这一部分是为了修复一个在视频后面会遇到的 <code>DataContext</code>（数据上下文）问题。当我们在 <code>IconButton</code> 内部放置一个需要绑定到视图模型（ViewModel）的控件时（比如侧边栏可以折叠的文字），这个设置可以确保数据上下文被正确地传递下去，让绑定能够正常工作。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 备注：这是 IconButton 的视觉模板定义文件。 --&gt;</span><br><span class="line">&lt;!-- 它决定了 IconButton 在界面上看起来是什么样子。 --&gt;</span><br><span class="line">&lt;ResourceDictionary xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">                    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">                    x:ClassModifier=&quot;internal&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- Design.PreviewWith 用于在设计器中预览控件效果，不影响程序运行 --&gt;</span><br><span class="line">  &lt;Design.PreviewWith&gt;</span><br><span class="line">    &lt;Border Padding=&quot;20&quot;&gt;</span><br><span class="line">      &lt;StackPanel Spacing=&quot;20&quot;&gt;</span><br><span class="line">        &lt;IconButton IconText=&quot;&amp;#xe7f2;&quot; Content=&quot;Click Me!&quot; /&gt;</span><br><span class="line">        &lt;IconButton IconText=&quot;&amp;#xe3ee;&quot; Classes=&quot;accent&quot; Content=&quot;Click Me!&quot; /&gt;</span><br><span class="line">        &lt;Button Content=&quot;Click Me!&quot; /&gt;</span><br><span class="line">        &lt;Button Classes=&quot;accent&quot; Content=&quot;Click Me!&quot; /&gt;</span><br><span class="line">      &lt;/StackPanel&gt;</span><br><span class="line">    &lt;/Border&gt;</span><br><span class="line">  &lt;/Design.PreviewWith&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 这是 IconButton 控件的主题定义 --&gt;</span><br><span class="line">  &lt;ControlTheme x:Key=&quot;&#123;x:Type IconButton&#125;&quot; TargetType=&quot;IconButton&quot;&gt;</span><br><span class="line">    &lt;!-- 下面是按钮在各种状态下的默认样式设置（背景、前景、边框等） --&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource ButtonBackground&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource ButtonForeground&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrush&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;BorderThickness&quot; Value=&quot;&#123;DynamicResource ButtonBorderThemeThickness&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;CornerRadius&quot; Value=&quot;&#123;DynamicResource ControlCornerRadius&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Padding&quot; Value=&quot;&#123;DynamicResource ButtonPadding&#125;&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;HorizontalAlignment&quot; Value=&quot;Left&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;VerticalAlignment&quot; Value=&quot;Center&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;none&quot; /&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">      &lt;Transitions&gt;</span><br><span class="line">        &lt;TransformOperationsTransition Property=&quot;RenderTransform&quot; Duration=&quot;0:0:.075&quot; /&gt;</span><br><span class="line">      &lt;/Transitions&gt;</span><br><span class="line">    &lt;/Setter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Template 定义了控件的内部结构 (ControlTemplate) --&gt;</span><br><span class="line">    &lt;Setter Property=&quot;Template&quot;&gt;</span><br><span class="line">      &lt;ControlTemplate&gt;</span><br><span class="line">        &lt;ContentPresenter x:Name=&quot;PART_ContentPresenter&quot;</span><br><span class="line">                          Background=&quot;&#123;TemplateBinding Background&#125;&quot;</span><br><span class="line">                          BorderBrush=&quot;&#123;TemplateBinding BorderBrush&#125;&quot;</span><br><span class="line">                          BorderThickness=&quot;&#123;TemplateBinding BorderThickness&#125;&quot;</span><br><span class="line">                          CornerRadius=&quot;&#123;TemplateBinding CornerRadius&#125;&quot;</span><br><span class="line">                          Padding=&quot;&#123;TemplateBinding Padding&#125;&quot;</span><br><span class="line">                          RecognizesAccessKey=&quot;True&quot;</span><br><span class="line">                          HorizontalContentAlignment=&quot;&#123;TemplateBinding HorizontalContentAlignment&#125;&quot;</span><br><span class="line">                          VerticalContentAlignment=&quot;&#123;TemplateBinding VerticalContentAlignment&#125;&quot;&gt;</span><br><span class="line">          </span><br><span class="line">          &lt;!-- 这里是我们自定义的内容模板，用于显示图标和文字 --&gt;</span><br><span class="line">          &lt;ContentPresenter.ContentTemplate&gt;</span><br><span class="line">            &lt;DataTemplate DataType=&quot;x:Object&quot;&gt;</span><br><span class="line">              &lt;StackPanel Orientation=&quot;Horizontal&quot; Spacing=&quot;8&quot;&gt;</span><br><span class="line">                &lt;!-- 这个 Label 用于显示图标，它的 Content 绑定到 IconButton 的 IconText 属性 --&gt;</span><br><span class="line">                &lt;Label Classes=&quot;icon&quot; Content=&quot;&#123;Binding $parent[IconButton].IconText&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;!-- 这个 ContentControl 用于显示 IconButton 的主要内容，并修复了 DataContext 的问题 --&gt;</span><br><span class="line">                &lt;ContentControl DataContext=&quot;&#123;Binding $parent[IconButton].DataContext&#125;&quot; Content=&quot;&#123;Binding $parent[IconButton].Content&#125;&quot; /&gt;</span><br><span class="line">              &lt;/StackPanel&gt;</span><br><span class="line">            &lt;/DataTemplate&gt;</span><br><span class="line">          &lt;/ContentPresenter.ContentTemplate&gt;</span><br><span class="line">          </span><br><span class="line">        &lt;/ContentPresenter&gt;</span><br><span class="line">      &lt;/ControlTemplate&gt;</span><br><span class="line">    &lt;/Setter&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 下面是按钮在不同交互状态（如鼠标悬浮、按下）下的样式变化 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;^:pointerover /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource ButtonBackgroundPointerOver&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrushPointerOver&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource ButtonForegroundPointerOver&#125;&quot; /&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Style Selector=&quot;^:pressed&quot;&gt;</span><br><span class="line">      &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(0.98)&quot; /&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Style Selector=&quot;^:pressed  /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource ButtonBackgroundPressed&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrushPressed&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource ButtonForegroundPressed&#125;&quot; /&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Style Selector=&quot;^:disabled /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource ButtonBackgroundDisabled&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource ButtonBorderBrushDisabled&#125;&quot; /&gt;</span><br><span class="line">      &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource ButtonForegroundDisabled&#125;&quot; /&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这是对拥有 &quot;accent&quot; 样式的按钮的特殊处理 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;^.accent&quot;&gt;</span><br><span class="line">      &lt;Style Selector=&quot;^ /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource AccentButtonBackground&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource AccentButtonBorderBrush&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource AccentButtonForeground&#125;&quot; /&gt;</span><br><span class="line">      &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Style Selector=&quot;^:pointerover /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource AccentButtonBackgroundPointerOver&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource AccentButtonBorderBrushPointerOver&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource AccentButtonForegroundPointerOver&#125;&quot; /&gt;</span><br><span class="line">      &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Style Selector=&quot;^:pressed  /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource AccentButtonBackgroundPressed&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource AccentButtonBorderBrushPressed&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource AccentButtonForegroundPressed&#125;&quot; /&gt;</span><br><span class="line">      &lt;/Style&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Style Selector=&quot;^:disabled /template/ ContentPresenter#PART_ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource AccentButtonBackgroundDisabled&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;BorderBrush&quot; Value=&quot;&#123;DynamicResource AccentButtonBorderBrushDisabled&#125;&quot; /&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource AccentButtonForegroundDisabled&#125;&quot; /&gt;</span><br><span class="line">      &lt;/Style&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">  &lt;/ControlTheme&gt;</span><br><span class="line">&lt;/ResourceDictionary&gt;</span><br></pre></td></tr></table></figure><h3 id="7-2-Controls-IconButton-axaml-cs"><a href="#7-2-Controls-IconButton-axaml-cs" class="headerlink" title="7.2 Controls\IconButton.axaml.cs"></a>7.2 Controls\IconButton.axaml.cs</h3><p>这是 <code>IconButton</code> 的后台代码文件。</p><p><strong>关键修改点解释：</strong></p><ol><li><strong><code>public class IconButton : Button</code></strong><ul><li><strong>用途</strong>：我们将基类从默认的 <code>TemplatedControl</code> 修改为了 <code>Button</code>。这是至关重要的一步。通过继承 <code>Button</code>，我们的 <code>IconButton</code> 自动获得了按钮的所有核心功能，例如 <code>Click</code> 事件、<code>Command</code> 绑定、可点击性等。它现在“是”一个按钮了。</li></ul></li><li><strong><code>IconTextProperty</code></strong><ul><li><strong>用途</strong>：我们在这里定义了一个新的 <strong><code>StyledProperty</code>（样式化属性）</strong>，名为 <code>IconText</code>。<code>StyledProperty</code> 是 Avalonia 中的一种特殊属性，它支持数据绑定、样式设置和在模板中使用。这使得我们可以在 XAML 文件中像这样 <code>&lt;IconButton IconText=&quot;...&quot;/&gt;</code> 来给它赋值。</li></ul></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备注：这是 IconButton 的后台逻辑代码文件。</span></span><br><span class="line"><span class="keyword">using</span> Avalonia;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Controls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2.Controls</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：让 IconButton 继承自 Button，这样它就拥有了按钮的所有功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IconButton</span> : <span class="title">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个名为 IconText 的新属性，这样我们就可以在 XAML 中设置它</span></span><br><span class="line">    <span class="comment">// StyledProperty 是一种支持数据绑定和样式的特殊属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> StyledProperty&lt;<span class="built_in">string</span>&gt; IconTextProperty = AvaloniaProperty.Register&lt;IconButton, <span class="built_in">string</span>&gt;(</span><br><span class="line">        <span class="keyword">nameof</span>(IconText));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是 IconText 属性的常规 C# 包装器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> IconText</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; GetValue(IconTextProperty);</span><br><span class="line">        <span class="keyword">set</span> =&gt; SetValue(IconTextProperty, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Styles-AppDefaultStyles-axaml"><a href="#7-3-Styles-AppDefaultStyles-axaml" class="headerlink" title="7.3 Styles\AppDefaultStyles.axaml"></a>7.3 Styles\AppDefaultStyles.axaml</h3><p><strong>关键修改点解释：</strong></p><ol><li><code>:is(Button)</code> 选择器<ul><li><strong>用途</strong>：我们将之前所有针对 <code>Button</code> 的样式选择器，例如 <code>Style Selector=&quot;Button&quot;</code>，都修改为了 <code>Style Selector=&quot;:is(Button)&quot;</code>。</li><li><strong>原因</strong>：<code>:is()</code> 是一个伪类选择器，它会匹配所有符合括号内条件的控件。<code>:is(Button)</code> 不仅会匹配标准的 <code>&lt;Button&gt;</code>，还会匹配任何<strong>继承</strong>自 <code>Button</code> 的控件。因为我们的 <code>IconButton</code> 继承自 <code>Button</code>，所以这个修改可以确保我们为普通按钮编写的通用样式（如圆角、字体大小、颜色等）也能自动应用到 <code>IconButton</code> 上，保持了应用的视觉统一性。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&lt;Styles xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;</span><br><span class="line">    &lt;Design.PreviewWith&gt;</span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot; Width=&quot;200&quot;&gt;</span><br><span class="line">            &lt;!-- 此处预览代码未更改 --&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;200&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE2C2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE346;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE7F2;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE3EE;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xEB7A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button HorizontalAlignment=&quot;Stretch&quot;&gt;</span><br><span class="line">                        &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;icon&quot; Content=&quot;&amp;#xE03A;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                            &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                        &lt;/StackPanel&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                    &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/Button&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Design.PreviewWith&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 未更改的样式 --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Window&quot;&gt;</span><br><span class="line">        &lt;!-- &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt; --&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Border&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">            &lt;Transitions&gt;</span><br><span class="line">                &lt;DoubleTransition Property=&quot;Width&quot; Duration=&quot;0:0:1&quot;&gt;&lt;/DoubleTransition&gt;</span><br><span class="line">            &lt;/Transitions&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon, Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor-Fill&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0 2 5 0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;19&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Margin&quot; Value=&quot;0&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;Button, Label.akko&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource AkkoPro&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 关键修改：将 &quot;Button&quot; 选择器改为 &quot;:is(Button)&quot;，以使其能应用到 IconButton --&gt;</span><br><span class="line">    &lt;Style Selector=&quot;:is(Button)&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;CornerRadius&quot; Value=&quot;10&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button) /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Setter Property=&quot;Transitions&quot;&gt;</span><br><span class="line">            &lt;Transitions&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Foreground&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;BrushTransition Property=&quot;Background&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/BrushTransition&gt;</span><br><span class="line">                &lt;TransformOperationsTransition Property=&quot;RenderTransform&quot; Duration=&quot;0:0:0.1&quot;&gt;&lt;/TransformOperationsTransition&gt;</span><br><span class="line">            &lt;/Transitions&gt;</span><br><span class="line">        &lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button).transparent:pointerover Label&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;RenderTransform&quot; Value=&quot;scale(1.2)&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button):pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Foreground&quot; Value=&quot;&#123;DynamicResource PrimaryHoverForeground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryHoverBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button).active /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;&#123;DynamicResource PrimaryActiveBackground&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button).transparent&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    &lt;Style Selector=&quot;:is(Button).transparent Label.icon-only&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;FontFamily&quot; Value=&quot;&#123;DynamicResource Phosphor&#125;&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Style Selector=&quot;:is(Button).transparent:pointerover /template/ ContentPresenter&quot;&gt;</span><br><span class="line">        &lt;Setter Property=&quot;Background&quot; Value=&quot;Transparent&quot;&gt;&lt;/Setter&gt;</span><br><span class="line">    &lt;/Style&gt;</span><br><span class="line">&lt;/Styles&gt;</span><br></pre></td></tr></table></figure><h3 id="7-4-App-axaml"><a href="#7-4-App-axaml" class="headerlink" title="7.4 App.axaml"></a>7.4 App.axaml</h3><p><strong>关键修改点解释：</strong></p><ol><li><code>&lt;MergeResourceInclude Source=&quot;/Controls/IconButton.axaml&quot;/&gt;</code><ul><li><strong>用途</strong>：这行代码的作用是将我们刚刚创建的 <code>IconButton.axaml</code> 文件（它是一个资源字典）合并到应用的主资源中。</li><li><strong>原因</strong>：如果不进行这一步，整个应用程序将不知道 <code>IconButton</code> 的样式定义在哪里，导致 <code>IconButton</code> 无法被正确渲染，会显示为一个没有样式的空白控件。这一步使得 <code>IconButton</code> 的主题在整个应用范围内都是可用的。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;Application xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.App&quot;</span><br><span class="line">             xmlns:local=&quot;clr-namespace:AvaloniaApplication2&quot;</span><br><span class="line">             RequestedThemeVariant=&quot;Default&quot;&gt;</span><br><span class="line">             &lt;!-- &quot;Default&quot; ThemeVariant follows system theme variant. &quot;Dark&quot; or &quot;Light&quot; are other available options. --&gt;</span><br><span class="line"></span><br><span class="line">     &lt;Application.DataTemplates&gt;</span><br><span class="line">         &lt;local:ViewLocator&gt;&lt;/local:ViewLocator&gt;</span><br><span class="line">     &lt;/Application.DataTemplates&gt;</span><br><span class="line">             </span><br><span class="line">    &lt;Application.Styles&gt;</span><br><span class="line">        &lt;FluentTheme /&gt;</span><br><span class="line">        &lt;StyleInclude Source=&quot;Styles/AppDefaultStyles.axaml&quot;&gt;&lt;/StyleInclude&gt;</span><br><span class="line">    &lt;/Application.Styles&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;!-- 在这里添加了对 IconButton 样式文件的引用 --&gt;</span><br><span class="line">     &lt;Application.Resources&gt;</span><br><span class="line">         &lt;ResourceDictionary&gt;</span><br><span class="line">             &lt;ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">                 &lt;!-- 这行代码将 IconButton.axaml 中定义的样式合并到整个应用中 --&gt;</span><br><span class="line">                 &lt;MergeResourceInclude Source=&quot;/Controls/IconButton.axaml&quot;&gt;&lt;/MergeResourceInclude&gt;</span><br><span class="line">             &lt;/ResourceDictionary.MergedDictionaries&gt;</span><br><span class="line">         &lt;/ResourceDictionary&gt;</span><br><span class="line">         &lt;!-- 此处其他资源未更改 --&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryForeground&quot;&gt;#CFCFCF&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryBackground&quot;&gt;#14172D&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;LinearGradientBrush x:Key=&quot;PrimaryBackgroundGradient&quot; StartPoint=&quot;0%, 0%&quot; EndPoint=&quot;100%, 0%&quot;&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;0&quot; Color=&quot;#111214&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">             &lt;GradientStop Offset=&quot;1&quot; Color=&quot;#151E3E&quot;&gt;&lt;/GradientStop&gt;</span><br><span class="line">         &lt;/LinearGradientBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverBackground&quot;&gt;#333B5A&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryActiveBackground&quot;&gt;#6633dd&lt;/SolidColorBrush&gt;</span><br><span class="line">         &lt;SolidColorBrush x:Key=&quot;PrimaryHoverForeground&quot;&gt;White&lt;/SolidColorBrush&gt;</span><br><span class="line">         </span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoPro&quot;&gt;/Assets/Fonts/AkkoPro-Regular.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;AkkoProBold&quot;&gt;/Assets/Fonts/AkkoPro-Bold.ttf#Akko Pro&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor&quot;&gt;/Assets/Fonts/Phosphor.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line">         &lt;FontFamily x:Key=&quot;Phosphor-Fill&quot;&gt;/Assets/Fonts/Phosphor-Fill.ttf#Phosphor&lt;/FontFamily&gt;</span><br><span class="line">     &lt;/Application.Resources&gt;</span><br><span class="line">&lt;/Application&gt;</span><br></pre></td></tr></table></figure><h3 id="7-5-App-axaml-cs"><a href="#7-5-App-axaml-cs" class="headerlink" title="7.5 App.axaml.cs"></a>7.5 App.axaml.cs</h3><p><strong>关键修改点解释：</strong></p><ol><li><code>[assembly: XmlnsDefinition(...)]</code><ul><li><strong>用途</strong>：这是一个程序集级别的特性（Attribute），它将一个 C# 命名空间（<code>AvaloniaApplication2.Controls</code>）映射到一个 XML 命名空间（<code>https://github.com/avaloniaui</code>）。</li><li><strong>原因</strong>：这是一个非常有用的“语法糖”。添加它之后，我们就可以在 XAML 中直接使用 <code>&lt;IconButton /&gt;</code>，而不需要先在文件顶部定义一个像 <code>xmlns:c=&quot;clr-namespace:AvaloniaApplication2.Controls&quot;</code> 这样的前缀，然后再使用 <code>&lt;c:IconButton /&gt;</code>。它让我们的自定义控件使用起来和 Avalonia 的内置控件一样方便、自然。</li></ul></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Avalonia;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Controls.ApplicationLifetimes;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Markup.Xaml;</span><br><span class="line"><span class="keyword">using</span> Avalonia.Metadata; <span class="comment">// 需要引入这个命名空间</span></span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Data;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.Factories;</span><br><span class="line"><span class="keyword">using</span> AvaloniaApplication2.ViewModels;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键：添加这个程序集特性，让我们可以不带前缀地在 XAML 中使用 IconButton</span></span><br><span class="line">[<span class="meta">assembly: XmlnsDefinition(<span class="string">&quot;https://github.com/avaloniaui&quot;</span>, <span class="string">&quot;AvaloniaApplication2.Controls&quot;</span>)</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AvaloniaApplication2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此文件中的其他代码在本节教程中未发生变更</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        AvaloniaXamlLoader.Load(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFrameworkInitializationCompleted</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> collection = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">        collection.AddSingleton&lt;MainViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;ActionsPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;HomePageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;MacrosPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;ProcessPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;ReporterPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;HistoryPageViewModel&gt;();</span><br><span class="line">        collection.AddTransient&lt;SettingsPageViewModel&gt;();</span><br><span class="line"></span><br><span class="line">        collection.AddSingleton&lt;Func&lt;ApplicationPageNames, PageViewModel&gt;&gt;(x =&gt; name =&gt; name <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            ApplicationPageNames.Home =&gt; x.GetRequiredService&lt;HomePageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Process =&gt; x.GetRequiredService&lt;ProcessPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Macros =&gt; x.GetRequiredService&lt;MacrosPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Actions =&gt; x.GetRequiredService&lt;ActionsPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Reporter =&gt; x.GetRequiredService&lt;ReporterPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.History =&gt; x.GetRequiredService&lt;HistoryPageViewModel&gt;(),</span><br><span class="line">            ApplicationPageNames.Settings =&gt; x.GetRequiredService&lt;SettingsPageViewModel&gt;(),</span><br><span class="line">            _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException()</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        collection.AddSingleton&lt;PageFactory&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> services = collection.BuildServiceProvider();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ApplicationLifetime <span class="keyword">is</span> IClassicDesktopStyleApplicationLifetime desktop)</span><br><span class="line">        &#123;</span><br><span class="line">            desktop.MainWindow = <span class="keyword">new</span> MainView</span><br><span class="line">            &#123;</span><br><span class="line">                DataContext = services.GetService&lt;MainViewModel&gt;()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">base</span>.OnFrameworkInitializationCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-Views-MainView-axaml"><a href="#7-6-Views-MainView-axaml" class="headerlink" title="7.6 Views\MainView.axaml"></a>7.6 Views\MainView.axaml</h3><p><strong>关键修改点解释：</strong></p><ul><li><strong>替换为 <code>&lt;IconButton&gt;</code></strong>：这里是应用我们新控件最直观的地方。之前所有左侧菜单的按钮都是由 <code>&lt;Button&gt;&lt;StackPanel&gt;&lt;Label/&gt;&lt;Label/&gt;&lt;/StackPanel&gt;&lt;/Button&gt;</code> 这样的复杂结构组成的。</li><li><strong>简化XAML</strong>：现在，我们用一行简洁的 <code>&lt;IconButton&gt;</code> 就完成了同样的功能。图标通过 <code>IconText</code> 属性设置，而需要折叠的文字 <code>Label</code> 则直接作为 <code>IconButton</code> 的内容（Content）传入。这使得 XAML 代码大大减少，并且更易于阅读和维护。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;Window xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">        mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1400&quot; d:DesignHeight=&quot;800&quot;</span><br><span class="line">        Width=&quot;1400&quot; Height=&quot;800&quot;</span><br><span class="line">        MinWidth=&quot;1400&quot; MinHeight=&quot;800 &quot;</span><br><span class="line">        x:Class=&quot;AvaloniaApplication2.MainView&quot;</span><br><span class="line">        xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">        xmlns:view=&quot;clr-namespace:AvaloniaApplication2.Views&quot;</span><br><span class="line">        x:DataType=&quot;vm:MainViewModel&quot;</span><br><span class="line">        Title=&quot;AvaloniaApplication2&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:MainViewModel&gt;&lt;/vm:MainViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Grid Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot; ColumnDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;ContentControl Grid.Column=&quot;1&quot; Content=&quot;&#123;Binding CurrentPage&#125;&quot; /&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;Border Padding=&quot;20&quot; Background=&quot;&#123;DynamicResource PrimaryBackgroundGradient&#125;&quot;&gt;</span><br><span class="line">            &lt;Grid RowDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                &lt;StackPanel Spacing=&quot;12&quot;&gt;</span><br><span class="line">                    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage /Assets/Images/logo.svg&#125;&quot; Width=&quot;220&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    &lt;Image PointerPressed=&quot;InputElement_OnPointerPressed&quot; Source=&quot;&#123;SvgImage /Assets/Images/icon.svg&#125;&quot; Width=&quot;22&quot; IsVisible=&quot;&#123;Binding !SideMenuExpanded&#125;&quot;&gt;&lt;/Image&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;!-- 关键修改：将原来的复杂 Button 结构替换为简洁的 IconButton --&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE2C2;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding HomePageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToHomeCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;Home&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE346;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ProcessPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToProcessCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;Process&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE7F2;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ActionsPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToActionsCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;Actions&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE3EE;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding MacrosPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToMacrosCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;Macros&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xEB7A;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding ReporterPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToReporterCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;Reporter&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE03A;&quot; HorizontalAlignment=&quot;Stretch&quot; Classes.active=&quot;&#123;Binding HistoryPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToHistoryCommand&#125;&quot;&gt;</span><br><span class="line">                        &lt;Label Classes=&quot;akko&quot; Content=&quot;History&quot; IsVisible=&quot;&#123;Binding SideMenuExpanded&#125;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                    &lt;/IconButton&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;!-- 这个设置按钮未在本节修改，但因为它也是Button，所以会受到 :is(Button) 样式的影响 --&gt;</span><br><span class="line">                &lt;Button Classes=&quot;transparent&quot; Grid.Row=&quot;1&quot; Classes.active=&quot;&#123;Binding SettingsPageIsActive&#125;&quot; Command=&quot;&#123;Binding GoToSettingsCommand&#125;&quot;&gt;</span><br><span class="line">                    &lt;Label Classes=&quot;icon-only&quot; Content=&quot;&amp;#xE272;&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/Grid&gt;</span><br><span class="line">        &lt;/Border&gt;</span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">&lt;/Window&gt;</span><br></pre></td></tr></table></figure><h3 id="7-7-Views-SettingsPageView-axaml"><a href="#7-7-Views-SettingsPageView-axaml" class="headerlink" title="7.7 Views\SettingsPageView.axaml"></a>7.7 Views\SettingsPageView.axaml</h3><p>与 <code>MainView</code> 类似，<code>SettingsPageView</code> 中的所有带图标的按钮也被替换成了我们新的 <code>IconButton</code>。</p><p><strong>关键修改点解释：</strong></p><ul><li><strong>代码简化</strong>：这里的修改效果更加明显。对于那些内容只是简单文本的按钮，例如“Release License”，之前的XAML结构被极大地简化了。</li><li><strong>统一接口</strong>：现在，无论是只需要文本的按钮，还是需要图标+文本的按钮，我们都使用同一个 <code>IconButton</code> 控件，通过 <code>IconText</code> 和 <code>Content</code> 属性来控制其显示，使得API非常统一和清晰。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserControl xmlns=&quot;https://github.com/avaloniaui&quot;</span><br><span class="line">             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><br><span class="line">             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;</span><br><span class="line">             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;</span><br><span class="line">             xmlns:vm=&quot;clr-namespace:AvaloniaApplication2.ViewModels&quot;</span><br><span class="line">             mc:Ignorable=&quot;d&quot; d:DesignWidth=&quot;1100&quot; d:DesignHeight=&quot;900&quot;</span><br><span class="line">             Background=&quot;&#123;DynamicResource PrimaryBackground&#125;&quot;</span><br><span class="line">             Foreground=&quot;&#123;DynamicResource PrimaryForeground&#125;&quot;</span><br><span class="line">             x:DataType=&quot;vm:SettingsPageViewModel&quot;</span><br><span class="line">             x:Class=&quot;AvaloniaApplication2.Views.SettingsPageView&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Design.DataContext&gt;&lt;vm:SettingsPageViewModel&gt;&lt;/vm:SettingsPageViewModel&gt;&lt;/Design.DataContext&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Grid ColumnDefinitions=&quot;*, *&quot; RowDefinitions=&quot;Auto, *&quot;&gt;</span><br><span class="line">        &lt;!-- Header 未更改 --&gt;</span><br><span class="line">        &lt;Grid Name=&quot;HeaderGrid&quot; Grid.ColumnSpan=&quot;2&quot;&gt;</span><br><span class="line">            &lt;Image Source=&quot;&#123;SvgImage /Assets/Images/background-settings.svg&#125;&quot; Height=&quot;160&quot; Stretch=&quot;UniformToFill&quot;&gt;&lt;/Image&gt;</span><br><span class="line">            &lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Settings&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Version 3.0.0.2 Beta&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Label HorizontalAlignment=&quot;Center&quot; Content=&quot;Compiled Jul 07 2025&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/Grid&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- Left side content --&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;0&quot; Grid.Row=&quot;1&quot; Spacing=&quot;10&quot; Margin=&quot;15&quot;&gt;</span><br><span class="line">            &lt;!-- General --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;General&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, Auto&quot; RowDefinitions=&quot;Auto, Auto, Auto&quot;&gt;</span><br><span class="line">                    &lt;!-- Release license --&gt;</span><br><span class="line">                    &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;Remove license of BatchProcess from this machine and release the license back to the server ready to be transferred to another machine.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;!-- 关键修改：替换为 IconButton --&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE2FE;&quot; Content=&quot;Release License&quot; Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;!-- Skip Files --&gt;</span><br><span class="line">                    &lt;TextBlock Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;Skip files if only Open, Save (Optional) and Close are Valid actions.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;CheckBox Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot;&gt;&lt;/CheckBox&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;!-- Duplicate Entries --&gt;</span><br><span class="line">                    &lt;TextBlock Grid.Row=&quot;2&quot; Grid.Column=&quot;0&quot; TextWrapping=&quot;Wrap&quot; Text=&quot;Allow duplicate entries of the same file in project list&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                    &lt;CheckBox Grid.Row=&quot;2&quot; Grid.Column=&quot;1&quot;&gt;&lt;/CheckBox&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;!-- Location --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;Location&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, Auto&quot;&gt;</span><br><span class="line">                    &lt;StackPanel&gt;</span><br><span class="line">                        &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;Add or remove the locations to search for Reporter Templates, Macros, Actions and other custom files or templates.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                        &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;All sub-directories will be searched automatically&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                    &lt;/StackPanel&gt;</span><br><span class="line">                    </span><br><span class="line">                    &lt;Button Grid.Column=&quot;1&quot; Content=&quot;+ Folder&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/Button&gt;</span><br><span class="line">                    </span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">                &lt;ListBox ItemsSource=&quot;&#123;Binding LocationPaths&#125;&quot;&gt;</span><br><span class="line">                    </span><br><span class="line">                &lt;/ListBox&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;!-- Right Side Content --&gt;</span><br><span class="line">        &lt;StackPanel Grid.Column=&quot;1&quot; Grid.Row=&quot;1&quot; Spacing=&quot;10&quot; Margin=&quot;15&quot;&gt;</span><br><span class="line">            &lt;!-- SolidWorks Host (未更改) --&gt;</span><br><span class="line">            &lt;StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;SolidWorks Host&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot;&gt;</span><br><span class="line">                    BatchProcess can work locally on the current machine, or on any machine accessible</span><br><span class="line">                    over the network or even internet.&lt;LineBreak /&gt;&lt;LineBreak /&gt;</span><br><span class="line">                    </span><br><span class="line">                    Enter the machines IP address, network name or localhost for this machine.</span><br><span class="line">                &lt;/TextBlock&gt;</span><br><span class="line">                &lt;ComboBox&gt;&lt;/ComboBox&gt;</span><br><span class="line">                &lt;Label Content=&quot;Connection established&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            &lt;!-- PDM Enterprise --&gt;</span><br><span class="line">            &lt;StackPanel Spacing=&quot;15&quot;&gt;</span><br><span class="line">                &lt;Label Content=&quot;PDM Enterprise&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot; Text=&quot;If you are using PDM Enterprise enter the credentials below and test login. BatchProcess can then automatically handle checking in and out files from PDM Enterprise.&quot;&gt;&lt;/TextBlock&gt;</span><br><span class="line">                &lt;Grid ColumnDefinitions=&quot;*, *, *&quot;&gt;</span><br><span class="line">                    &lt;ComboBox HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/ComboBox&gt;</span><br><span class="line">                    &lt;TextBox Grid.Column=&quot;1&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">                    &lt;TextBox Grid.Column=&quot;2&quot;&gt;&lt;/TextBox&gt;</span><br><span class="line">                &lt;/Grid&gt;</span><br><span class="line">                &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                    &lt;!-- 关键修改：替换为 IconButton --&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE23E;&quot; Content=&quot;Login&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE094;&quot; Content=&quot;Refresh Vault&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">                &lt;Label Content=&quot;Connection Established&quot;&gt;&lt;/Label&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">            &lt;!-- Setting Cache --&gt;</span><br><span class="line">            &lt;StackPanel Spacing=&quot;15&quot;&gt;</span><br><span class="line">                &lt;Label Content=&quot;Setting Cache&quot;&gt;&lt;/Label&gt;</span><br><span class="line">                &lt;TextBlock TextWrapping=&quot;Wrap&quot;&gt;</span><br><span class="line">                    Various settings are stored locally including Processes, Actions, Macros, Reports and History. &lt;LineBreak /&gt;&lt;LineBreak /&gt;</span><br><span class="line">                    If you are experiencing issues you can try clearing the cache (this won&#x27;t remove the license).</span><br><span class="line">                &lt;/TextBlock&gt;</span><br><span class="line">                </span><br><span class="line">                &lt;StackPanel Orientation=&quot;Horizontal&quot;&gt;</span><br><span class="line">                    &lt;!-- 关键修改：替换为 IconButton --&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xEC54;&quot; Content=&quot;Clear Cache&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE5DE;&quot; Content=&quot;Export Cache&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                    &lt;IconButton IconText=&quot;&amp;#xE20C;&quot; Content=&quot;Import Cache&quot; Grid.Column=&quot;1&quot; HorizontalAlignment=&quot;Stretch&quot;&gt;&lt;/IconButton&gt;</span><br><span class="line">                &lt;/StackPanel&gt;</span><br><span class="line">            &lt;/StackPanel&gt;</span><br><span class="line">        &lt;/StackPanel&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/Grid&gt;</span><br><span class="line">&lt;/UserControl&gt;</span><br></pre></td></tr></table></figure><h3 id="7-8-当前目录结构"><a href="#7-8-当前目录结构" class="headerlink" title="7.8 当前目录结构"></a>7.8 当前目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">│  App.axaml</span><br><span class="line">│  App.axaml.cs</span><br><span class="line">│  app.manifest</span><br><span class="line">│  AvaloniaApplication2.csproj</span><br><span class="line">│  Program.cs</span><br><span class="line">│  ViewLocator.cs</span><br><span class="line">│</span><br><span class="line">├─Assets</span><br><span class="line">│  ├─Fonts</span><br><span class="line">│  │      AkkoPro-Bold.ttf</span><br><span class="line">│  │      AkkoPro-Regular.ttf</span><br><span class="line">│  │      Phosphor-Fill.ttf</span><br><span class="line">│  │      Phosphor.ttf</span><br><span class="line">│  │</span><br><span class="line">│  └─Images</span><br><span class="line">│          background-actions.svg</span><br><span class="line">│          background-settings.svg</span><br><span class="line">│          icon.svg</span><br><span class="line">│          logo.svg</span><br><span class="line">│</span><br><span class="line">├─Controls</span><br><span class="line">│      IconButton.axaml</span><br><span class="line">│      IconButton.axaml.cs</span><br><span class="line">│</span><br><span class="line">├─Data</span><br><span class="line">│      ApplicationPageNames.cs</span><br><span class="line">│</span><br><span class="line">├─Factories</span><br><span class="line">│      PageFactory.cs</span><br><span class="line">│</span><br><span class="line">├─Styles</span><br><span class="line">│      AppDefaultStyles.axaml</span><br><span class="line">│</span><br><span class="line">├─ViewModels</span><br><span class="line">│      ActionsPageViewModel.cs</span><br><span class="line">│      HistoryPageViewModel.cs</span><br><span class="line">│      HomePageViewModel.cs</span><br><span class="line">│      MacrosPageViewModel.cs</span><br><span class="line">│      MainViewModel.cs</span><br><span class="line">│      PageViewModel.cs</span><br><span class="line">│      ProcessPageViewModel.cs</span><br><span class="line">│      ReporterPageViewModel.cs</span><br><span class="line">│      SettingsPageViewModel.cs</span><br><span class="line">│      ViewModelBase.cs</span><br><span class="line">│</span><br><span class="line">└─Views</span><br><span class="line">        ActionsPageView.axaml</span><br><span class="line">        ActionsPageView.axaml.cs</span><br><span class="line">        HistoryPageView.axaml</span><br><span class="line">        HistoryPageView.axaml.cs</span><br><span class="line">        HomePageView.axaml</span><br><span class="line">        HomePageView.axaml.cs</span><br><span class="line">        MacrosPageView.axaml</span><br><span class="line">        MacrosPageView.axaml.cs</span><br><span class="line">        MainView.axaml</span><br><span class="line">        MainView.axaml.cs</span><br><span class="line">        ProcessPageView.axaml</span><br><span class="line">        ProcessPageView.axaml.cs</span><br><span class="line">        ReporterPageView.axaml</span><br><span class="line">        ReporterPageView.axaml.cs</span><br><span class="line">        SettingsPageView.axaml</span><br><span class="line">        SettingsPageView.axaml.cs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csharp语法</title>
      <link href="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/"/>
      <url>/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="vs设置"><a href="#vs设置" class="headerlink" title="vs设置"></a>vs设置</h2><p>vs中F6键：生成语法错误，可以定位到错误位置。</p><p>输出快捷键：cw+两次tab键 ，foreach快捷键，foreach +两次tab键</p><p>构造器快捷键：ctor+两次tab键</p><p>快速创建属性的快捷键：porp+两次tab键</p><p>激活key：BWG7X-J98B3-W34RT-33B3R-JVYW9</p><p>对于一些控件的属性设置在，视图选项卡的属性可以调出</p><p>鼠标放在某个类上直接按住F1键，会自动定位到对该类的解释文档。</p><p>自动实现接口中的所有方法：alt+insert</p><p>替换快捷键：ctrl+r</p><p>获取某一方法的所有重载：光标在括号内，然后ctrl+shift+空格</p><p>向下复制ctrl+d</p><p>插入空行：ctrl+enter</p><p>多个光标同时操作：alt+鼠标左键</p><p>整理代码：ctrl+k+f</p><span id="more"></span><h2 id="git推送"><a href="#git推送" class="headerlink" title="git推送"></a>git推送</h2><p><strong>github</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.git init，使用之前的git文件就行</span><br><span class="line"></span><br><span class="line">2.git add &quot;文件夹名称&quot;</span><br><span class="line"></span><br><span class="line">3.git commit -m &quot;注释&quot;</span><br><span class="line"></span><br><span class="line">4.git remote add origin https://github.com/gao-hongfei123/Project.git</span><br><span class="line"></span><br><span class="line">5.git pull origin master 若是不成功，在upload文件夹下执行git clean -d -fx,清除所有文件</span><br><span class="line"></span><br><span class="line">6.git push -u origin master//使用密码登录已经不行了，必须使用taken登录</span><br><span class="line"></span><br><span class="line">taken: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</span><br></pre></td></tr></table></figure><p><strong>gitee</strong></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1Mh4y1Y73m/?spm_id_from=333.337.search-card.all.click&vd_source=b7cae512e14e0a063a1ab014969b6164">使用gitee上传代码 （最简单最实用的操作）_哔哩哔哩_bilibili</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://gitee.com/gao-hongfei123/code-storage.git</span><br><span class="line">git pull origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;avalonia测试&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h2><p>参考<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.337.search-card.all.click&vd_source=b7cae512e14e0a063a1ab014969b6164">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili</a>视频</p><p>视频中命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.安装nodejs</span><br><span class="line">2.set-ExecutionPolicy RemoteSigned回车，把策略改成A</span><br><span class="line">3.npm install -g cnpm</span><br><span class="line">4.npm install -g hexo-cli</span><br><span class="line">5.建立Blog文件夹</span><br><span class="line">6.安装git，Blog文件夹下右键git bash</span><br><span class="line">7.hexo init</span><br><span class="line">8.npm install --save  hexo-deployer-git</span><br><span class="line">9.设置_config.yml文件</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">    repo: https://github.com/gao-hongfei123/gao-hongfei123.github.io</span><br><span class="line">    branch: master</span><br><span class="line">10. hexo -d</span><br><span class="line">11.报错：”不知道用户名是谁(Please tell me who you are.)“，在git bash命令窗口中输入git config --global user.name &quot;邮箱&quot;</span><br><span class="line">12.hexo -d</span><br><span class="line">13.报错 不能访问是因为网不行，等待即可.</span><br><span class="line">14.先解决部署后图片无法显示的问题再更换主题</span><br><span class="line">14.修改主题。</span><br><span class="line">15.重新hexo -d</span><br><span class="line">16.在github上图片不显示：F12观察源码，typora图片设置，_config.yml中文件配置</span><br></pre></td></tr></table></figure><p>typora偏好设置：</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20260129092758133.png" alt="image-20260129092758133"></p><p>_config.yml中的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: &#x27;时代的寒流&#x27;</span><br><span class="line">subtitle: &#x27;技术爱好者&#x27;</span><br><span class="line">description: &#x27;不断寻找人生的真谛&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: &quot;时代的寒流&quot;</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: http://gao-hongfei123.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link:</span><br><span class="line">  enable: true # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: &#x27;&#x27;</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: true</span><br><span class="line">relative_link: true</span><br><span class="line">future: true</span><br><span class="line">syntax_highlighter: highlight.js</span><br><span class="line"></span><br><span class="line">highlight:</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &#x27;&#x27;</span><br><span class="line">  per_page: 12</span><br><span class="line">  order_by: -date</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line"></span><br><span class="line"># Metadata elements</span><br><span class="line">## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta</span><br><span class="line">meta_generator: true</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span><br><span class="line">updated_option: &#x27;mtime&#x27;</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 12</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Include / Exclude file(s)</span><br><span class="line">## include:/exclude: options only apply to the &#x27;source/&#x27; folder</span><br><span class="line">include:</span><br><span class="line">exclude:</span><br><span class="line">ignore:</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: hexo-theme-matery</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: https://github.com/gao-hongfei123/gao-hongfei123.github.io</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="窗口设置"><a href="#窗口设置" class="headerlink" title="窗口设置"></a>窗口设置</h2><p>窗口标题更改：属性：外观，text修改即可</p><p>修改窗口左上角小图标：窗口样式，Icon，选择图片进行设置即可，最大不超过72x72</p><p>窗体出现的位置设置：布局，startposition。</p><p>固定窗口的大小，不允许改变：布局，AntoSize&#x3D; false</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><p>方法重载区别点：1.返回类型，2.传参类型，3.传参数目</p><p>判断类，数据类型等，type a &#x3D; typeof(int);</p><p>类的继承：使用‘：’进行继承，而java中是使用extends关键词进行继承，代码如下</p><p>class Person : Student{</p><p>}</p><p><strong>StringBuilder</strong>: 与string的区别是，前者是针对原对象进行操作的，而后者是复制一个新对象，在新对象上面进行操作。如果对字符串操作频繁，推荐使用前者，若是只操作几次，则推荐使用string，避免产生过多的对象。</p><p><strong>Sizeof</strong>方法只能计算基本数据类型的大小。例如sizeof(int)。</p><p>对一个变量求相反数：- -x这是错误的，-(-x)这是正确的。</p><p>While语句与for语句的使用情况，当知道执行循环次数的时候使用for循环，其他情况的时候都是使用while语句。Foreach语句是迭代器，只能用于迭代集合中的元素或者数组。</p><p>**readonly关键字：**const修饰的常量只能在创建的时候使用硬编码赋值，而readonly是可以在以后通过变量进行赋值并且该变量只能被赋予一次值 public readonly int ID;使用该关键字修饰的字段类似于const关键字，其中const修饰的字段只能在声明中赋值，而readonly可以在声明中或者在构造函数中赋值。所以最好是用readonly替换const</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public const int id1 = 1;必须写死，不能被计算得到</span><br><span class="line">public readonly int path = Enviroment.GetFolderPath(Enviroment.SpecialFolder.LocalApplicationData)可以计算得到</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**Guid;**global unique  identifier全球唯一标识符</p><p>main方法中string[] args 说明声明的是长度为0的字符串数组。</p><p>栈：存储局部变量</p><p>堆：new出来的对象</p><p> 默认赋值：整形：0，浮点型0.0，布尔型：false，字符型：\u0000;</p><p>静态：非静态成员方法既可以访问静态，也可以访问非静态，静态成员方法只可以访问静态</p><p>Public 不同项目中可以使用  internal(或者不写)限制在统一个项目中，被sealed修饰的类不能被继承，子类访问级别不能超过父类</p><p>**Typeof()运算符:**返回的是个Type类型等价于使用getType()方法,可以用它来作为反射,在winform中使用的场景是判断某个控件属于什么类型，例如一个button对象btn  If(btn.getType()&#x3D;&#x3D;typeof(TextBox))&#x2F;&#x2F;判断btn这个对象是否属于button类型</p><p>**Nameof(var)运算符:**返回的是变量名而不是变量值。例如console.writeLine(nameof(var1));返回的是var1,例2:console.writeLine(nameof(Myclass.method1))&#x2F;&#x2F;返回的是method1,使用它的作用就是防止在重命名变量名的时候，使用该变量名的字符串没有更改。如下</p><p>public static void method()</p><p>​    {</p><p>​      Console.WriteLine( “method”+”:输入”);</p><p>​      Console.WriteLine(“method” + “:输出”);</p><p>​    }</p><p>当使用vs的重命名功能修改method方法名为method1，则发现所有的method名称都会修改为method1，只有字符串里面的method不会修改，因为这是已经写死的，所以为了解决该问题可以使用nameof</p><p>改为如下console.writeLine($”{nameof(method)}”+”输入”);&#x2F;&#x2F;这样在重命名的时候就会一并修改为method1;</p><p><strong>Using语句</strong>：用来释放非托管资源（托管资源就是内存中的资源，比如创建的对象，变量，非托管资源就是文件流，数据库的连接，系统的窗口句柄，打印机资源等外面资源），如果不及时进行释放，其他代线程在使用该资源的时候就会报错。所以说using就是代替以及try，catch（），finally{&#x2F;&#x2F;dispose}的一种简单写法。一般用于处理各种流，使用using释放资源的对象必须实现IDisposable接口,例如TextWriter,TextReader等</p><p>例如using(Test t &#x3D; new Test()){}&#x2F;&#x2F;Test类必须实现Idisposable接口，否则报错，因为实现该接口后，在结尾处会自动调用dispose方法释放资源。</p><p>Using(filestream fs &#x3D; new filestream(“地址”)){}</p><p>等价于下面的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> static void WriteFileWithoutUsing()</span><br><span class="line">        &#123;</span><br><span class="line">            // 创建要写入临时文件的字节</span><br><span class="line">            Byte[] bytesToWrite = new byte[] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">            // 创建临时文件</span><br><span class="line">            FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                // 将字节写入临时文件</span><br><span class="line">                fs.Write(bytesToWrite, 0, bytesToWrite.Length);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                // 写入字节后显示关闭文件，这是必须要执行的</span><br><span class="line">                if (fs != null) fs.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">替换后</span><br><span class="line"> static void WriteFileWithoutUsing()</span><br><span class="line">        &#123;</span><br><span class="line">            // 创建要写入临时文件的字节</span><br><span class="line">            Byte[] bytesToWrite = new byte[] &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">            // 创建临时文件</span><br><span class="line">            using (FileStream fs = new FileStream(&quot;Temp.dat&quot;, FileMode.Create))</span><br><span class="line">            &#123;</span><br><span class="line">                // 将字节写入临时文件</span><br><span class="line">                fs.Write(bytesToWrite, 0, bytesToWrite.Length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在c#8之后，可以简化using的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">int function()&#123;</span><br><span class="line">using(var conn = new sqlSconnection(connStr))&#123;</span><br><span class="line">conn.Open();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">简化后为</span><br><span class="line">using var conn = new sqlSconnection(connStr);这样就不是在指定的作用域内进行释放了，而是在当前using所在的整个方法即function方法快要结束的时候执行dispose方法</span><br><span class="line">conn.Open();</span><br><span class="line">这样可能会出现问题，当前面已经使用using访问某个非托管资源了，在该方法内有另一个对象也要想要访问该资源，但此时该资源被占用还没有释放，解决方法：1.使用传统的using&#123;&#125;的方式，2.使用局部代码块，将using括起来例如</span><br><span class="line">方法1</span><br><span class="line">using&#123;</span><br><span class="line">var outStream = File.OpenWrite(&quot;e:/1.text&quot;);</span><br><span class="line">&#125;</span><br><span class="line">string s = File.ReadAllText(&quot;e:/1.txt&quot;);</span><br><span class="line">方法2</span><br><span class="line">&#123;</span><br><span class="line">using var outStream =File.OpenWrite(&quot;e:/1.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">string s = File.ReadAllText(&quot;e:/1.txt&quot;);</span><br></pre></td></tr></table></figure><p>**record关键字：**解决问题，对象之间使用&#x3D;&#x3D;判断是否是同一对象，如果属性都相同但是两个不同对象，结果也是false，传统方式是重写equals方法，record就是解决重写equals的问题，使用record代替class关键字，再次使用&#x3D;&#x3D;的时候就会根据对象里面的属性值进行比较代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public record Person </span><br><span class="line">&#123;</span><br><span class="line">    string firstName;</span><br><span class="line">    string lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p1 = new Person(&quot;znk&quot;, &quot;zmk&quot;);</span><br><span class="line">Person p2 = new Person(&quot;znk&quot;, &quot;zmk&quot;);</span><br><span class="line">Person p3 = new Person(&quot;ndk&quot;, &quot;nmk&quot;);</span><br><span class="line">Console.WriteLine(p1==p2);//true</span><br><span class="line">Console.WriteLine(p2==p3);//false</span><br><span class="line">Console.WriteLine(p1==p3);//false</span><br><span class="line">注意使用record在创建对象的时候必须给所有属性赋值，在进行对象比较的时候，会将两个对象的属性值一一进行对比,并且他们的属性是只读的，不能更改，解决方法实现部分可读部分可写</span><br><span class="line">public record Person(string LastName)//注意这是一个类，看上去像一个方法，LastName是只读的属性</span><br><span class="line">&#123;</span><br><span class="line">public string FirstName&#123;get;set;&#125;//FistName是可读可写属性</span><br><span class="line">public void SayHello()</span><br><span class="line">&#123;</span><br><span class="line">cw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组中的常用属性和方法：</strong></p><p>数组和集合和字典（键值对）：</p><p>数组元素数量不可变，集合可变（这是确定使用哪个进行存储的原因）</p><p>若让数组中的元素变成集合，则有两种方法1.使用数组中的toList();方法（例如arr.toList()）  2.使用Array的静态copy（）方法</p><p>属性，rank：表示维度length：数组长度      </p><p>方法：getlength（）：返回长度</p><p>​ Clear（）；将数组元素赋值为0或者null</p><p>​ Array.Sort（）；对一位数组从大到小排序</p><p>​ BinarySearch（）；进行二分法查找</p><p>​ Clone（）；赋值</p><p>​ Indexof（）；返回一维数组第一个值</p><p>​ Reverse（）；翻转数组中的元素</p><p>**is关键字：**if(bill is Person)&#x2F;&#x2F;来判断bill类型能否转换成Person类型。但是一般使用as代替is更加方便。</p><p>新用法：不仅可以判断而且如果为true的话可以进行赋值</p><p>例如if(Employ is Person person)&#x2F;&#x2F;判断Employ类是否属于Person，如果是，则将其转换为Person类并赋给person变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void testIs()</span><br><span class="line">           &#123;</span><br><span class="line">               string str=&quot;c#1200例&quot;;</span><br><span class="line">               Object obj = str;</span><br><span class="line">               if (obj is string)</span><br><span class="line">               &#123;</span><br><span class="line">                   string s = (string)obj;</span><br><span class="line">                   Console.WriteLine(&quot;可以转换&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   Console.WriteLine(&quot;不可以转换&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>**as关键字：**as也是强制转换，只不过as转换不了的话返回null，而不是报异常。</p><p>P &#x3D;Bill as Person</p><p>If(p&#x3D;&#x3D;null){&#x2F;&#x2F;逻辑代码}</p><ol start="7"><li><p>可以有多个约束</p><p>**可空类型：**例如string? name（string类型是引用类型，如果不加？的话，编译器会出现警告信息，如果其他地方使用该变量的时候发现没有赋值会报错空指针异常，加上?之后就会允许使用null类型，即允许别人调用该变量的时候是null，至于拿到null之后怎样操作是调用者的事，被调用变量只负责不报错） </p><p>int? myInt&#x3D;22;  应用场景：数据库中值类型可以为null，但是c#中值类型是不能为null，默认为0等，所以需要对应数据库，所以使用null来代替默认值0；又比如，前端没有选择某个条件会传递后端一个null，会造成前后端数据不一致，此时使用可空类型</p><p>因为模型绑定系统中，对于参数为int类型，如果url中没有传入数值，则会将int类型默认赋值为0，但是需要需要区分未赋值但系统默认为0和手动传入参数为0的两种情况，此时需要使用可空类型代替默认值0</p><p>public IActionResult Index(int? id){</p><p>​    string name;&#x2F;&#x2F;等价于string name &#x3D; null;</p><p>​    int age;&#x2F;&#x2F;等价于int age &#x3D; 0；</p><p>}</p><p>可空类型和非可空类型之间转换</p><p>Int? temp &#x3D; 22;&#x2F;&#x2F;实际上这就是非可空类型转换为可空类型</p><p>Int temp1 &#x3D; (int)temp;&#x2F;&#x2F;这就是可空类型转换为非可空类型</p><p><strong>空接合运算符：</strong>?? 例如name&#x3D;temp ?? -1;表示如果temp变量是null就返回-1，如果不是null就返回temp的值。</p><p><strong>null条件运算符：</strong>?.   在使用.的方式调用之前检查为null，则报异常，若不为null，则调用属性，例如string name&#x3D;P?.Name;若P为null则name为null，若P不为null，则name&#x3D;Name。同理decimal? price&#x3D; P?.price; 因为deciamal本身不带null。string name &#x3D; P?.Related?.Name表示若P为null或者P.Relate为null则name为空否则name&#x3D;P.Related.Name</p><p>null条件运算符保证不会抛出nullreferenceexception异常，而空接合运算符保证浏览器结果中不显示空值</p></li></ol><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><p>namespace ：use system实际上就是使用了名称空间。就是将类放在名称空间里面，例如Console.WriteLine这个方法，使用的console这个类就是system这个名称空间里面的类，如果没有use system这个调用，需要使用system.console.writeline这个方法使用，这是比较麻烦的，所以程序开头就直接引用system这个名称空间。如何寻找命名空间：把一个类名写出来后，点击这个类，左下角会自动出现所属命名空间，引用即可。</p><p>属性 property 方法：method ，事件event</p><p>命名规范：类或者接口:大驼峰</p><p>​公开成员：大驼峰</p><p>​私有成员：_+小写</p><p>​局部成员：小驼峰</p><p>​常量：全部大写</p><h3 id="属性，字段"><a href="#属性，字段" class="headerlink" title="属性，字段"></a>属性，字段</h3><p>Get,set：在c#中，使用set和get方法对字段进行设置和获取，但是不像java那么麻烦，在这两个方法中，都是通过value这个变量来作为形参，value就是外界传入的数值，它的类型与对象的字段类型是相同的。设置set和get的目的是是对字段进行private，防止暴露在外面，同时为了筛选字段条件。<font color="red">字段一般使用private修饰，作为类内部的变量使用，而属性一般使用public修饰，外界访问类对象的属性时使用，推荐使用属性，不使用字段</font>&gt;</p><p>在java中的使用方法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    private string name;</span><br><span class="line"></span><br><span class="line">​    public void setName(string name)//通过创建对象是传入name</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      this.name = name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public string  getName() &#123;</span><br><span class="line"></span><br><span class="line">​      return name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main方法中使用对象.setName()；去设置字段，使用对象.getName()；去获取字段，可以看到java中每个字段都要get和set，而c#是使用属性将get和set封装起来了</p><p>而在c#中如下class Person</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​private string name</span><br><span class="line"></span><br><span class="line">​    public string Name//这个属性就是相当于一个方法    </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​      set &#123;</span><br><span class="line"></span><br><span class="line">​        name = value;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      get &#123;</span><br><span class="line"></span><br><span class="line">​        return name;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中使用对象.Name&#x3D;”张三”的方式去设置字段（自动调用set方法,通过操作属性进而为字段赋值），使用arr&#x3D;对象.Name的方式去获取字段的值（自动调用get方法，通过操作属性获取字段的值）</p><p>注意：在c#中字段和属性相似但是不一样的，字段是不用get和set的，而属性需要get和set的，属性其使用set方法对字段赋值，使用get方法获取。对上面的name字段提供访问方法，在java中的访问是直接通过两个函数来访问，而c#中使用属性对set和get方法进行了封装，属性名（函数名）叫做Name，一般字段用小写，而属性名是对应字段名字的大写。所以我们为属性赋值的时候，会自动调用set方法进而对字段进行赋值，获取属性的时候，会自动调用get方法，获取字段中的值。get相当于一个无参的构造方法。set相当于一个具有单个属性值参数的方法。之后为了简便就不必写字段了，而是直接将属性看为字段，即上面的代码变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123;</span><br><span class="line">​Public string Name</span><br><span class="line">&#123;</span><br><span class="line">​Set;</span><br><span class="line">​Get;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再简化之后就是public string Name{set;get;}</p><p>因为属性可以直接当做字段了，所以可以为属性初始化public string Name{set;get;}&#x3D;”张三”;</p><p>它的底层代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Private string name;</span><br><span class="line"></span><br><span class="line">Public string Name</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​Set&#123;name = value&#125;//其中value=”张三”</span><br><span class="line"></span><br><span class="line">​Get&#123;return name &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是将某个字段设置为只读属性，那么只需要删掉set即可例public string Name{get;}</p><h3 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h3><p>如果类中定义了构造器，那么系统就不会提供默认无参构造器，否则系统提供默认无参构造器。构造器的作用：该类在被创建对象时，就会自动执行构造器的内容，不需要再后续代码中再重新指定，相当于所有来自于该类的对象的共有属性。</p><p>构造方法：为对象的属性进行赋值，这样在创建对象时，直接在创建对象的形参中传入参数即可，不必每次都使用set方法，例如new Student(‘张三’,23);，为了使构造方法多样性，可以重载构造方法。若自己写出有参构造方法，那么系统不会提供无参构造，无参构造需要自己写才能调用。构造方法用来初始化属性和set，get方法作用差不多，可以后续对属性进行修改，推荐使用get，set方法，因为更加灵活。</p><p>子类继承父类情况下，在子类执行自己的构造方法之前会先自动调用一下父类的构造方法。如果子类想要自动调用父类的某个指定的有参构造，那么就使用</p><p>Public Student(int x,string s):base(x,s){};即可，如果没有手动调用，那么子类会自动调用父类的无参构造，即</p><p>Class Student:Person{</p><p>public Student():base(){};&#x2F;&#x2F;这种方式等价于public Student(){};</p><p>}</p><p>还有一种情况，本类构造函数想要使用本类的其他构造函数就使用public student(int x):this(x,”hello”){}；使用这种情况的好处是一个类有好几个构造函数，且他们都需要在开始阶段执行重复的代码，那么我们就将公共代码提出来放到新的构造函数中执行，这样其他的构造函数提前使用它即可</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//判断Form类属于什么类型</span><br><span class="line">           Type myForm = typeof(Form);</span><br><span class="line">           Console.WriteLine(myForm);</span><br><span class="line">           //Console.WriteLine(Form);这是错误的，java可以直接这样输出一个类的信息，但是c#不可以</span><br></pre></td></tr></table></figure><pre><code>var的变量类型， static void Main(string[] args)    {        Console.WriteLine();        var a = 3;        var b = 3L;        var c = &quot;hello world&quot;;        Console.Write(a.GetType().Name);        Console.Write(a.GetType().Name);        Console.WriteLine(c.GetType().Name);    }结果为  Int32    Int32    String，说明var类型是个自动识别变量类型的变量。</code></pre><p>数据类型和表示范围：int ：占4个字节，long :占8个字节，byte，一个字节，short：两个字节，float :4个字节，double:8个字节，char：2个字节，bool，1&#x2F;8个字节，<font color="red">整数默认是int，小数默认是double</font>&gt;，所以long x&#x3D;8888888888L错误，float x &#x3D; 12.3错误，应为float x &#x3D; 12.3f。</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210202203407102.png" alt="image-20210202203407102"></p><p>c#五大数据类型： 1.类类型class</p><p>​    2.接口interface</p><p>​3.结构体类型struct</p><p>​4.枚举类型（enum）：即给类的某个属性设置为某几个固定值，可以任意选择。（一对多）</p><p>​5.委托类型deledates</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>在字符串中使用变量,在vs2015(c#6.0)之后使用大括号将变量括起来，同时字符串前面加上$符号，这比传统使用单引号和双引号的方式好用的多。</p><p>int var1 &#x3D; 30;</p><p>int var2 &#x3D; 60;</p><p>Console.WriteLine($”我的年龄是{var1},老师的年龄是{var2}”);</p><p>字符串的常用属性或者方法：</p><p>\1. length：属性</p><p>\2. concat：静态方法，连接字符串</p><p>\3. contaions();方法，判断参数字符串是否是对象字符串的子字符串</p><p>\4. format（）；静态方法，格式化字符串</p><p>\5. insert(parameter 1,parameter2):插入新字符串，第一个参数为插入的位置，第二个参数为插入的字符串。</p><p>\6. remove();移除子字符串，从指定位置以后全部移除</p><p>\7. replace();将字符串中旧的子字符串替换为新的子字符串</p><p>\8. split();将字符串拆分为多个子字符串数组。参数为指定的拆分字符</p><p>\9. substring()；截取字符串</p><p>\10. toLower();全部转为小写</p><p>\11. toUpper();全部转为大写</p><p>\12. 将字符串解析为数字值例如double.tryParse(“12.85”,out FirstString);会生成double类型的12.85不要使用parse，因为一旦出错会报异常，而tryparse成功会将数值传递给firststring并返回true，失败会返回false。tryparse只用于将字符串类型转换为数字类型。</p><p>案例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   string str = &quot;你深邃的眼眸abCliKlLLOO想要透漏什么密码&quot;;</span><br><span class="line">   string str0 = &quot;lkjkjsd&quot;;</span><br><span class="line">​      Console.WriteLine(str.Length);</span><br><span class="line"></span><br><span class="line">​      var str1 = str.ToUpper();</span><br><span class="line"></span><br><span class="line">​      var str2 = str.ToLower();</span><br><span class="line"></span><br><span class="line">​      var str3 = str.Substring(2,5);</span><br><span class="line"></span><br><span class="line">​      var str4 = String.Concat(str0,str1);</span><br><span class="line"></span><br><span class="line">​      var str5 = str.Insert(3,&quot;王老吉&quot;);</span><br><span class="line"></span><br><span class="line">​      var str6 = str.Remove(8);</span><br><span class="line"></span><br><span class="line">​      var str7 = str.Replace(&quot;想要透漏&quot;,&quot;不想要&quot;);</span><br><span class="line"></span><br><span class="line">​      //var str8 = str.Reverse();</span><br><span class="line"></span><br><span class="line">​      char[] ch = &#123; &#x27;邃&#x27;,&#x27;眸&#x27;,&#x27;i&#x27;,&#x27;L&#x27;,&#x27;什&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">​      string[] str9 = str.Split(ch);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str1+str2);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str3);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str4);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str.Contains(str0));</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str5);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str6);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(str7);</span><br><span class="line"></span><br><span class="line">​      foreach (var s in str9)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br></pre></td></tr></table></figure><h3 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h3><p>float，double，decimal，其中decimal一般用于货币的计算，更加精确可以表示分数,精度比double高，浮点型转decimal可能会出现溢出错误，所以通常会使用checked{}代码块检查。</p><h3 id="Dynamic关键字："><a href="#Dynamic关键字：" class="headerlink" title="Dynamic关键字："></a>Dynamic关键字：</h3><p>与var差不多，只不过var是在编译时确定类型的，而dynamic是在运行时确定数据类型的。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承：  静态方法不能被继承，</p><p>子类只能继承父类的非私有化成员，</p><p>子类不能继承父类的构造方法，若调用，需使用base关键字</p><p>若父类和子类中有相同的成员变量，根据就近原则优先使用子类的，子类没有的话会去调用父类。方法同样优先调用子类方法   </p><p>继承：子类 is 父类，is关键字就是判断符</p><p>父类的构造器不可以被子类继承，因为每个类的构造器名必须与它自己的类名相同，所以当父类使用有参构造的时候，子类中的空参构造默认调用（是调用不是继承）父类的空参构造(即类似java中子类构造器中默认会有super())，而父类不提供空参构造，所以导致报错，解决方法:在子类中创建有参构造调用父类的有参构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Son s = new Son(5000);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(s.money);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  class Father</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int money;</span><br><span class="line"></span><br><span class="line">​    public Father(int money)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      this.money = money;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Son :Father&#123;</span><br><span class="line"></span><br><span class="line">​    public Son(int money):base(money)//手动让子类的有参构造调用父类的有参构造</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>java中默认自带vurtual关键字，c#默认不自带，使用virtual修饰方法后表示这些成员将会在继承后重写里面的内容，如果不用virtual修饰，表示它是不能被重写的，virtual修饰属性表示可重写里面的get，set方法</p><p>重写：子类继承了父类中的方法，同时将父类中的方法进行了改造，优先使用子类的方法，重写的返回值是相同的或者是子父类之间的关系，参数列表必须一样</p><p>注意c#中的重写与java中的重写不一样，c#中父类被重写的方法需加上virtual关键字，子类中被重写的方法需加上override关键字，如果不加上这两个关键字，那么意味着父类和子类各有自己的introduce方法，如果此时使用多态进行父类引用子类对象时，就不会出现编译看父类运行看子类，多态也就没有意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public virtual void introduce() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是父亲类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">public override void introduce() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是儿子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Public override void introduce()&#123;</span><br><span class="line"></span><br><span class="line">​Console.writeLine(“我是孙子类”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态：（好处提高代码的复用性）为什么会有多态及为什么会有父类引用指向子类对象。</p><p>答：就是为了少写代码。例如main方法中需要一个Dog对象，一个Cat对象，可以直接创建即可，但是如果有10个类似的类，那么需要10个形参来接收，那么就太麻烦了，所以出现了接口，只要将一个接口作为形参，来接收对应的对象就可以，创建的时候就会自动指定对象的类型，可以简化代码。</p><p>当使用父类引用指向子类对象的情况时，在java中自动的，但是在c#中是需要手动设置的，当父类和子类有相同的方法，且创建对象使用的父类引用指向子类对象的方式，</p><p>前提1，具有继承关系2，有方法重写3.有父类引用指向子类对象</p><p>​对于成员变量，编译看父类，运行看父类</p><p>​对于成员方法，编译看父类，运行看子类</p><p>​对于静态方法，编译看父类，运行看父类</p><p>以上是父类和子类共有相同的方法，若子类中的方法父类没有，那么就需要进行向下转型或者向上转型：</p><p>向上转型，父类引用指向子类对象，</p><p>向下转型，使用括号进行父类转化为子类，注意，必须先完成向上转型才能接着完成向下转型。即Father father &#x3D; new Son();   Son son &#x3D; (Son)father。</p><p>举例如下</p><ol><li><p>如果想要调用的是父类中的方法，那么就在子类的对应的方法的前面用new修饰，表示隐藏</p></li><li><p>如果想要使用的子类中的方法，那么就需要在父类的方法上用virtual修饰，子类方法用override修饰。同样，在属性，事件，索引器上也可以使用virtual的修饰方法，子类重写(抽象类的重写不必再父类上加virtual，但子类必须加override)</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Person p = new Student &#123; &#125;;</span><br><span class="line"></span><br><span class="line">​      p.method();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    </span><br><span class="line"></span><br><span class="line">​    public void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;父类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Student : Person</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">​    new public  void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第二种情况：</span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Person p = new Student &#123; &#125;;</span><br><span class="line"></span><br><span class="line">​      p.method();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Person</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    Virtual public void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;父类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Student : Person</span><br><span class="line"></span><br><span class="line">  &#123; </span><br><span class="line"></span><br><span class="line">​    override public  void method()</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;子类&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强转"><a href="#强转" class="headerlink" title="强转"></a>强转</h3><p>类型强转：如果都是数字型：int，float，double之间进行强转，可以直接使用(int)double进行强转，如果是不同类型之间进行强转，比如string和int之间需要使用int.parse(string)进行强转.</p><h3 id="判断字符串不能为空的方法："><a href="#判断字符串不能为空的方法：" class="headerlink" title="判断字符串不能为空的方法："></a>判断字符串不能为空的方法：</h3><p>​方法一：使用string.isnullorempty()方法</p><p>​方法二：使用textbox.text !&#x3D; “”;</p><p>​注意：不能够使用textbox.text&#x3D; null;去判断</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类abstract</p><p>中的抽象方法强制子类必须去重写该抽象方法。抽象类的作用：1.给其他类作父类2.作为多态实现父类引用子类对象。</p><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>interface，接口仍然使用:去实现，java中是implements是实现。若子类不想要完全去实现所有的接口中的功能，例如Run方法，就使用abstract public void Run();不去重写该方法，继续作为抽象方法即可</p><p>所有方法都为抽象方法的类作为接口</p><p>接口优点：可以实现多继承</p><p>接口中成员变量默认修饰符pubic static final     </p><p>接口中所有方法不需要都去实现的话，可以自己手写一个子接口，实现总接口中的部分方法，然后让子类去实现这个子接口。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>是定义在类里面，方法的外面，然后在方法里面使用例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum level&#123;</span><br><span class="line"></span><br><span class="line">​        low,</span><br><span class="line"></span><br><span class="line">​        mid,</span><br><span class="line"></span><br><span class="line">​        high,</span><br><span class="line"></span><br><span class="line">​        super</span><br><span class="line"></span><br><span class="line">​      &#125;;</span><br></pre></td></tr></table></figure><h3 id="权限："><a href="#权限：" class="headerlink" title="权限："></a>权限：</h3><p>C#是五种访问权限</p><p>1.public（所有的类以及对程序集外部的也可见）  2.private（不带修饰符默认就是private）   3.protected（允许子类访问）  4.internal(内部的,只能被同一程序集内部访问，程序集就是一个源文件，可能包含多个类)  5.protected internal（受保护的内部的）</p><p>公开性比较大小public &gt; protect internal&gt;protect &#x3D; internal&gt;private</p><h3 id="程序集"><a href="#程序集" class="headerlink" title="程序集"></a>程序集</h3><p><a href="https://blog.csdn.net/wsnbbdbbdbbdbb/article/details/125682296">https://blog.csdn.net/wsnbbdbbdbbdbb/article/details/125682296</a></p><p><a href="https://www.cnblogs.com/cqpanda/p/16712658.html">https://www.cnblogs.com/cqpanda/p/16712658.html</a></p><p>以.dll或者.exe命名，如果说命名空间是类库的逻辑组织形式，那么程序集就是类库的物理组织形式。程序集是硬盘驱动器上存储.NET Framework中的类编译后的实际.dll文件.例如,ASP.NET Framework中包含的所有类都位于名为System.Web.dll的程序集中.要在.NET Framework中使用任何特定类,必须执行两项操作.首先,您的应用程序必须引用包含该类的程序集.其次,您的应用程序必须导入与该类关联的命名空间.（程序集就是将类库代码编译后的文件的集合）简单来说：程序集就是编译好了的类库（dll）或入口文件（exe），程序集中的代码称为IL代码，是c#代码编译后的</p><p>Assembly.loadfile(Enviroment.Currentdirection)；</p><p>assembly.getexecuteassembly()获取当前正在运行的程序集</p><h3 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h3><p>就是各种类的集合，并且给出了类之间的继承关系，提供外部使用的dll文件。与model层不一样，model层是只提供了属性。而类库中的类主要是提供了针对某一目标实现功能方法的类的集合。根据不同的目标建立不同的类库。可以使用using进行引用的前提是先将类库引用到解决方案中，nuget会自动引用类库到当前项目的referce中</p><p>引用类库的两种方法：</p><p>1.右键项目添加引用，选择类库，会将其引用（复制）到当前项目中然后才能使用using引入命名控件</p><p>2.使用Assembly.loadfile(Enviroment.Currentdirection))；通过代码进行引用，Enviroment.Currentdirection)表示获取当前当前exe文件所在的路径名,会加载到路径+debug下的文件夹，Assembly.loadfile只能加载dll类型文件，所以需要硬编码到dll文件</p><p>简单来说：程序集就是编译好了的类库（dll）或入口文件（exe）</p><h3 id="is和as"><a href="#is和as" class="headerlink" title="is和as"></a>is和as</h3><p>的使用方法：is用来判断该对象是否是某个类的对象，或者是某个类的子类的对象，返回的是一个bool型，而as原理与is相似，返回的是个对象或者null。as与强制类型转换的区别：强制类型转换，会将原有类型按照指定类型强制转移，若无法转换则报错。而as若无法转换则返回一个null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            teacher t = new teacher();</span><br><span class="line">            bool flag = t is teacher;//判断是否是t是否是teacher的对象，true</span><br><span class="line">            Console.WriteLine(flag);</span><br><span class="line">            bool flag2 = t is Person;判断是否是person的对象，因为teacher是person的子类，所以结果为true</span><br><span class="line">        Console.WriteLine(flag2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    public void think() &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class teacher : Person &#123;</span><br><span class="line">    public void study() &#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与java相似，c#创建对象的时候也有两种方式，第二种方式创建的对象只能使用一次，第一种方式创建的对象可以无限使用，其中中括号里面的内容表示对Form这个类中的属性进行更改。代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Form fm = new Form();</span><br><span class="line"></span><br><span class="line">​      fm.Text = &quot;这是我的第一个程序&quot;;</span><br><span class="line"></span><br><span class="line">​      fm.ShowDialog();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      new Form() &#123; Text = &quot;这是我的第二个程序&quot;&#125;.ShowDialog();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象："><a href="#匿名对象：" class="headerlink" title="匿名对象："></a>匿名对象：</h3><p>创建对象的另一种方式（java没有），该类没有名称，所以使用var作为接受类型，然后在{}中写入属性内容。（注意{}中不能添加方法只能添加属性）</p><p>var person &#x3D; new { name &#x3D; “张三”, age &#x3D; 64 };</p><p>​      Console.WriteLine(person.name);</p><p>​      Console.WriteLine(person.age);</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>1)将string类型转换为int类型,使用Convert类中的toInt32()方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">string str1 = “10”;</span><br><span class="line"></span><br><span class="line">​      string str2 = “20”;</span><br><span class="line"></span><br><span class="line">​      int it1 = Convert.ToInt32(str1);</span><br><span class="line"></span><br><span class="line">​      int it2 = Convert.ToInt32(str2);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(it1+it2);</span><br><span class="line"></span><br><span class="line">​2)显视类型转换，例如将Stone这个类转换为Monkey类，（这个在java中是没有办法实现的。）代码如下</span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123; </span><br><span class="line"></span><br><span class="line">​      Stone stone1 = new Stone();</span><br><span class="line"></span><br><span class="line">​      stone1.age = 5000;</span><br><span class="line"></span><br><span class="line">​      Monkey wukong = (Monkey)stone1;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(wukong.age);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Stone &#123;</span><br><span class="line"></span><br><span class="line">​    public int age;</span><br><span class="line"></span><br><span class="line">​//注意是在被转换的代码下面写如下代码</span><br><span class="line"></span><br><span class="line">​    public static explicit operator Monkey(Stone st)&#123;</span><br><span class="line"></span><br><span class="line">​      Monkey m = new Monkey();</span><br><span class="line"></span><br><span class="line">​      m.age = stone.age/500;//石头五百年相当于猴子一年</span><br><span class="line"></span><br><span class="line">​      return m;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Monkey &#123;</span><br><span class="line"></span><br><span class="line">​    public int age;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="使用get-set-方法的意义："><a href="#使用get-set-方法的意义：" class="headerlink" title="使用get(),set()方法的意义："></a>使用get(),set()方法的意义：</h3><p>为了让用户在创建对象并且为属性赋值的时候进行合法赋值（例如年龄0&lt;age&lt;100），通常将属性值设置为private权限（不让用户在没有筛选的条件下使用属性）,然后提供 set，get方法进行赋值和取值，在set，get方法中进行合理值的过滤和筛选。代码如下（注意，这是java中的代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st1 = new Student();</span><br><span class="line"></span><br><span class="line">​      st1.setAge(50);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st1.getName()+st1.getAge());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Student st2 = new Student();</span><br><span class="line"></span><br><span class="line">​      st2.setAge(100);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st2.getName()+st2.getAge());</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    private int age;</span><br><span class="line"></span><br><span class="line">​    private string name;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    public void setAge(int age) &#123;</span><br><span class="line"></span><br><span class="line">​      if (0 &lt; age &amp;&amp; age &lt; 100)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        this.age = age;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      else &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(&quot;请输入年龄在0-100之间&quot;);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int getAge() &#123;</span><br><span class="line"></span><br><span class="line">​      return this.age;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    public void setName(string name) &#123;</span><br><span class="line"></span><br><span class="line">​      this.name = name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public string getName() &#123;</span><br><span class="line"></span><br><span class="line">​      return this.name;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到java中的代码在访问属性时比较麻烦，为了想要用st1.age这种与public访问属性方式，c#创造了另一种写法，但是逻辑思想与java是一样的，代码如下</p><p>（简便书写方法，快捷键，输入propfull按两下tab键，输入对应的参数即可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st = new Student();</span><br><span class="line"></span><br><span class="line">​      st.Age = 20;//在这里可以直接使用这种方式访问（注意使用Age而不是age，相当于为age又起了一个变量名Age），下面的set代码块中限制了了用户年龄范围。</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(st.Age);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    private int age;//这个必须写，而且是private</span><br><span class="line"></span><br><span class="line">​    public int Age &#123;//这里与java不同，c#可以在创建属性的同时直接使用与get，set方法类似的代码块进行年龄范围设置，同时这里是public，相当于为age起了另一个变量名Age</span><br><span class="line"></span><br><span class="line">​      set &#123;</span><br><span class="line"></span><br><span class="line">​        if (value &gt; 0 &amp;&amp; value &lt; 100) &lt;font color = &#x27;red&#x27;&gt;//注意value此时写在get，set代码块中，value此时是个关键字（只在get，set方法中value是个关键词，在其他代码块中value不是 关键字，可以随便使用），因为此代码块中get和set不是方法所以无法传参，所以微软规定value就是这个形参，在上面st.Age = 20时，实际上value的值就等于20，若value写在string类型的代码块中，value就是个string类型的。&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          this.age = value;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​        else &#123;</span><br><span class="line"></span><br><span class="line">​          Console.WriteLine(&quot;年龄区间输入错误&quot;);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      get &#123;</span><br><span class="line"></span><br><span class="line">​        return this.age;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">还有一种写法</span><br><span class="line"></span><br><span class="line">Public int Age&#123;get;set;&#125;//这种写法是定义了一种变量Age，但是get和set中没有对Age进行限制，与public int age;</span><br></pre></td></tr></table></figure><h3 id="ref关键字："><a href="#ref关键字：" class="headerlink" title="ref关键字："></a>ref关键字：</h3><p>类似于指针，如下method方法中形参为ref类型，实参y传入后，x与y指向同一个内存地址，所以x直接操作的是y对应的地址，所以最终输出结果为101，而不是100,使用ref的特点是传递过来的实参应该是变量而不是数值，所以形参只是拿来用即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      int y = 100;</span><br><span class="line"></span><br><span class="line">​      method(ref y);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(y);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    static void method(ref int x ) &#123;</span><br><span class="line"></span><br><span class="line">​      x = x + 1;  </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Ref关键字：当传参时，若是传递的为引用参数，那么就得使用ref进行修饰。使用时必须在方法的声明和调用中都使用ref。使用该关键字的原因是在方法中对使用该关键字的引用类型对象修改时，方法执行完后修改后的对象在其他方法中仍然使用的是修改后的对象。</p><p>例如ref int value，ref Student stu;普通类型和引用类型都可以使用ref</p><p>但是如果是引用类型进行传递的话，加ref和不加ref还是有区别的，如果不加ref，传递引用类型，那么如果在方法中对引用类型的形参赋予新的对象时，就会切断形参与实参之间的联系。当加上ref后，再对形参赋予新的对象时，不会切断两者之间的联系，而且对象是实参的值。案例如下两种情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">class MyClass </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value = 20;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass mc = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之前的值为：&quot;+ mc.value);</span><br><span class="line"></span><br><span class="line">​      parameter(mc);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之后的值为：&quot;+mc.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public static void parameter(MyClass m1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      m1.value = 50;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1的值为：&quot; + m1.value);</span><br><span class="line"></span><br><span class="line">​      m1 = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(m1.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">结果为20,50,20，50</span><br><span class="line"></span><br><span class="line">第二种方式：</span><br><span class="line"></span><br><span class="line">class MyClass </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value = 20;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass mc = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之前的值为：&quot;+ mc.value);</span><br><span class="line"></span><br><span class="line">​      parameter(ref mc);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1改变之后的值为：&quot;+mc.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public static void parameter(ref MyClass m1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      m1.value = 50;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;m1的值为：&quot; + m1.value);</span><br><span class="line"></span><br><span class="line">​      m1 = new MyClass();</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(m1.value);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">结果为20,50,20,20</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="out关键字"><a href="#out关键字" class="headerlink" title="out关键字"></a>out关键字</h3><p>Out：他与ref类似，只不过是ref是在调用函数时将实参传入形参中，而out是将方法中的形参传出来放到实参中。他的作用就是使局部变量可以在方法块外面使用。double.tryParse(“12.85”,out FirstString);字符串转换double类型成功就将其放倒firststring变量中，否则返回false；并且转换完成之后自动放到FirstString里面的，不需要手动进行赋值。</p><h3 id="parames关键字"><a href="#parames关键字" class="headerlink" title="parames关键字"></a>parames关键字</h3><p>参数数组，若传递的是一个数组，那么使用params修饰，例如void test(params int[] values),但是在调用的时候不需要使用parames修饰</p><h3 id="具名参数："><a href="#具名参数：" class="headerlink" title="具名参数："></a>具名参数：</h3><p>实际上就是传参的另一种使用方法，（c#独有，意义不大）在调用method方法时，实参使用name:”张三”，age:23这种方式的好处一是可读性比较强，二是传参时可以不必按照method的形参的类型顺序进行赋值，即method(age:23,name:”张三”)这种传参方式也可以。</p><pre><code>static void Main(string[] args){  method2(name: &quot;张三&quot;,age:23);}    }static void method2(String name, int age) {  Console.WriteLine(name+age);}</code></pre><h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>数组的增删插入比较麻烦，查询,修改方便。集合查询修改比较麻烦，增删容易。如果数据的个数是固定的推荐使用数组，反之使用集合</p><p>当需要存储数据的时候,如果使用集合,在一个for循环查询数组中使用list.add()即可顺便保存到全局变量中，如果使用全部数组变量需要单独再创建一个for循环，将原数组中的每个数据保存到全局数组变量中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">方法：ArrayList list = new ArrayList();</span><br><span class="line"></span><br><span class="line">//将数据添加到链表的结尾处</span><br><span class="line"></span><br><span class="line">​list.add(“abc”);</span><br><span class="line"></span><br><span class="line">​list.add(123);</span><br><span class="line"></span><br><span class="line">//删除某一个位置的数据</span><br><span class="line"></span><br><span class="line">list.removeAt(0);</span><br><span class="line"></span><br><span class="line">​//指定删除某一个数据</span><br><span class="line"></span><br><span class="line">​List.remove(“123”);</span><br><span class="line"></span><br><span class="line">​//插入一个数据</span><br><span class="line"></span><br><span class="line">​List.insert(0,”helloword”);</span><br><span class="line"></span><br><span class="line">​//查询数据：</span><br><span class="line"></span><br><span class="line">​foreach(int i in list)&#123;</span><br><span class="line"></span><br><span class="line">​//查询即可</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary();</span><br><span class="line"></span><br><span class="line">通过键值对完成增删改查</span><br><span class="line"></span><br><span class="line">\1. 增：</span><br><span class="line"></span><br><span class="line">a) 方式一：dic.add(1,”a”);</span><br><span class="line"></span><br><span class="line">b) 方式二:dic[1] = “a”;</span><br><span class="line"></span><br><span class="line">c) 方式三：Dictionary&lt;int&gt;&lt;string&gt;  dic = new Dictionary()&#123;</span><br><span class="line"></span><br><span class="line">&#123;1,”a”&#125;,</span><br><span class="line"></span><br><span class="line">&#123;2,”b”&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">\2. 查：</span><br><span class="line"></span><br><span class="line">\1. 方式一：string str = dic[1];通过键获取值</span><br><span class="line"></span><br><span class="line">\2. foreach(keyValuePair&lt;int&gt;&lt;string&gt; item in dic)&#123;//首先获取一个键值对数据</span><br><span class="line"></span><br><span class="line">int key = item.key;//获取键</span><br><span class="line"></span><br><span class="line">string value = item.value;//获取值                                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.删：bool a = dic.remove();</span><br></pre></td></tr></table></figure><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托：  表示具有特定参数列表和返回类型的引用，好处：将方法作为参数传递出去，将方法封装成一个对象进行传递，可以完成对该方法的使用，避免重写该方法。委托是一种类。它主要用于跨线程的时候调用控件使用，对于不能直接调用的方法，需要委托给别人，即别的线程来执行。例如一个方法在一个线程中定义，而需要调用这个函数时，在另外一个线程，这是就需要使用委托</p><p>delegate（可以无返回值，可以指定返回值类型）， action和delegate的参数列表被定义到了16个，足够用户使用。</p><p>Action(无返回值的泛型)，Action&lt;int,string&gt;表示传入int，string无返回值的委托</p><p>Func（有返回值的泛型委托），Func&lt;string,int&gt;表示传入参数为string，返回值为int的委托，Func&lt;string,string,int&gt;,参数为string，string，返回值类型为int</p><p>predicate（返回值是布尔类型的泛型委托）predicate<int>表示传入参数为int，返回bool的委托。</int></p><p>自定义委托：但是上面的四种委托已经足够了，自己通过代码体验就好，但是注意，自定义委托是一种类，需声明在其他类的外面，如果声明在其他类的里面，则属于嵌套类，则在使用时需要使用 当前所在类的类名.del1  cal1 &#x3D; new  del1(c1.add);进行调用。委托的使用类似于以下代码，<font color="red">委托可以接收各种传递过来的方法变量，然后调用，而不使用委托就只能固定调用某个方法。可以节约代码</font></p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">namespace test5</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  public delegate int del1(int x,int y);//自定义的委托，与下面的Action，Func具有同样的作用,自定义委托写在其他类的外面。其中被传递的函数的返回值为int，参数为两个int型于委托的返回值类型和参数列表必须一样。</span><br><span class="line"></span><br><span class="line">  class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Calculator cl = new Calculator();</span><br><span class="line"></span><br><span class="line">​      Action action = new Action(cl.Report);</span><br><span class="line"></span><br><span class="line">​      cl.Report();//传统方法调用report方法</span><br><span class="line"></span><br><span class="line">​      action.Invoke();//使用委托调用report方法</span><br><span class="line"></span><br><span class="line">​      action();//使用委托调用另一种写法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Func&lt;int,int,int&gt; func1 = new Func&lt;int,int,int&gt;(cl.Add);//两个参数类型，一个返回类型</span><br><span class="line"></span><br><span class="line">​      Func&lt;int, int, int&gt; func2 = new Func&lt;int, int, int&gt;(cl.sub);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(func1(2,3));</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(func2(5,5));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      //使用自定义委托</span><br><span class="line"></span><br><span class="line">​      del1 cal1 = new del1(cl.Add);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(cal1(5, 6)); </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class Calculator &#123;</span><br><span class="line"></span><br><span class="line">​    public void Report() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;I have three methods&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int Add(int a,int b) &#123;</span><br><span class="line"></span><br><span class="line">​      int result = a + b;</span><br><span class="line"></span><br><span class="line">​      return result;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public int sub(int a, int b) &#123;</span><br><span class="line"></span><br><span class="line">​      int result = a - b;</span><br><span class="line"></span><br><span class="line">​      return result;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名委托：只执行一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;string,int&gt; f= delegate (string n,int i)&#123;console.writelin(n+i)&#125;;即定义一个匿名方法，该方法赋给委托f，小括号内为方法参数，大括号为方法体</span><br><span class="line">f();//调用该方法</span><br><span class="line"></span><br><span class="line">Func&lt;int,int,string&gt; f2= delegate(int i,int j)&#123;console.write(i+j)&#125;//参数为int，int返回值为string的委托</span><br></pre></td></tr></table></figure><p>多播委托：一个委托内部封装着多个方法，顺序是按照添加的顺序执行，如果想要进行多线程争抢执行顺序，需使用BeginInvoke();  方法即action1.BeginInvoke();  action2.BeginInvoke(); action3.BeginInvoke();</p><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Student st = new Student();</span><br><span class="line"></span><br><span class="line">​      Teacher t = new Teacher();</span><br><span class="line"></span><br><span class="line">​      Worker w = new Worker();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Action action1 = new Action(st.doHomeWork);</span><br><span class="line"></span><br><span class="line">​      Action action2 = new Action(t.Teach);</span><br><span class="line"></span><br><span class="line">​      Action action3 = new Action(w.work);</span><br><span class="line"></span><br><span class="line">​      //多播委托</span><br><span class="line"></span><br><span class="line">​      action1 += action2;//将action2添加到action1中</span><br><span class="line"></span><br><span class="line">​      action1 += action3;//将action3添加到action1中</span><br><span class="line"></span><br><span class="line">​      action1.Invoke();//执行顺序，按照添加顺序开始执行ation1，action2，action3</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Student &#123;</span><br><span class="line"></span><br><span class="line">​    public void doHomeWork() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是学生&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Teacher &#123;</span><br><span class="line"></span><br><span class="line">​    public void Teach() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是老师&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Worker &#123;</span><br><span class="line"></span><br><span class="line">​    public void work() &#123;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(&quot;我是工人&quot;);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义委托</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>（参考刘铁猛wpf的事件更加直观）事件的五个成员：1.事件的拥有者（例textbox对象）2.事件成员（例如textbox中的click方法）3.事件的响应者(类对象)4.事件处理器(类对象中的方法)5.事件订阅：事件 +&#x3D; 事件处理器（本质上是以委托为基础的约定）</p><p>写事件之前先把以上五个关于事件的东西写出来</p><p>事件拥有者和事件的响应者共有四种组合方式，推荐第四种</p><p>如下第一种组合方式和对应代码，</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214254615.png" alt="image-20210219214254615"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Timer time = new Timer();//事件的拥有者，即小闪电符号的就是事件，小扳手是属性，小方块是方法</span><br><span class="line">​           time.Interval = 1000;</span><br><span class="line">            Boy boy = new Boy();//事件的响应者</span><br><span class="line">            Girl girl = new Girl();</span><br><span class="line">            time.Elapsed += boy.Action;//左边是事件，右侧是事件处理器（即Action方法），中间+=就是事件的订阅</span><br><span class="line">            time.Elapsed += girl.Acton;</span><br><span class="line">            time.Start();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Boy &#123;</span><br><span class="line">    internal void Action(object sender, ElapsedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;jump&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Girl &#123;</span><br><span class="line"></span><br><span class="line">    internal void Acton(object sender, ElapsedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;sing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种组合方式，事件的拥有者和事件的响应者是两个不同的对象。代码重新看视频</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214539229.png" alt="image-20210219214539229"></p><p>第三种组合方式，事件的拥有者和事件的响应者是同一个对象</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20210219214620011.png" alt="image-20210219214620011"></p><p>第四种组合方式：事件的拥有者是事件响应者的字段成员</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            MyForm mf = new MyForm();</span><br><span class="line">            mf.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class MyForm : Form &#123;//myFrom 作为事件的响应者</span><br><span class="line">        private Button button;//事件拥有者</span><br><span class="line">        private TextBox tb;</span><br><span class="line">        public MyForm()</span><br><span class="line">        &#123;</span><br><span class="line">            button = new Button();</span><br><span class="line">            tb = new TextBox();</span><br><span class="line">            this.Controls.Add(button);</span><br><span class="line">            this.Controls.Add(tb);</span><br><span class="line">            this.button.Click += this.action;//事件+=事件处理=》事件订阅</span><br><span class="line">            this.button.Text = &quot;say hello&quot;;</span><br><span class="line">            this.button.Top = 50;</span><br><span class="line">        &#125;</span><br><span class="line">        private void action(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        this.tb.Text = &quot;helloWorld&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对事件订阅时，即左侧为事件，右侧为事件处理，整个过程为订阅，则<strong>订阅过程共有三种写法</strong>，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public partial class Form1 : Form</span><br><span class="line">    &#123;</span><br><span class="line">        public Form1()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            //this.button3.Click += this.button_Click;//这是第一种写法</span><br><span class="line">            //第二种写法，使用了EventHandler进行了委托</span><br><span class="line">            this.button3.Click += new EventHandler(this.button_Click);</span><br><span class="line">            //第三种写法，lamdam表达式</span><br><span class="line">            this.button3.Click += (sender, e) =&gt; &#123; this.textBox1.Text = &quot;我是button3&quot;; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void button_Click(object sender, EventArgs e)</span><br><span class="line">        &#123;//一个事件处理器可以挂接多个不同的事件</span><br><span class="line">            if (sender == button1) &#123;</span><br><span class="line">                this.textBox1.Text = &quot;我是button1&quot;;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if (sender == button2) &#123;</span><br><span class="line">                this.textBox1.Text = &quot;我是button2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型：为什么用泛型？防止类膨胀和成员膨胀。</p><p><font color="red">泛型只是起到一个占位符的作用，对于类名后面加泛型，不需要传入对象，而是在使用它的时候知道是什么类型即可，如果是自己设计的泛型类，一般设计将泛型应用在方法的形参上，但大部分是使用别人的泛型类，所以需要了解该类中的该泛型起到了什么作用（一般也是用在方法的形参上，或者方法的返回值上），泛型方法是在调用该方法的时候确定类型，</font><a href="https://www.cnblogs.com/forever-Ys/p/10304276.html">https://www.cnblogs.com/forever-Ys/p/10304276.html</a></p><p>使用泛型的情况，类太多和成员变量太多或者不确定变量类型属于什么类型。方法泛型：当形参接受不同的数据类型，但是方法中对形参处理的逻辑一样就考虑使用方法泛型。只要写变量类型的时候就考虑用泛型 。</p><p>类膨胀如下，苹果对应一个盒子类和一个产品类，书对应一个盒子类一个产品类，那么1000中对应2000个类，这就是成员膨胀</p><p>泛型用在返回值类型的位置表示返回值类型为某个泛型类型，用在类名后面表示在该类的方法里面，泛型将作为形参传入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      AppleBox box = new AppleBox() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box.cargo.color);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​      Book bk = new Book() &#123; bookName = &quot;new book&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      BookBox bb = new BookBox() &#123; book = bk &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(bb.book.bookName);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class AppleBox &#123;</span><br><span class="line"></span><br><span class="line">​    public Apple cargo &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class BookBox &#123;</span><br><span class="line"></span><br><span class="line">​    public Book book &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>成员膨胀：如下，在创建box1对象时，只用到了Apple这个属性，创建box2这个对象时只用到了Book这个属性，如果1000中商品，在Box类中就有1000个类属性，创建一个对象时，其他属性就多余，这就属于成员膨胀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      Book book = new Book()&#123; bookName = &quot;new book&quot;&#125;;</span><br><span class="line"></span><br><span class="line">​      Box box1 = new Box() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Box box2 = new Box() &#123; bk = book &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box1.cargo.color);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box2.bk.bookName);</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Box &#123;</span><br><span class="line"></span><br><span class="line">​    public Apple cargo &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">​    public Book bk &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解决方法：使用泛型，如下，当Box后面使用<Tcargo>说明，当创建Box对象时&lt;&gt;里面是什么类型，那么该类型会自动替换Box类中的Tcargo作为一种类型，box1中的cargo类型就是Apple类型，box2中的cargo类型就是Book类型。</Tcargo></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      Apple apple = new Apple() &#123; color = &quot;red&quot; &#125;;</span><br><span class="line"></span><br><span class="line">​      Book book = new Book()&#123; bookName = &quot;new book&quot;&#125;;</span><br><span class="line"></span><br><span class="line">​      Box&lt;Apple&gt; box1 = new Box&lt;Apple&gt;() &#123; cargo = apple &#125;;</span><br><span class="line"></span><br><span class="line">​      Box&lt;Book&gt; box2 = new Box&lt;Book&gt;() &#123; cargo = book &#125;;</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box1.cargo.color);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(box2.cargo.bookName);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Apple &#123;</span><br><span class="line"></span><br><span class="line">​    public string  color &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Box&lt;Tcargo&gt; &#123;</span><br><span class="line"></span><br><span class="line">​    public Tcargo cargo &#123; get; set; &#125;  </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Book &#123;</span><br><span class="line"></span><br><span class="line">​    public String bookName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>泛型约束：**Where关键字：**在定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的类型种类施加限制。 如果客户端代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译时错误。 这些限制称为约束。 约束是使用 where 上下文关键字指定的。</p><p>例如class MyClass&lt;T1,T2,T3&gt; where T2:Customer where T3:IComparable</p><p>约束总共有可以约束7种情况：</p><ol><li><p>约束是值类型：public void method<T>(T t) where T:struct</T></p></li><li><p>约束为引用类型public void method<T>(T t) where T:class</T></p></li><li><p>指定泛型具有无参的构造方法public void method<T>(T t) where T:new()</T></p></li><li><p>指定泛型类为某个类或者其子类 public void method<T>(T t) where T:Person</T></p></li><li><p>接口同4</p></li><li><p>指定T提供的参数必须为U提供的参数</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class sample&lt;U&gt;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​Public void method&lt;T&gt;(T t) where T:U</span><br><span class="line"></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7. </p><h3 id="Partial类"><a href="#Partial类" class="headerlink" title="Partial类"></a>Partial类</h3><p>当项目比较庞大时，使用分布类可以将一个类拆分至几个文件中，这样可以使不同的开发人员同时工作，提升了工作效率。</p><p>使用别处的类的时候，无需创建新文件，只需要引用别处的文件中的类。</p><p>一般不使用，涉及到多人开发时才会使用。按照规范，一个类中一般不超过500行，一旦超过500行，就要使用分布类。</p><h2 id="Lambda表达式：相当于一个匿名方法"><a href="#Lambda表达式：相当于一个匿名方法" class="headerlink" title="Lambda表达式：相当于一个匿名方法"></a>Lambda表达式：相当于一个匿名方法</h2><p>Lambda表达式：在参数列表和表达式之间必须用&#x3D;&gt;连接。当一个方法它的内容不超过三行代码时，就直接用lambda表达式。</p><p>委托和lambda表达式混用：例如Fun&lt;int,int,int&gt; add &#x3D; (i,j)&#x3D;&gt;{return i+j};实际上就是为委托赋予了一个方法，该方法使用lambda表达式。参数为i,j,返回值为i+j。fun的传递的两个参数为int型，返回类型也为int型。所以在见到传递参数为func的时候，我们可以直接传递lambda表达式即可。</p><p>使用情况：在程序中只调用一次，可以使用lambda表达式，不用再创建类和方法进行调用，例如Func&lt;int,int,int&gt; func &#x3D; new Func&lt;int,int,int&gt;({int a,int b}&#x3D;&gt;{return a+b;});进行加法运算,简化后为Func&lt;int,int,int&gt; func &#x3D; (a,b)&#x3D;&gt;{return a+b;};</p><p>若方法体中没有返回值且只有一行代码，则方法体的大括号可以去掉，例如Action ac &#x3D; ()&#x3D;&gt;cosole.writeline(“你好”);</p><p>若方法体中有返回值但只有一行代码，则可以省略return以及大括号，例如Func&lt;int,int,string&gt; f1 &#x3D; (i1,i2)&#x3D;&gt;i1+i2</p><p>若只有一个参数，则参数的小括号可以省略，Action&lt;string,&gt; f1 &#x3D;s&#x3D;&gt;console.writeLine(s);  Func&lt;int,bool&gt; f2 &#x3D;i&#x3D;&gt; i&gt;0;</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      DoSomeCalc((a,b)=&gt;&#123;return a*b;&#125;,100,200);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    static void DoSomeCalc&lt;T&gt;(Func&lt;T, T, T&gt; func, T x, T y) &#123;</span><br><span class="line"></span><br><span class="line">​      T res = func(x, y);</span><br><span class="line"></span><br><span class="line">​      Console.WriteLine(res);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>lambda作为参数传递：会发现某些方法中要求传入func委托，实际上传入lambda即可例如数组有有个Count（Func&lt;T,bool&gt;）要求传入参数为T类型，返回值类型为bool类型的函数，但是T是什么时候传入的呢？bool又是什么时候使用的呢？T实际上是再Count()函数体里面传入的，需要查看源码，而不是在调用count函数作为参数传入的。返回的类型也是在count函数体里面使用的，若返回为true则把当前数值作为总数的一个。同理中间件中有个run方法，可以通过设置options对象进行配置，该对象也是在run方法里面自动进行传入的。即lambda表达式的参数和返回值都是在调用它的函数里面传入和使用的，具体怎样使用我们是未知的  </p><h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><p>使用情况：需要为某个类添加方法时传统方法是修改代码，C#提供扩展方法</p><p>比如想要在某个类中添加其他一些方法，如果有源码，那么可以直接添加源码，如果没有源码，那么应该怎么办，就是使用扩展方法，但是扩展方法必须是静态的，它写在 一个静态类里面，该静态类随便起名，因为用不到该类名，只用到该方法名，然后在对应的静态方法上使用(this 类名 对象名)的方式来指定该方法属于哪个类中的扩展方法。而静态类实际上就是起一个封装的作用，不参与任何调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public static class exMethod</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Public Static void add(this Test test)&#123;//逻辑代码&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：<font color="red">静态类里的静态方法，参数列表最前面加this+要扩展的类型</font>&gt;</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Calculate&#123;//类中原本只有add方法</span><br><span class="line">public int add(int a,int b)&#123;</span><br><span class="line">return a+b;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">static class CalculateNew&#123;//使用扩展方法为Calculate添加addNew方法</span><br><span class="line"></span><br><span class="line">​public static int addNew(this Calculate cal,int a,int b,int c )&#123;//Calculate就是要为Claculate中添加了addNew方法</span><br><span class="line"></span><br><span class="line">​return a+b+c;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IComparable接口："><a href="#IComparable接口：" class="headerlink" title="IComparable接口："></a>IComparable接口：</h2><p>该接口只有一个方法Compareto方法。我们在创建对象的时候就要想到是否有必要去实现比较器功能。</p><p>当int数组需要排序时，只需要使用Array.Sort();方法即可，这是因为int类型实现了Icomparable接口，如果是我们自定义的类数组进行比较大小，那么无法使用sort，解决方法就是使用Icomprable中的compareto方法根据对象中的字段比较大小，然后就可以使用sort方法了。但是还有更加简单的方法排序方法可以替代它不用写compareto就是使用linq代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    static void Main(string[] args)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      MyClass[] mc = new MyClass[3];</span><br><span class="line"></span><br><span class="line">​      mc[0] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[0].value = 22;</span><br><span class="line"></span><br><span class="line">​      mc[1] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[1].value = 25;</span><br><span class="line"></span><br><span class="line">​      mc[2] = new MyClass();</span><br><span class="line"></span><br><span class="line">​      mc[2].value = 10;</span><br><span class="line"></span><br><span class="line">​      Array.Sort(mc);</span><br><span class="line"></span><br><span class="line">​      foreach (MyClass ml in mc)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        Console.WriteLine(ml.value);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​//使用linq即可，不用使用compareTo</span><br><span class="line"></span><br><span class="line">Var a = from s in mc orderBy s.value select s;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  class MyClass:IComparable</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    public int value;</span><br><span class="line"></span><br><span class="line">​    public int CompareTo(object obj)//使用linq不必使用compareTO</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      var cla = (MyClass)obj;</span><br><span class="line"></span><br><span class="line">​      if (this.value &lt; cla.value) return -1;</span><br><span class="line"></span><br><span class="line">​      if (this.value &gt; cla.value) return 1;</span><br><span class="line"></span><br><span class="line">​      else return 0;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerator枚举器"><a href="#IEnumerator枚举器" class="headerlink" title="IEnumerator枚举器:"></a>IEnumerator枚举器:</h2><p>foreach的底层就是由它实现的，所以了解即可：实现该接口的都具有current，movenext()，reset()三个属性</p><p>Current：当前指针指向的对象</p><p>Movenext()：指针后移，返回bool型，新的位置有效返回true，无效返回false</p><p>Reset()：回原位</p><h2 id="IEumerable接口-枚举类"><a href="#IEumerable接口-枚举类" class="headerlink" title="IEumerable接口:枚举类"></a>IEumerable接口:枚举类</h2><p>他与集合相同，保存的类型可以是值类型也可以是引用类型，只有一个getEnumerator方法，返回对象的枚举器只有实现了该接口的类才能使用foreach，或者返回结果为IEumerable才能对其进行遍历。如果返回的集合只是用来遍历不需要修改，则返回IEumerable。如果返回的集合需要添加和删除，则返回ICollection，如果返回的集合支持排序，则需要返回Ilist。返回的结果为Ienumerable类型的一般只在Linq的返回结果中看到。</p><h2 id="Iqueryable"><a href="#Iqueryable" class="headerlink" title="Iqueryable"></a>Iqueryable</h2><p>与IEumerable差不多，前者是继承于后者的。两者的区别是在linq语句进行筛选时，使用IEumerable的集合类中的where方法是在客户端（内存）进行筛选的，而Iqueryable中的where是在服务器（数据库中进行筛选的），前者会多了一个将所有数据先加载到内存的过程，效率比较低。所以在数据库查询时推荐使用Iqueryable中的where，因为Iqueryable是在数据库服务器中进行筛选，所以会生成对应的sql语句，而前者不会。在linq中，上面传递的参数是func即委托，下面传递的expresson表达式树，具体使用哪个是根据linq查询的东西有关，如果是linq to object则选择IEumerable，如果是linq to sql则选择Iqueryable。</p><p>同时Iqueryable是延迟执行的：只有用到了foreach，tolist，toarray，min，max，count等方法的时候才会立即执行。使用延迟查询的原因是方便用户，比如根据不同的条件进行不同的查询语句，只有真正满足条件之后在用foreach进行立即查询，执行最后的遍历</p><p>Foreach举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Int[] arr = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">Foreach(int a in arr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.writeLine(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">它的底层代码如下:</span><br><span class="line"></span><br><span class="line">Int[] arr = new int[]&#123;1,2,3,4,5&#125;;</span><br><span class="line"></span><br><span class="line">IEnumerator I = arr.getEnumerator();</span><br><span class="line"></span><br><span class="line">While(i.moveNext())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">​Console.write(i.current)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.writeLine();</span><br></pre></td></tr></table></figure><p>所以在99%情况下我们完全可以使用foreach代替for，那1%的情况就是如果对集合实现增删，就必须得使用for而不能使用foreach</p><p>迭代器：它是来替代枚举器的更好的一种方法。</p><h1 id="expression与Func的区别"><a href="#expression与Func的区别" class="headerlink" title="expression与Func的区别"></a>expression与Func的区别</h1><p>使用上没有什么区别，底层有区别。但expression在生成sql代码的时候可以通过vs查看到树的结构，而Func不行,一般与数据库相关有expression，而其他情况使用func。另一个区别与Ienumerable和iquerable的区别一样，expression在筛选的时候是深入到数据库中进行筛选的，而func是将所有数据从数据库中放到内存后进行筛选的（比较慢），所以对于操作数据库的，我们一般使用expression代替func </p><h1 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h1><p>让数据处理变得更简单</p><p>常用扩展方法：凡是实现IEnumrable接口的都可以使用linq，例如，数组，集合（colletion），字典（directory），Set等。里面的每个元素作为参数传递到func方法中。</p><p>Linq：from语句指定数据源，where语句指定筛选语句，select语句指定返回的类型</p><p>from c in list where c.age &#x3D;&#x3D;20 select c;</p><p>(from c in list where c.age &gt; 20 selcet c).first();</p><p>综上比较会误认为第一种比较快，但实际上第二种效率快。因为第一种是查询了所有的age然后返回一个年龄为20的，而第二种是找到一个大于20的立刻返回。这就体现了first（）方法的效率，Take（2）方法同样，返回两个满足条件的，所以我们应该充分使用first和take方法。</p><h3 id="比如"><a href="#比如" class="headerlink" title="比如"></a>比如</h3><p>1.where方法：每一项数据都会经过测试，如果func执行的返回结果为true，则该元素就会放到返回值中，返回类型为IEnumrable,使用where意味着后面可以使用链式调用使用其他的linq表达式，比如list.where(e&#x3D;&gt;e.salary&gt;8000).Any();凡是返回IEnumrable的意味着可以进行链式编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int[] nums = new int[] &#123; 1, 2, 3, 5, 6, 7 &#125;;</span><br><span class="line">//where方法不是数组的特有方法，而是他的扩展方法，where方法会遍历集合中每个元素，对于每个元素都调用a=&gt; a&gt;10这个表达式，判断是否为true，如果为true，则把这个放到返回的集合中（lambda表达式返回结果为集合），where的参数为func委托</span><br><span class="line">            IEnumerable&lt;int&gt; result = nums.Where(a=&gt;a&gt;3);//设里面的每个元素为a，传递参数a，并判断</span><br><span class="line">            foreach(int i in result) </span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i);</span><br><span class="line">            &#125;        </span><br><span class="line"> 该方法背后的秘密,自己定义一个where方法</span><br><span class="line"> staic IEnumerable&lt;int&gt; where(IEnumrable&lt;int&gt; items,Func&lt;int,bool&gt; f)</span><br><span class="line"> &#123;</span><br><span class="line"> List&lt;int&gt; result = new List&lt;int&gt;(); //定义一个集合用来存储符合条件的数据</span><br><span class="line"> foreach(int i in items)//遍历</span><br><span class="line"> &#123;</span><br><span class="line"> if(f(i) == true)//其中委托方法里面用来判定数据是否大于3，返回类型为bool</span><br><span class="line"> &#123;</span><br><span class="line"> result.add(i); //将a&gt;3的数据装入到集合中</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return result;//返回该集合</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2.count方法：获取数据的条数，返回类型为int</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.Count(e=&gt;e.salary&gt;3000);</span><br><span class="line">等价于list.where(e=&gt;e.salary&gt;3000).Count();</span><br></pre></td></tr></table></figure><p>3.any（）方法：是否至少有一条数据返回类型为bool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义一个员工类包含，姓名年龄，性别，工资</span><br><span class="line">var items = list.where(e=&gt;e.age&gt;30);</span><br><span class="line">foreach(var emp in items)</span><br><span class="line">&#123;</span><br><span class="line">//遍历即可</span><br><span class="line">&#125;</span><br><span class="line">int count1 =list.Count(e=&gt;e.salary &gt;2000||e.age&lt;30);//获取工资大于2000，年龄小于30的员工数量</span><br><span class="line">list.Any(e=&gt;e.salary&gt;3000);//是否有大于工资大于3000的员工</span><br><span class="line">等价于list.where(e=&gt;e.salary&gt;3000).Any();</span><br></pre></td></tr></table></figure><p>4.Single()：是否只有一条满足要求的数据，并返回该条数据。返回类型为数据对应的类型，若有多条则报错</p><p>5.SingleOrDefault:最多只有一条满足要求的数据,(有0条或者1条满足条件的数据)，返回类型为数据对应的类型，若0条，则返回null而不是报错</p><p>6.First（）：至少有一条，返回第一条。若0条则报错</p><p>7.FirlstOrDefault：返回第一条或者0条。0条是返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e1 = items.Single(e=&gt;e.name==&quot;tom&quot;);//是否只有一条并返回该条数据。</span><br><span class="line">Employee e2 = items.First(e=&gt;e.age&gt;30);//返回第一条满足条件的数据</span><br><span class="line">Employee e3 = items.FirstOrDefault(e=&gt;e.age&gt;30);//</span><br></pre></td></tr></table></figure><h3 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h3><p>8.list.orderBy(e&#x3D;&gt;e.salary);&#x2F;&#x2F;正向排序，返回的是IEnumrable</p><p>9.orderByDescending();&#x2F;&#x2F;倒叙排序。返回的是IEnumrable</p><h3 id="多排序"><a href="#多排序" class="headerlink" title="多排序"></a>多排序</h3><p>10.ThenBy();&#x2F;&#x2F;前面排序完之后，再按照其他条件排序。例如Ordby(e&#x3D;e.age).ThenBy(e&#x3D;&gt;e.salary);即按照年龄排序完成之后有可能年龄相同，将年龄相同的再按照工资排序。即优先按照orderby，然后按照thenby</p><p>11.ThenByDescending();&#x2F;&#x2F;反序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEnumrable&lt;Employee&gt; itmes = list.orderBy(e=&gt;e.age);//按照年龄正向排序</span><br><span class="line">IEnumrable&lt;Employee&gt; itmes2 = list.OrderBuDescending(e=&gt;e.salary);//按照工资倒叙排序</span><br><span class="line">IEnumrable&lt;Employee&gt; itmes3 = list.orderBy(e=&gt;e.Name[e.Name.Length-1]);//根据姓名的最后一个字母排序</span><br></pre></td></tr></table></figure><h3 id="获取部分数据（分页）"><a href="#获取部分数据（分页）" class="headerlink" title="获取部分数据（分页）"></a>获取部分数据（分页）</h3><p>12.Skip(n);表示跳过n条数据，返回Ienumrable</p><p>13.Take（n）；表示获取前n条数据返回类型IEnumrable  例如List.Skip(3).Take(2);&#x2F;&#x2F;跳过三条数据获取两条数据。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>14.Max（）；list.Max(e&#x3D;&gt;e.age);&#x2F;&#x2F;获取年龄最大值</p><p>15.Min（）；</p><p>16.Average（）；</p><p>17.Sum();</p><p>18.Count();</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>19.GroupBy();返回类型IEnumrable&lt;IGrouping&lt;泛型一，泛型二&gt;&gt;</p><h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>把集合中每一项数据只获取其中的属性值，与sql中的select完全一样,之前返回结果都是一个对象，而该方法只获取对象中的属性</p><p>Select投影方法的使用：把查出来的结果映射到新的对象上，而不是在数据中进行条件查询。</p><p>投影方法是linq中的语句，对序列或者集合进行使用，返回结果为IEnumrable，意味着只能对其进行遍历，如果想转换为集合，在返回的集合后面添加toList()方法即可。</p><p>20.select(); &#x2F;&#x2F;返回类型为IEnumrable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumrable&lt;string&gt; items = list.select(e=&gt;e.Name+e.age);//</span><br><span class="line"></span><br><span class="line">foreach(string i in items)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">​console.writelin(i);</span><br><span class="line">&#125;</span><br><span class="line">var niming = list.select(e=&gt;new&#123;xingming = e.name,nianling = e.age,xingbie = e.gender?&quot;男&quot;:&quot;女&quot;&#125;)；//返回一个新建的匿名类型</span><br></pre></td></tr></table></figure><h3 id="集合类型之间相互转换"><a href="#集合类型之间相互转换" class="headerlink" title="集合类型之间相互转换"></a>集合类型之间相互转换</h3><p>21.ToArray();&#x2F;&#x2F;将IEnumrable类型转换为数组类型</p><p>22.ToList();&#x2F;&#x2F;将IEnumrable类型转换为集合类型</p><p>总结：返回类型为IEnumrable的方法：where，select，orderby，groupby，take，skip，take，groupby，select等可以使用链式调用</p><h2 id="反射："><a href="#反射：" class="headerlink" title="反射："></a>反射：</h2><p>有两种方式，一种是使用Typeof（类名）返回的类型是Type类型，里面封装了所有该类的信息，包括所有方法的集合，所有方法参数的集合等</p><p>第二种是使用对象名.getType();&#x2F;&#x2F;后返回一个Type类型，获取所有信息</p><p>MyClass ms &#x3D; new MyClass();</p><p>​      Console.WriteLine(typeof(MyClass).GetFields()[0]);</p><p>​      Console.WriteLine(ms.GetType().GetFields()[0]);</p><p>一般会使用到的地方：判断某个控件是否属于某个类型的控件</p><p>foreach(control c in Controls){&#x2F;&#x2F;遍历所有控件的集合</p><p>if(c.getType()&#x3D;&#x3D;TypeOf(TextBox)&#x2F;&#x2F;判断是否为TextBox控件</p><p>{</p><p>}</p><p>}</p><p>反射的两种作用：</p><p>1.通过反射遍历成员并调用成员</p><p>2.通过加载dll文件获取目标类型，可以通过isabstract等判断判断是否是一个类，一个接口，一个抽象类，可以通过反射创建对象等。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>对于在写程序时，程序员发现可能出现的异常有两种处理方法：</p><p>1.使用trycatchfanally</p><p>2.对于处理不了的异常则主动抛出。即throw new Exception。例如原本应该传递一个对象参数，结果传递进来一个null，则主动抛出异常</p><p>例如说，由于内存资源有限导致需要分配的内存失败了；或某个目录下本应存在的一个文件找不着了；或说不小心被零除了、内存越界了、数组越界了等等。这些错误事件存在非常大的隐患，因此程序员总需要在程序中不断加入if语句，来判断是否有异常出现，如果有，就必须要及时处理，否则可能带来意想不到的后果。但是这样一来，程序可读性差了很多，总是有许多与真正工作无关的代码，而且也给程序员增加了极大的工作负担。）</p><p>3.使用异常处理后：1、把错误处理和真正的工作分开来； 2、 代码更易组织，更清晰，复杂的工作任务更容易实现； 3、 毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了；</p><p>异常与ifelse的区别：有人说了try …catch…不就是抛出异常以文本形式显示出来么?if…else…也可以阿.else里面写showmessage不就可以么???<br>　1.首先try提捕获异常的，即异常并不是我们能预先知道的，所以不能用if什么条件来判断的。异常是需要在程序的运行中进行捕获的。<br>　　举个例子来看看吧：<br>　 int a&#x3D;200,b&#x3D;0;<br>  int c;<br>  try<br>  {<br>   c&#x3D;a&#x2F;b;<br>  }<br>  catch(…)<br>  {<br>   ShowMessage(“Can  not  devided  by  zero!”);<br>  }<br>可是如果上面的例子用if…else…，就不能够显示else后面的结果了。</p><p>  的确,  if可以进行简单的过滤,  但是,  由于机器或者说环境各异, 可能会产生一些无法预知的异常,  这是在开发阶段无法预知的, 所以就要用try…catch来捕捉,  而if是无法做到的.  </p><p>从程序结构上来说：   if…else…属于程序结构中的分支结构；   try…catch…应该属于程序结构中的顺序结构，虽然说在出现异常的时候编译器会跳到捕获异常的入口处，但这和传统意义上的if…else…结构存在根本性的差别.</p><ol start="2"><li>当不可预知有什么异常的时候，用try 当过多情况需要处理，用if就会太繁琐  </li><li><font color="red">当你需要观察的代码没有返回值的时候，if（）当中没法作判断，必须用try </font>&gt; 大致就是这3种情况。还有就是：意义不一样，异常是在运行时不定出现的。</li></ol><h2 id="特性：Attribute"><a href="#特性：Attribute" class="headerlink" title="特性：Attribute"></a>特性：Attribute</h2><p>特性实际上就是一个类，他们都继承于Attribute这个类,需要导包。</p><p>使用场景：数据验证，类上，方法上，属性上，参数上。但是对于大项目不推荐，而且自定义校验就则写起来麻烦，推荐使用fluent api的方式</p><p>常见特性：</p><p>1.类上使用：[Obsolete(“”,true)]:表明该类已经过时, [DebuggerStepThrough]:跳过调试，[Authorize]:授权特性</p><p>2.方法上使用：[HttpGet]:要求只能get提交  [HttpPost]:要求只能post提交</p><p>3.属性上使用：</p><p>【Key】:主键</p><p>【Required】:不许为空</p><p>【DisplayName(“修改姓名”)】;修改发送给前端的属性名</p><p>【StringLength(maxmumlength:50,minmumlength:20)】:字符串长度</p><p>【EmaiAddress】:Email地址格式</p><p>【Phone】:电话号码格式</p><p>【Range】数据范围</p><p>【MinLength】：字符串最小长度</p><p>【MaxLength】：字符串最大长度</p><p>【Compare】：比较是否相等</p><p>【RegularExpression】：正则表达式</p><p>在控制器中，使用if(Modelstate.isvalid){}&#x2F;&#x2F;来判断上面的特性是否验证成功。</p><p>【ForeignKey(nameof(Class))】:引入外键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">自己创建特性：</span><br><span class="line"></span><br><span class="line">​Class DefindAtrribute:Attribute&#123;</span><br><span class="line"></span><br><span class="line">​public DefindAttribute(String showInfo)&#123;</span><br><span class="line"></span><br><span class="line">​console.writelin(showInfo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当调用该特性时为[Defind(&quot;自定义特性&quot;)]</span><br></pre></td></tr></table></figure><p>所有的特性再视图-》对象浏览器下面搜索</p><p><img src="/2026/01/28/csharp%E5%AD%A6%E4%B9%A0/assets/image-20220129112920767.png" alt="image-20220129112920767"></p><h3 id="异步和多线程："><a href="#异步和多线程：" class="headerlink" title="异步和多线程："></a>异步和多线程：</h3><p>多线程：用于计算密集型</p><p>异步：用于IO密集型</p><p>例如点击一个按钮，该按钮处理的逻辑太多（比如加载网页内容过多），导致主线程阻滞，这时可以开启一个新的线程去处理该按钮，而主线程还可以处理其他的东西。</p><p>异步</p><h2 id="设计架构："><a href="#设计架构：" class="headerlink" title="设计架构："></a>设计架构：</h2><p>\1. 抽象类的构造方法设置成protect的，因为不用他创建对象。</p><p>\2. IEnumerable</p><p>\3. 优先考虑将基类或者接口作为形参</p><p>\4. 用params减少重复的形参</p><p>\5. 接口和抽象类选择：接口的功能比较单一，比如只有一个方法，而抽象类功能多样。抽象类和子类之间关系密切，包含很多相似功能，而接口和子类关系不大，子类只是为了实现接口的某一功能。</p><p>使用sealed修饰的类不能被继承</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
