<h3 id="技巧："><a href="#技巧：" class="headerlink" title="技巧："></a>技巧：</h3><p>有些控件是不能添加到图形界面上的，例如time控件，tooltip控件，到时候我们直接使用即可。</p>
<p>winform中，this指的是当前窗体的对象，而sender指的是控件</p>
<p>this.close事件和Applacation.exit()的区别：后者是关闭所有窗口，而前者是只关闭当前窗口</p>
<p>当弹出另一个窗口隐藏当前窗口，新窗口关闭时显示原来的窗口操作方法。</p>
<p>​    this.Hide();</p>
<p>​    新窗口.ShowDialog();</p>
<p>​    this.Show();    </p>
<p>当在解决方案管理器中创建第二个项目的时候，运行后发现执行的仍然是上一个项目，在新创建的项目上右键=》设为启动项目即可。</p>
<h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>窗体：</p>
<p>​    标题：外观=》text</p>
<p>窗口图标：窗口样式=》icon属</p>
<p>是否允许用户拖动更改窗体大小：布局=》autoSizeMode=》Growandshrink</p>
<p>窗体出现的位置：布局=》startPosition=&gt;居中显示</p>
<p>窗体基本事件：</p>
<p>​    控件对应的事件是在窗体进入构造方法中进入InitializeComponent()方法后会发现自动调用控件对应的事件。如果想要解绑控件，即不是运行后就自动执行该控件对应的事件，可以在事件=》属性=》load属性中删除该控件名称</p>
<p>调整容器距边界距离的三种方式：</p>
<p>1.不许用户调节窗口大小：AutoSizeMode=&gt;GrowAndShark：缺点不人性化</p>
<p>2.容器距边界调整的方式的第三种方法，是调整anchor属性：建议使用</p>
<p>3.dock:可能不太美观。</p>
<p>最大化功能关闭：max    mumBox = false</p>
<p>Winform中窗体sender参数就表示传递过来的按钮对象，默认为object类型，使用的时候我们需要将其强转。例如一个点击一个button1，平时我们是直接使用button1.text=…进行设置。而sender使用方式是Button b = (Button)sender; B.text = …返回的结果是一个类。这两种方式结果一样，但是sender只表示当前控件的对象，可以传递任意一种控件。而button1是一种指定使用哪种的方式。</p>
<p>而EventArgs表示的将鼠标的所有动作或者位置封装在该参数里面</p>
<p>每次设计winform窗体的时候，拉伸窗体的时候导致窗体与初始的窗体设置不一样。</p>
<p>解决方法：1.划分区域，使用工具箱中的容器里面的划分区域的工具。Split，table，tab等</p>
<p>2．将winform的AutoSizeMode改为GrowAndShrink,这种方式是不让用户更改窗体大小，治标不治本。</p>
<h3 id="button控件"><a href="#button控件" class="headerlink" title="button控件"></a>button控件</h3><p>Button中MouseClick事件与click事件的区别：mouseClick会接受鼠标其他按键（右键、中键、其他），而click仅支持鼠标左键的点击</p>
<h3 id="Label控件"><a href="#Label控件" class="headerlink" title="Label控件"></a>Label控件</h3><p>​        Borderstyle 为fixSingle：为里面的内容添加方框，但是文字不是居中的</p>
<p>​        Textalien:文字居中</p>
<h3 id="TextBox控件"><a href="#TextBox控件" class="headerlink" title="TextBox控件"></a>TextBox控件</h3><p>​    基本特性：</p>
<p>​        解决textBox控件可以进行纵向拖拽或者多行输入，控件图像上单击小三角形，然后选择multltyLines即可。或者修改属性中=》行为=》multiline设置为true即可</p>
<p>​        外观=》ScrollBars：当多行文本框写入的字数过多时，文本框右侧出现滚动的滚动滑块（vertual垂直滑块，both加上一个水平滑块）</p>
<p>​        当在文本框中输入密码的时候，需要将密码设置为<em>，则在属性=》行为=》passwordChars=》添加一个</em>即可（只允许设置单行文本，多行文本不允许设置）</p>
<p>弹出对话框的代码：是个静态写法：即MessageBox.show(string str);</p>
<p>​        若文本设置为只读时，设置readonly为true即可</p>
<p>​            与enable的区别：readonly允许复制内容，enable不允许</p>
<p>​            Readonly可直接看到变成灰色，enable运行后才可以</p>
<p>​            TextChange事件获取的是文本框中的所有内容</p>
<p>​            textbox添加滚动条，在属性中的scrollbars</p>
<h3 id="Datagridtext"><a href="#Datagridtext" class="headerlink" title="Datagridtext:"></a>Datagridtext:</h3><p>不让用户添加行和添加列，只展示给用户，不让用户操作，将allowUserAddRows和allowUserdeleteRows的值改为false；</p>
<p>不让用户一次选择多个单元格：将multiselect改为false；</p>
<p>每次选择一行而不是一个单元格，将selectionMode改为fullRowSelecte;</p>
<h3 id="ComboBox下拉框"><a href="#ComboBox下拉框" class="headerlink" title="ComboBox下拉框"></a>ComboBox下拉框</h3><p>​    下拉框选项，类似于枚举，选项设置：在图像选中小三角=》编辑项添加即可。第二种方式在属性=》数据=》itmes中添加枚举即可</p>
<p>如果选择下拉框的值触动事件的时候，就使用selectindexchanged，如果是手动写入的值触动事件的时候，就用textchanged事件。Selectvaluechanged表示值，枚举中可能有相同的值</p>
<p>​    获取下拉框中的值，使用Text属性或者selectItem属性其中Text返回的是字符串，而selectItem返回的是对象。</p>
<p>​            string str = comboBox1.Text;</p>
<p>​      string obj = comboBox1.SelectedItem.ToString();</p>
<p>​      MessageBox.Show(str+obj);</p>
<p>禁止用户在下拉框中输入数据：将属性中的DropDownStyle更改为dropdownlist模式。 </p>
<h3 id="checkBox复选框"><a href="#checkBox复选框" class="headerlink" title="checkBox复选框"></a>checkBox复选框</h3><p>​    修改大小：在布局=》aotusize改为false，然后可以拖动更改大小，但是意义不大。</p>
<p>​    设置默认选中，在外观=》checked改为true即可</p>
<p>​    Checkbox的三种状态：checked，unchecked，Indeterminate（树结构时，全选则显示对号，部分选择则显示篮筐，未选则为空框）</p>
<p>​    获取所有checkBox，根据源码发现，所有checkBox都放在controls这个集合里面</p>
<p>​    for(int I;i &lt; this.controls.count;i++){</p>
<p>​    CheckBox1  cb1 = (CheckBox1)this.Controls[i];</p>
<p>}</p>
<h3 id="进度条：Trackbar控件。"><a href="#进度条：Trackbar控件。" class="headerlink" title="进度条：Trackbar控件。"></a>进度条：Trackbar控件。</h3><p>修改步长：将maxxmum实际上它的大小取决于每个歌曲的时间长度，maximum是最大值，value是图片中的小游标。</p>
<p><img src="winform%E5%AD%A6%E4%B9%A0/assets/wpsD638.tmp.jpg" alt="img"> </p>
<h3 id="Progressbar（进度条）控件"><a href="#Progressbar（进度条）控件" class="headerlink" title="Progressbar（进度条）控件"></a>Progressbar（进度条）控件</h3><p><img src="winform%E5%AD%A6%E4%B9%A0/assets/image-20210228133139651.png" alt="image-20210228133139651"></p>
<p>​        基本属性：MaxNum最大值，</p>
<p>​                            minNum最小值，</p>
<p>​                            value，当前值。</p>
<p>​                            step。每次调用PerformStep方法时的进度。默认为10，调用一次增加10%，但是这种方式是固定增量，在实际应用中不可能这样应用 。所以通过操控value值进行进度</p>
<pre><code> private void button1_Click(object sender, EventArgs e)
        {
            //为button1设置后退
            if (progressBar1.Value &gt; progressBar1.Minimum)
            {
                progressBar1.Value = progressBar1.Value - progressBar1.Step;
                button1.Text = progressBar1.Value.ToString();
            }

        }

        private void button2_Click(object sender, EventArgs e)
        {
            //为button2设置前进
            //progressBar1.PerformStep();这种方法不够实际，因为他是每次固定增加一定的step
            
            //使用下面这种方法，通过操控value值进行增加
            for (int i=0; i &lt;= progressBar1.Maximum; i++)
               {  
               progressBar1.Value = i;
                }

            button1.Text = progressBar1.Value.ToString();
                
        }
</code></pre>
<h3 id="NumericUpDown（数字输入框）控件"><a href="#NumericUpDown（数字输入框）控件" class="headerlink" title="NumericUpDown（数字输入框）控件"></a>NumericUpDown（数字输入框）控件</h3><p>​    属性：只能输入数字，负号，小数点</p>
<p>​            textAlin：设置文本显示的位置，左对齐，居中，右对齐</p>
<p>​            Hexadecimal：以16进制显示数据</p>
<p>​            Increment：按向上或向下键进行增减。</p>
<p><img src="winform%E5%AD%A6%E4%B9%A0/assets/image-20210228135015953.png" alt="image-20210228135015953"></p>
<h3 id="ToolTip（提示信息）控件"><a href="#ToolTip（提示信息）控件" class="headerlink" title="ToolTip（提示信息）控件"></a>ToolTip（提示信息）控件</h3><p>​            toolTip1.InitialDelay = 1000;//悬停时间<br>​            toolTip1.AutoPopDelay = 1000;//提示保存的时间<br>​            toolTip1.AutomaticDelay = 1000;//延迟时间<br>​            toolTip1.ReshowDelay = 1000;//转换到其他控件时的时间间隔；</p>
<h3 id="Notifylcon-托盘控件"><a href="#Notifylcon-托盘控件" class="headerlink" title="Notifylcon(托盘控件)"></a>Notifylcon(托盘控件)</h3><p>就是点击最小化之后显示在桌面右下角的最小化窗口中，例如360等，注意只有为控件添加背景图片之后才能够看得见。如果想要双击之后仍然能够打开原来的窗口，则在事件doubleClick中写入Windowstate = FormWindowState.Normal即可</p>
<h3 id="ConTextMenuStrip（右键之后显示菜单）控件"><a href="#ConTextMenuStrip（右键之后显示菜单）控件" class="headerlink" title="ConTextMenuStrip（右键之后显示菜单）控件"></a>ConTextMenuStrip（右键之后显示菜单）控件</h3><h3 id="timer（时钟）控件"><a href="#timer（时钟）控件" class="headerlink" title="timer（时钟）控件"></a>timer（时钟）控件</h3><p>当调用timer.start()的时候，就会执行timer事件</p>
<h3 id="DateTimePicker（日期选择）控件"><a href="#DateTimePicker（日期选择）控件" class="headerlink" title="DateTimePicker（日期选择）控件"></a>DateTimePicker（日期选择）控件</h3><p>​    属性：Format：long（年月日），</p>
<p>​                short（xx/xx/xx），</p>
<p>​                time（时：分：秒），</p>
<p>​                custom自定义（同时设置格式属性customFormat按照yy-MM-dd HH:mm:ss）。</p>
<p><img src="winform%E5%AD%A6%E4%B9%A0/assets/image-20210228172837013.png" alt="image-20210228172837013"></p>
<h3 id="TreeView（树）控件"><a href="#TreeView（树）控件" class="headerlink" title="TreeView（树）控件"></a>TreeView（树）控件</h3><p>​            属性：Nodes  每个子节点作为一个选项。最直接的例子是windows中的注册表</p>
<p>​                        HotTracking：移动至该节点的时候，该节点的文字会自动添加下划线</p>
<p><img src="winform%E5%AD%A6%E4%B9%A0/assets/image-20210228180018611.png" alt="image-20210228180018611"></p>
<pre><code>private void button1_Click(object sender, EventArgs e)
        {
            //添加节点第一中方式
            treeView1.Nodes.Add(&quot;添加的第一个节点&quot;);

            //第二种方式
            TreeNode tn = new TreeNode();
            tn.Name = &quot;tn2&quot;;
            tn.Text = &quot;第二个节点&quot;;
            treeView1.Nodes.Add(tn);
        }

        private void button2_Click(object sender, EventArgs e)
        {
            //移除最后一个节点
            treeView1.Nodes.RemoveAt(treeView1.Nodes.Count-1);
        }
</code></pre>
<h3 id="LIstVIew（列表）控件"><a href="#LIstVIew（列表）控件" class="headerlink" title="LIstVIew（列表）控件"></a>LIstVIew（列表）控件</h3><p>属性：view：显示模式，常用为details</p>
<p>项：就是行（每个ListViewItem就是一行）。Items中的列就是列（SubItems是子列）</p>
<p>Gridines:显示出网格</p>
<h3 id="单选框radioButton"><a href="#单选框radioButton" class="headerlink" title="单选框radioButton"></a>单选框radioButton</h3><p>​    Checked的属性：true和false,默认选中和非默认选中</p>
<h3 id="GroupBox的作用："><a href="#GroupBox的作用：" class="headerlink" title="GroupBox的作用："></a>GroupBox的作用：</h3><p>1.为radioBox划定区域,控制整个界面的整体边界。</p>
<p>2.为其他控件划定区域    ，将其他控件直接拖到gruopBox上即可，相当于背景墙一样。</p>
<p>容器的作用：</p>
<p>1， 当需往页面上使用代码添加控件的时候，容器的作用就体现出来了，使用使用容器中的添加方法进行控件的操作。例如groupbox，panel等。容器上面的控件就属于容器的一种子控件。如果不使用容器，那么无法动态加载控件。比如说抽奖系统抽取哪个人就在容器上添加某个人图片。</p>
<p>2， 所有控件需要整体移动的时候体现出容器的作用。</p>
<p>3， Dock的作用：第一个控件占用了一部分区域，那么第二个控件就占用剩下的区域，而不是占用整个父容器的区域。</p>
<h3 id="ListBox：列表框"><a href="#ListBox：列表框" class="headerlink" title="ListBox：列表框"></a>ListBox：列表框</h3><p>与多行的textBox差不多，只不过ListBox里面的数据是一个数组，每一行是个数组元素。它集合了textBox和comboBox的所有优点。即多行同时显示和每行数据都是个数组元素。不管是listbox还是combox等这些存放集合的控件，里面的行集合就是items属性。</p>
<p>​    获取所选中的所有对象集合object o = listBox1.SelectedItems;</p>
<p>​    往listbox中添加数据：fileName是个string数组</p>
<p>foreach (string item in fileName)</p>
<p>​        {</p>
<p>​          listBox1.Items.Add(item);//往listbox中添加</p>
<p>​        }</p>
<p>​    Listbox中每个元素选择对应一个索引，不同于自己设置的数组，listbox中selectIndex就是高亮显示的对应的元素(即被激活的元素)。对其进行赋值就是激活哪个元素。使用listbox.selectIndex = listBox.selectIndex-1本身就是个错误，因为该索引要求最小为0，否则报异常，即使使用ifelse语句排除，上面这个索引本身已经发生了改变无法规避，所以借用第三方变量i,进行取值和赋值操作。（在音乐播放器项目中有所体现）</p>
<p>​    Listbox中的selectIndex和selectItem的区别，前者是int类型，通过赋值进行激活元素的更改。而selectItem只表示当前选中的元素，只有获取当前选中元素的名称的作用</p>
<h3 id="PictureBox图片显示"><a href="#PictureBox图片显示" class="headerlink" title="PictureBox图片显示"></a>PictureBox图片显示</h3><p>Image属性：设置显示图片的属性</p>
<p>​    为Image属性添加图片手动代码。获取文件路径之后picture.Image = Image.FromFile(Path);//Path为图片的路径</p>
<p>​    Sizemode属性：显示图片的方式，normal（不做任何效果显示），stretchImage铺满整个图片控件（通常使用这个模式），AntoSize：自动大小（控件的大小随着图片的大小而改变）CenterImage：显示中间。Zoom：缩放</p>
<h3 id="Timer控件"><a href="#Timer控件" class="headerlink" title="Timer控件"></a>Timer控件</h3><p>​    Interval：改为1000，每次间隔时间为1秒，它只有一个tick事件，timer1.enable = true开始调用tick事件。即在其他方法中写入timer1.enable = true开始按照设定间隔1秒执行tick里面的代码。</p>
<p>OpenFileDialog和FileBrowerDialog文件选择控件</p>
<p>注意，是在其他控件的click事件中，调用打开文件的方法</p>
<h3 id="listview"><a href="#listview" class="headerlink" title="listview"></a>listview</h3><p>属性：每一个ListViewItem都是一行，它的text属性，就是该行该列中对应的内容，它的subItem都是该位置对应的后面的所有列</p>
<p>​    CheckBox属性设为true，同时listViewItem中的checked属性设为true，才会出现默认选中框</p>
<p>​    FullRowSelect：整行都被选中</p>
<p>​    第一列只能左对齐，其余列可以设置居中显示</p>
<p>​    Items：是所有行的集合，ListViewItem是一行，也就是所有列的集合。</p>
<p><img src="file:///C:\Users\hasee\AppData\Local\Temp\ksohtml\wpsC2CE.tmp.jpg" alt="img"> </p>
<h3 id="ContextMenustrip"><a href="#ContextMenustrip" class="headerlink" title="ContextMenustrip:"></a>ContextMenustrip:</h3><p>右键时候出现的菜单。将ContextMenuStrip绑定在listView上方法：当添加ContextMenuStrip控件之后，默认在ListView属性中会有ContextMenustrip属性，将其选择即可</p>
<pre><code>int i = 2;

​    private void 添加ToolStripMenuItem_Click(object sender, EventArgs e)

​    {

​      //当右键点击添加的时候，为表格添加一列

​      ListViewItem lvi = new ListViewItem();

​      lvi.Text = i.ToString() ;//第一列

​      lvi.SubItems.Add(&quot;3&quot;);//第二例

​      lvi.SubItems.Add(&quot;3&quot;);//第三列

​      lvi.SubItems.Add(&quot;3&quot;);//第四列

​      lvi.SubItems.Add(&quot;3&quot;);//第五列

​      listView1.Items.Add(lvi);

​      i++;

​    }

 
</code></pre>
<pre><code>  private void 删除ToolStripMenuItem_Click(object sender, EventArgs e)

​    {

​      //从第一个开始进行删除

​      ListViewItem lvi = listView1.SelectedItems[i];

​      listView1.Items.Remove(lvi);

 

​    }
</code></pre>
<h3 id="TreeView："><a href="#TreeView：" class="headerlink" title="TreeView："></a>TreeView：</h3><p>最直观的是注册表</p>
<p>​    Showlines:是否显示树控件的引导线。</p>
<p>FullRowSelect:点击文字所在的行也可以进行展开显示</p>
<p>​    Nodes:是所有节点的集合</p>
<p>​    ToolTip：气泡提示控件</p>
<p>​    TooltipIcon:提示方式。信息，警告，错误。</p>
<p>手动添加节点的代码：</p>
<p>​    TreeNode ankai = treeView1.Nodes[0].Nodes[4];</p>
<p>​      ankai.Nodes.Add(new TreeNode() { </p>
<p>​        Text = “保利通”</p>
<p>​      });</p>
<p>​    ShowPlusMinus:设置是否显示文字前面的折叠符号。去掉前面的折叠符号后，发现点击后不能显示其子项：解决方法：使用AfterSelect事件，在方法中显示子项即可，实现代码如下：</p>
<pre><code>    private void treeView1_AfterSelect(object sender, TreeViewEventArgs e)  {

​      TreeNode tn = e.Node;//获取当前点击的node

​      if (tn != null) { 

​        //判断是否有子节点

​        //判断是否为根节点，是：展开子项，否（子节点）：全部展开

​        if (tn.Nodes.Count &gt; 0)

​        {

​          if (tn.Parent == null)//该节点是否为根节点

​          {

​            tn.Expand();//展开二级节点

​          }

​          else {//若点击的是为二级节点，展开后折叠

​            if (tn.IsExpanded)

​            {

​              tn.Collapse();

​            }

​            else{ //全部展开

​              tn.ExpandAll();

​            }

​          }

​        }

​      }

​       }
</code></pre>
<p>​    </p>
<h3 id="Toolstripcombobox-他是toolstrip中的一个子控件"><a href="#Toolstripcombobox-他是toolstrip中的一个子控件" class="headerlink" title="Toolstripcombobox,他是toolstrip中的一个子控件"></a>Toolstripcombobox,他是toolstrip中的一个子控件</h3><p>为toolstripcombox添加选择值，在属性中的item添加集合即可。 而combobox是一个单独的控件。</p>
<h3 id="Panel面板"><a href="#Panel面板" class="headerlink" title="Panel面板"></a>Panel面板</h3><p>相当于背景板，可以批量操作子控件。与GroupBox的区别是GroupBox在左上角有个标签提示，如果使用Dork属性发现一个控件被另一个控件覆盖了了，那么右键将其置于底层即可。·</p>
<h3 id="SplitContainer"><a href="#SplitContainer" class="headerlink" title="SplitContainer"></a>SplitContainer</h3><p>可以在运行时进行拖拉的控件，类似于QQ窗口一样。点击右上角的小三角可以将水平更改为垂直</p>
<p>属性isSplitterFixed为false时设置可以拖动，true时不可以拖动</p>
<p><img src="winform%E5%AD%A6%E4%B9%A0/assets/wps3239.tmp.jpg" alt="img"> </p>
<h3 id="Tabcontrol选项卡"><a href="#Tabcontrol选项卡" class="headerlink" title="Tabcontrol选项卡"></a>Tabcontrol选项卡</h3><p><img src="winform%E5%AD%A6%E4%B9%A0/assets/wps323A.tmp.jpg" alt="img"> </p>
<h3 id="用户控件：（UserControl）。"><a href="#用户控件：（UserControl）。" class="headerlink" title="用户控件：（UserControl）。"></a>用户控件：（UserControl）。</h3><p>将窗体中已经布局好界面一部分单独创立一个文件独立出去，这样可以节约主窗体中的代码，使用的时候直接引用即可。样式与panel差不多</p>
<p>用户控件UserControls，相当于一个不带边框的窗体</p>
<p>拆分层级的方法：</p>
<p>1． 如果两个控件交互较多时，选择单一层级</p>
<p>2． 如果当前界面不确定因素较多（功能改动/界面改动）    较多，采用多层级方式</p>
<p>​    Usercontrol作为一个独立控件，拥有自己的设计界面和代码，它是一个控件，可以在工具箱中引用，但是它是一个独立的文件。Panel则不是。</p>
<p>​    UserControl拥有的load事件，但是panel没有。Load时间当usercontrol复制到窗体的时候会自动执行。</p>
<p>​    UserControl可以跨窗体使用，但是panel没有。</p>
<p>​    复制之后usercontrol可以将里面的所有控件和代码进行复制，而panel仅仅能复制panel一个控件，里面的内容和代码无法赋值</p>
<p>引用方法：文件资源管理器项目文件夹右键生成，在工具箱中会自动出现usercontrol控件</p>
<p>​    优点：加载不同控件的集合，对主窗体的功能进行分区，从而加载不同的控件。类似于GroudBox</p>
